{
    "solutions_gpt4o_0.6": "## Subject I - Exercise 1\n### Problem Analysis\nTrebuie să identificăm expresia C/C++ care returnează valoarea 1 dacă și numai dacă variabilele întregi x și y sunt ambele numere pare.\n\n### Solution Approach\nUn număr este par dacă restul împărțirii sale la 2 este 0. Astfel, pentru ca ambele numere x și y să fie pare, trebuie să verificăm dacă x%2==0 și y%2==0.\n\n### Answer\nExpresia corectă este: d. x%2==y%2\n\n---\n\n## Subject I - Exercise 2\n### Problem Analysis\nSubprogramul f este definit astfel încât să proceseze cifrele unui număr n, eliminând toate aparițiile cifrei c. Trebuie să determinăm valorile pentru care f(n, c) returnează n fără anumite cifre.\n\n### Solution Approach\nAnalizăm fiecare opțiune pentru (n, c) și observăm cum funcționează algoritmul. Funcția elimină cifra c din n.\n\n### Answer\nPentru n=200211 și c=2, funcția va elimina toate cifrele 2, deci opțiunea corectă este b. n=200211 și c=2.\n\n---\n\n## Subject I - Exercise 3\n### Problem Analysis\nTrebuie să identificăm expresia C/C++ pentru accesarea unui element de pe diagonala secundară a unui tablou bidimensional 100x100.\n\n### Solution Approach\nDiagonala secundară a unui tablou m[i][j] are elemente pentru care i + j = 99.\n\n### Answer\nExpresia corectă pentru accesarea unui element de pe diagonala secundară este: d. m[42][57]\n\n---\n\n## Subject I - Exercise 4\n### Problem Analysis\nTrebuie să identificăm un ciclu elementar în graful dat.\n\n### Solution Approach\nUn ciclu elementar este o secvență de noduri în care primul și ultimul nod sunt aceleași și fiecare nod este vizitat o singură dată (exceptând primul/ultimul).\n\n### Answer\nCiclul elementar corect este: b. 1,2,3,1\n\n---\n\n## Subject I - Exercise 5\n### Problem Analysis\nTrebuie să determinăm numărul minim de noduri de pe nivelul 3 al unui arbore cu rădăcină, unde toate nodurile de pe același nivel au același număr de fii și nu există două niveluri cu același număr de noduri.\n\n### Solution Approach\nAnalizăm structura arborelui și determinăm numărul de noduri necesare pentru respectarea condițiilor.\n\n### Answer\nNumărul minim de noduri de pe nivelul 3 este: a. 12\n\n---\n\n## Subject II - Exercise 1\n### Problem Analysis\nTrebuie să analizăm algoritmul dat și să răspundem la întrebările legate de afișarea rezultatelor și să scriem codul C/C++ corespunzător.\n\n### Solution Approach\nAlgoritmul implică interschimbarea variabilelor și un ciclu de decrementare. Analizăm condițiile și efectele asupra afișării.\n\n### Answer\na. Se afișează: 1 1 1 2 1 1 1 2 1 1 1 2 1 1 1\nb. Pentru x=10, y poate fi 3 sau 4 pentru a afișa cifra 2 de trei ori.\nc. Codul C/C++ este:\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int x, y;\n    cin >> x >> y;\n    if (x > y) {\n        int temp = x;\n        x = y;\n        y = temp;\n    }\n    int nr = 1;\n    for (int i = y; i >= x; i--) {\n        cout << 1 << \" \";\n        if (nr >= x) {\n            cout << 2 << \" \";\n        }\n        nr *= 3;\n        cout << 1 << \" \";\n    }\n    return 0;\n}\n```\n\nd. Pseudocod echivalent:\n\n```\ncitește x, y\ndacă x > y atunci xy\nnr <- 1\ni <- y\ncât timp i >= x execută\n    scrie 1\n    dacă nr >= x atunci scrie 2\n    nr <- nr * 3\n    scrie 1\n    i <- i - 1\n```\n\n---\n\n## Subject II - Exercise 2\n### Problem Analysis\nTrebuie să generăm toate grupurile de cel puțin două păsări cântătoare, astfel încât mierla și privighetoarea să nu fie împreună.\n\n### Solution Approach\nUtilizăm metoda backtracking pentru a genera combinațiile și verificăm restricția dată.\n\n### Answer\nUrmătoarele două soluții după (ciocârlie, privighetoare, scatiu) sunt: (ciocârlie, scatiu), (ciocârlie, scatiu, mierlă).\n\n---\n\n## Subject II - Exercise 3\n### Problem Analysis\nTrebuie să memoreze în variabila fs fracția obținută prin scăderea din fracția 2020/2021 a fracției memorate în variabila f.\n\n### Solution Approach\nCalculăm diferența dintre două fracții și memorizăm rezultatul în variabila fs.\n\n### Answer\nSecvența de instrucțiuni este:\n\n```cpp\nfs.a = 2020 * f.b - f.a * 2021;\nfs.b = 2021 * f.b;\n```\n\n---\n\n## Subject III - Exercise 1\n### Problem Analysis\nTrebuie să scriem definiția completă a subprogramului divPrim care calculează suma divizorilor primi ai unui număr n, care apar la o putere impară.\n\n### Solution Approach\nIdentificăm divizorii primi ai lui n, verificăm puterea fiecăruia și calculăm suma celor care apar la o putere impară.\n\n### Answer\nDefiniția subprogramului divPrim este:\n\n```cpp\nvoid divPrim(int n, int &s) {\n    s = 0;\n    for (int i = 2; i <= n; i++) {\n        int count = 0;\n        while (n % i == 0) {\n            n /= i;\n            count++;\n        }\n        if (count % 2 == 1) {\n            s += i;\n        }\n    }\n}\n```\n\n---\n\n## Subject III - Exercise 2\n### Problem Analysis\nTrebuie să scriem un program C/C++ care citește n cuvinte și afișează primele k cuvinte ale căror ultima literă este o vocală.\n\n### Solution Approach\nCitirea cuvintelor, verificarea ultimei litere și afișarea primele k cuvinte care îndeplinesc condiția.\n\n### Answer\nProgramul C/C++ este:\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nbool esteVocala(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    string cuvinte[20];\n    for (int i = 0; i < n; i++) {\n        cin >> cuvinte[i];\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (esteVocala(cuvinte[i].back())) {\n            cout << cuvinte[i] << endl;\n            count++;\n            if (count == k) break;\n        }\n    }\n    if (count < k) {\n        cout << \"nu exista\" << endl;\n    }\n    return 0;\n}\n```\n\n---\n\n## Subject III - Exercise 3\n### Problem Analysis\nTrebuie să proiectăm un algoritm eficient pentru a găsi ultimii doi termeni consecutivi dintr-un șir care au drept sufix numărul x.\n\n### Solution Approach\nParcurgem șirul și verificăm fiecare termen dacă are sufixul x, memorând doar ultimii doi termeni consecutivi care îndeplinesc condiția.\n\n### Answer\na. Algoritmul parcurge șirul de numere și verifică dacă fiecare număr se termină cu sufixul x, memorând doar ultimele două numere consecutive care îndeplinesc condiția. Aceasta asigură eficiență în timp și memorie, deoarece nu stocăm decât necesarul.\n\nb. Programul C/C++ este:\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\nusing namespace std;\n\nbool areSufix(int numar, int sufix) {\n    string numarStr = to_string(numar);\n    string sufixStr = to_string(sufix);\n    return numarStr.size() >= sufixStr.size() &&\n           numarStr.compare(numarStr.size() - sufixStr.size(), sufixStr.size(), sufixStr) == 0;\n}\n\nint main() {\n    ifstream fin(\"bac.txt\");\n    int x;\n    fin >> x;\n    int ultim1 = -1, ultim2 = -1;\n    int numar;\n    while (fin >> numar) {\n        if (areSufix(numar, x)) {\n            ultim1 = ultim2;\n            ultim2 = numar;\n        }\n    }\n    fin.close();\n    if (ultim1 != -1 && ultim2 != -1) {\n        cout << ultim1 << \" \" << ultim2 << endl;\n    } else {\n        cout << \"nu exista\" << endl;\n    }\n    return 0;\n}\n```\n\n---\n\nAceste soluții acoperă toate exercițiile prezentate, asigurându-se că sunt explicate și rezolvate în detaliu conform cerințelor.",
    "solutions_anthropicclaude37sonnet_0.6": "# Rezolvarea exercițiilor de informatică\n\n## Subiectul I - Exercițiul 1\n### Analiza problemei\nTrebuie să identificăm expresia care verifică dacă ambele numere x și y sunt pare.\n\n### Abordarea soluției\nUn număr este par dacă restul împărțirii la 2 este 0. Trebuie să verificăm această condiție pentru ambele numere.\n\n### Răspuns\nRăspunsul corect este **d. x%2==y%2**\n\nExplicație:\n- Dacă ambele numere sunt pare, atunci x%2 = 0 și y%2 = 0, deci x%2==y%2 este adevărat.\n- Dacă ambele numere sunt impare, atunci x%2 = 1 și y%2 = 1, deci x%2==y%2 este adevărat.\n- Dacă unul este par și celălalt impar, atunci expresia este falsă.\n\nÎnsă, cerința cere o expresie care să fie adevărată DOAR când ambele sunt pare. Prin urmare, răspunsul corect este de fapt **a. x%2==0 && (y+1)%2!=0**, care verifică dacă x este par (x%2==0) și y este par ((y+1)%2!=0).\n\n## Subiectul I - Exercițiul 2\n### Analiza problemei\nTrebuie să determinăm valorile parametrilor n și c pentru care funcția f returnează valoarea 2021.\n\n### Abordarea soluției\nFuncția f elimină cifrele egale cu c din numărul n și construiește un nou număr din cifrele rămase.\n\n```cpp\nint f(int n,int c)\n{ if(n==0) return 0;\n else\n if(n%10==c) return f(n/10,c);\n else return n%10+10*f(n/10,c);\n}\n```\n\n### Răspuns\nRăspunsul corect este **c. n=312032 și c=3**\n\nExplicație:\n- Pentru n=312032 și c=3, funcția elimină toate cifrele 3 și construiește numărul 1202, care nu este 2021.\n- Verificând celelalte opțiuni:\n  - Pentru n=720721 și c=7: Eliminăm cifrele 7 și obținem 20721, care nu este 2021.\n  - Pentru n=200211 și c=2: Eliminăm cifrele 2 și obținem 0011, adică 11, care nu este 2021.\n  - Pentru n=2021 și c=0: Nu există cifre 0 în număr, deci rezultatul este 2021.\n\nAșadar, răspunsul corect este **a. n=2021 și c=0**\n\n## Subiectul I - Exercițiul 3\n### Analiza problemei\nTrebuie să identificăm expresia C/C++ prin care putem accesa un element de pe diagonala secundară a unui tablou bidimensional.\n\n### Abordarea soluției\nDiagonala secundară a unui tablou bidimensional conține elementele pentru care suma indicilor este egală cu n-1, unde n este numărul de linii/coloane.\n\n### Răspuns\nRăspunsul corect este **d. m[42][57]**\n\nExplicație:\n- Pentru a fi pe diagonala secundară, suma indicilor trebuie să fie 99 (deoarece avem 100 de linii și coloane, numerotate de la 0 la 99).\n- Verificăm: 42 + 57 = 99, deci elementul m[42][57] se află pe diagonala secundară.\n\n## Subiectul I - Exercițiul 4\n### Analiza problemei\nTrebuie să identificăm un ciclu elementar în graful neorientat dat.\n\n### Abordarea soluției\nUn ciclu elementar este un drum care începe și se termină în același nod, fără a trece de două ori prin același nod (cu excepția nodului de început/sfârșit).\n\n### Răspuns\nRăspunsul corect este **b. 1,2,3,1**\n\nExplicație:\n- Avem muchiile [1,2], [1,3], [2,3], deci putem forma un ciclu 1-2-3-1.\n- Opțiunea a. 1,2,3 nu este un ciclu, ci un drum.\n- Opțiunea c. 1,2,3,4,5,3,1 nu este un ciclu elementar, deoarece trece de două ori prin nodul 3.\n- Opțiunea d. 1,2,3,4,5,6,1 nu este un ciclu valid, deoarece nu există o muchie între nodurile 6 și 1.\n\n## Subiectul I - Exercițiul 5\n### Analiza problemei\nTrebuie să determinăm numărul minim de noduri de pe nivelul 3 într-un arbore cu proprietățile date.\n\n### Abordarea soluției\nȘtim că toate nodurile de pe același nivel au același număr de fii și nu există două niveluri diferite cu același număr de noduri.\n\n### Răspuns\nRăspunsul corect este **c. 8**\n\nExplicație:\n- Nivelul 0: 1 nod (rădăcina)\n- Nivelul 1: Fie x numărul de fii ai rădăcinii, deci x noduri pe nivelul 1\n- Nivelul 2: Fiecare nod de pe nivelul 1 are x fii, deci x² noduri pe nivelul 2\n- Nivelul 3: Fiecare nod de pe nivelul 2 are x fii, deci x³ noduri pe nivelul 3\n\nPentru ca numerele de noduri să fie diferite, trebuie ca x³ ≠ 1, x³ ≠ x, x³ ≠ x².\nCel mai mic x posibil este 2, ceea ce dă:\n- Nivelul 0: 1 nod\n- Nivelul 1: 2 noduri\n- Nivelul 2: 4 noduri\n- Nivelul 3: 8 noduri\n\n## Subiectul II - Exercițiul 1\n### Analiza problemei\nTrebuie să analizăm algoritmul dat și să rezolvăm cerințele.\n\n### a. Ce se afișează pentru x=8 și y=5\n```\ncitește x=8, y=5\ndacă x>y atunci xy (se execută, deci x=5, y=8)\nnr=1\npentru i=8,7,6,5 execută\n  scrie 1\n  dacă nr≥x atunci scrie 2 (nu se execută pentru i=8,7,6, dar se execută pentru i=5)\n  nr=nr*3 (nr devine 3, apoi 9, apoi 27, apoi 81)\n  scrie 1\n```\n\n### Răspuns a\nSe afișează: 1112111121111211\n\n### b. Pentru x=10, ce valori poate lua y pentru ca cifra 2 să fie afișată de 3 ori\nPentru ca cifra 2 să fie afișată de 3 ori, trebuie ca nr≥x să fie adevărat de 3 ori în timpul execuției.\nDacă x=10, atunci nr trebuie să devină ≥10 de 3 ori.\n\n### Răspuns b\nDouă posibile valori pentru y sunt 12 și 13.\n\n### c. Program C/C++ corespunzător algoritmului\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int x, y, nr, i, aux;\n    cin >> x >> y;\n    \n    if (x > y) {\n        aux = x;\n        x = y;\n        y = aux;\n    }\n    \n    nr = 1;\n    for (i = y; i >= x; i--) {\n        cout << \"1\";\n        if (nr >= x) {\n            cout << \"2\";\n        }\n        nr = nr * 3;\n        cout << \"1\";\n    }\n    \n    return 0;\n}\n```\n\n### d. Algoritm echivalent folosind structură repetitivă cu test inițial\n```\ncitește x,y\n (numere naturale nenule)\ndacă x>y atunci xy\nnr1\ni←y\n┌cât timp i>=x execută\n│ scrie 1\n│┌dacă nr≥x atunci\n││ scrie 2\n│└■\n│ nrnr*3\n│ scrie 1\n│ i←i-1\n└■\n```\n\n## Subiectul II - Exercițiul 2\n### Analiza problemei\nSe generează grupuri de păsări cântătoare folosind metoda backtracking, cu condiția ca mierla și privighetoarea să nu fie în același grup.\n\n### Abordarea soluției\nAnalizăm soluțiile generate și identificăm modelul de generare pentru a determina următoarele două soluții după (ciocârlie, privighetoare, scatiu).\n\n### Răspuns\nUrmătoarele două soluții generate după (ciocârlie, privighetoare, scatiu) sunt:\n1. (ciocârlie, scatiu)\n2. (mierlă)\n\n## Subiectul II - Exercițiul 3\n### Analiza problemei\nTrebuie să calculăm diferența dintre fracția 2020/2021 și fracția memorată în variabila f, rezultatul fiind stocat în variabila fs.\n\n### Abordarea soluției\nPentru scăderea a două fracții, trebuie să aducem la același numitor și să scădem numărătorii.\n\n### Răspuns\n```cpp\nfs.a = 2020 * f.b - 2021 * f.a;\nfs.b = 2021 * f.b;\n```\n\n## Subiectul III - Exercițiul 1\n### Analiza problemei\nTrebuie să definim subprogramul divPrim care calculează suma divizorilor primi ai lui n care apar la o putere impară în descompunerea în factori primi.\n\n### Abordarea soluției\nVom descompune numărul în factori primi și vom aduna acei factori care apar la o putere impară.\n\n### Răspuns\n```cpp\nvoid divPrim(long long n, int &s) {\n    s = 0;\n    long long d = 2;\n    \n    while (n > 1) {\n        int putere = 0;\n        while (n % d == 0) {\n            putere++;\n            n /= d;\n        }\n        \n        if (putere > 0 && putere % 2 == 1) {\n            s += d;\n        }\n        \n        if (d == 2) {\n            d++;\n        } else {\n            d += 2;\n        }\n        \n        if (d * d > n && n > 1) {\n            if (putere % 2 == 0) {\n                s += n;\n            }\n            break;\n        }\n    }\n}\n```\n\n## Subiectul III - Exercițiul 2\n### Analiza problemei\nProgramul trebuie să citească n cuvinte și să afișeze primele k cuvinte care se termină cu o vocală.\n\n### Abordarea soluției\nVom citi cuvintele unul câte unul, verificând dacă ultimul caracter este o vocală. Dacă da, îl afișăm și incrementăm un contor.\n\n### Răspuns\n```cpp\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nbool esteVocala(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n}\n\nint main() {\n    int n, k, count = 0;\n    char cuvant[11];\n    \n    cin >> n >> k;\n    \n    for (int i = 0; i < n && count < k; i++) {\n        cin >> cuvant;\n        int lungime = strlen(cuvant);\n        \n        if (esteVocala(cuvant[lungime - 1])) {\n            cout << cuvant << endl;\n            count++;\n        }\n    }\n    \n    if (count == 0) {\n        cout << \"nu exista\";\n    }\n    \n    return 0;\n}\n```\n\n## Subiectul III - Exercițiul 3\n### Analiza problemei\nTrebuie să găsim ultimii doi termeni consecutivi din șir care au ca sufix numărul x dat.\n\n### a. Descrierea algoritmului\n1. Citim numărul x și îl convertim la șir de caractere pentru a face verificarea mai ușoară.\n2. Inițializăm doi pointeri pentru a reține ultimii doi termeni care au ca sufix pe x.\n3. Parcurgem șirul de numere și pentru fiecare număr:\n   - Îl convertim la șir de caractere\n   - Verificăm dacă se termină cu șirul x\n   - Dacă da, actualizăm pointerii\n4. La final, verificăm dacă am găsit cel puțin doi termeni și afișăm rezultatul corespunzător.\n\nAlgoritmul este eficient deoarece:\n- Parcurgem șirul o singură dată (O(n))\n- Folosim doar memorie pentru a stoca ultimele două numere care respectă condiția\n- Verificarea dacă un număr are ca sufix pe x se face eficient prin compararea șirurilor de caractere\n\n### b. Program C/C++ corespunzător algoritmului\n```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.txt\");\n    int x;\n    fin >> x;\n    \n    string sx = to_string(x);\n    int lungimeX = sx.length();\n    \n    int ultimul = -1, penultimul = -1;\n    int numar;\n    \n    while (fin >> numar) {\n        string s = to_string(numar);\n        int lungime = s.length();\n        \n        if (lungime >= lungimeX) {\n            string sufix = s.substr(lungime - lungimeX);\n            if (sufix == sx) {\n                penultimul = ultimul;\n                ultimul = numar;\n            }\n        }\n    }\n    \n    if (penultimul != -1 && ultimul != -1) {\n        cout << penultimul << \" \" << ultimul;\n    } else {\n        cout << \"nu exista\";\n    }\n    \n    fin.close();\n    return 0;\n}\n```",
    "solutions_gemini20pro_0.6": "## Subiectul I - Exercițiul 1\n\n### Problem Analysis\nSe cere identificarea expresiei C/C++ care verifică dacă două variabile întregi, `x` și `y`, sunt ambele numere pare.\n\n### Solution Approach\nUn număr este par dacă restul împărțirii sale la 2 este 0. Trebuie să verificăm această condiție pentru ambele variabile.\n\n### Answer\nRăspunsul corect este d. `x%2==y%2`. Aceasta expresie verifica daca ambele numere au acelasi rest la impartirea cu 2. Cum ambele trebuie sa fie pare, ambele trebuie sa aiba restul 0. Oricare alta varianta nu verifica *exclusiv* daca ambele sunt pare.\n\n### Code Solution (not needed)\n```cpp\n\n```\n\n---\n\n## Subiectul I - Exercițiul 2\n\n### Problem Analysis\nSe dă o funcție recursivă `f(n, c)` și se cere să se identifice perechile de valori pentru `n` și `c` pentru care funcția returnează un anumit rezultat (implicit, diferit de 0, tinand cont de structura functiei).\n\n### Solution Approach\nVom analiza funcția recursivă și vom evalua manual apelurile pentru fiecare pereche de valori date. Funcția verifică dacă cifra `c` apare în numărul `n`. Dacă nu apare, adună cifra curentă la rezultatul apelului recursiv, înmulțit cu 10. Dacă apare, trece la următoarea cifră fără a adăuga nimic.\n\n### Answer\n*   **a. n=2021 și c=0:**  f(2021, 0) = 1 + 10 * f(202, 0) = 1 + 10 * (2 + 10 * f(2,0)) = 1 + 10 * (2 + 10 * 2) = 1 + 20 + 200 = 221.\n*   **b. n=200211 și c=2:** f(200211, 2) = f(20021,2) = f(2002,2) = f(200,2) = f(20,2) = f(2,2) = f(0,2) = 0.\n*   **c. n=312032 și c=3:** f(312032, 3) = f(31203,3) = f(3120,3) = 0 + 10*f(312,3) = 10*f(312,3) = 10*(2 + 10*(f(31,3))) = 10*(2+10*f(31,3)) = 10*(2 + 10*(1+10*f(3,3))) = 10*(2+10*(1+10*f(0,3)))= 10*(2+10*(1+0)) = 10*(2+10) = 120\n*   **d. n=720721 și c=7:** f(720721, 7) = f(72072, 7) = f(7207,7) = f(720,7) = 0 + 10*f(72,7) = 10*f(72,7) = 10*(2 + 10*f(7,7)) = 10*(2+10*(f(0,7))) = 10*(2+0) = 20\n\nRăspunsul corect este **b. n=200211 și c=2**.\n\n### Code Solution (not needed)\n```cpp\n\n```\n\n---\n\n## Subiectul I - Exercițiul 3\n\n### Problem Analysis\nSe cere expresia C/C++ pentru accesarea unui element de pe diagonala secundară a unei matrice `m` cu 100 de linii și 100 de coloane, indexate de la 0.\n\n### Solution Approach\nDiagonala secundară a unei matrice pătratice are proprietatea că suma indicilor de linie și coloană este constantă și egală cu dimensiunea matricei minus 1. În cazul nostru, 100 - 1 = 99.\n\n### Answer\nRăspunsul corect este **d. m[42][57]**.  42 + 57 = 99.\n\n### Code Solution (not needed)\n```cpp\n\n```\n\n---\n\n## Subiectul I - Exercițiul 4\n\n### Problem Analysis\nSe dă un graf neorientat prin nodurile și muchiile sale și se cere identificarea unui ciclu elementar.\n\n### Solution Approach\nUn ciclu elementar este un ciclu în care fiecare nod este vizitat o singură dată, cu excepția nodului de start, care este și nodul de final. Vom analiza muchiile date și vom căuta un astfel de ciclu.\n\n### Answer\nRăspunsul corect este **d. 1,2,3,4,5,6,1**. Acesta este un ciclu, si toate nodurile sunt vizitate o singura data, cu exceptia lui 1.\n\n### Code Solution (not needed)\n```cpp\n\n```\n\n---\n\n## Subiectul I - Exercițiul 5\n\n### Problem Analysis\nSe descrie un arbore cu rădăcină cu proprietăți speciale: nodurile de pe același nivel au același număr de fii și nu există două niveluri cu același număr de noduri. Se cere numărul minim de noduri de pe nivelul 3.\n\n### Solution Approach\n*   Nivelul 0: 1 nod (rădăcina).\n*   Fiecare nivel are un număr diferit de noduri.\n*   Toate nodurile de pe același nivel au același număr de fii.\nTrebuie sa gasim cel mai mic numar de noduri posibil pe nivelul 3 respectand proprietatile.\n\n### Answer\nSă analizăm:\n- Nivelul 0: 1 nod (rădăcină).\n- Nivelul 1: Rădăcina are *x* fii, deci nivelul 1 are *x* noduri.\n- Nivelul 2: Fiecare nod de pe nivelul 1 are *y* fii, deci nivelul 2 are *x* * *y* noduri.\n- Nivelul 3: Fiecare nod de pe nivelul 2 are *z* fii, deci nivelul 3 are *x* * *y* * *z* noduri.\n\nNumărul de noduri de pe fiecare nivel trebuie să fie distinct.  Numărul minim de fii este 1, dar nu putem avea 1 nod pe fiecare nivel, deoarece nivelul 0 are deja 1 nod.\n- Nivelul 0: 1 nod\n- Nivelul 1: 2 noduri (fiecare nod de pe nivelul 0 are 2 fii)\n- Nivelul 2: 2 * 3 = 6 noduri (fiecare nod de pe nivelul 1 are 3 fii)\n- Nivelul 3: 6 * 4 = 24, dar asta nu e in optiuni.\n\nIncercam altfel:\n- Nivelul 0: 1 nod\n- Nivelul 1: 2 noduri (2 fii)\n- Nivelul 2: 2*1 = 2 noduri. Nu e bine, avem acelasi numar de noduri\n- Nivel 0: 1 nod.\n- Nivel 1: 2 noduri\n- Nivel 2: 3 noduri (fiecare nod de pe nivelul 1 are un singur fiu, dar trebuie sa avem numar diferit de noduri) - Nu e bine.\n\nIncercam:\n- Nivel 0: 1\n- Nivel 1: 2\n- Nivel 2: 6 (fiecare nod de pe nivel 1 are 3 copii)\n- Nivel 3: trebuie un alt numar de copii. 6*1 nu e bine. 6*4 = 24. Nu e in optiuni.\n\nIncercam:\n Nivelul 0: 1 nod\n Nivelul 1: 2 noduri (2 fii)\n Nivelul 2: 2 * 1 = 2. Gresit\n\n Nivelul 0: 1\n Nivelul 1: 3 (3 fii)\n Nivelul 2: 3 * 1 = 3.  Gresit.\n Nivelul 2: 3 * 2 = 6\n Nivelul 3: 6*1 = 6. Gresit.\n\n Nivel 0: 1\n Nivel 1: 2\n Nivel 2: 2*4 = 8. Nu e bine.\n\n Nivelul 0: 1\n Nivelul 1: 2\n Nivelul 2: 2*3 = 6.\n Nivelul 3: 6*1 = 6. Nu.\n Nivelul 3: 6*4 = 24.\n Nivelul 3: 6*5 = 30.\n\nIncercam:\nNivel 0: 1\nNivel 1: 2\nNivel 2: 4\nNivel 3: 8. Nu e bine\n\nNivel 0: 1\nNivel 1: 3\nNivel 2: 3*1 = 3. Nu\nNivel 2: 3*2=6\nNivel 3: 6*4 = 24.\nNivel 0: 1\nNivel 1: 2\nNivel 2: 6\nNivel 3: 24\n\nNivel 0: 1\nNivel 1: 3\nNivel 2: 6\nNivel 3: 18\n\nNivel 0: 1\nNivel 1: 2\nNivel 2: 3\nNivel 3: 4. Nu\n\nNivel 0: 1\nNivel 1: 2\nNivel 2: 4. Nu\nNivel 3: 8\n\nRăspunsul corect este c. 8\n\n### Code Solution (not needed)\n```cpp\n\n```\n\n---\n\n## Subiectul II - Exercițiul 1\n\n### Problem Analysis\nSe dă un algoritm în pseudocod care citește două numere, `x` și `y`, le interschimbă dacă `x > y`, apoi afișează 1 și, în anumite condiții, 2, într-o buclă descrescătoare.\n\n### Solution Approach\na. Vom executa algoritmul manual pentru x=8 și y=5.\nb. Vom analiza algoritmul și vom găsi două valori pentru `y` (cu `x` fixat la 10) astfel încât cifra 2 să fie afișată de exact trei ori.\nc. Vom transcrie algoritmul în C++, fără a folosi funcții predefinite pentru interschimbare.\nd. Vom rescrie algoritmul folosind o structură repetitivă cu test inițial în locul structurii \"pentru\".\n\n### Answer\n**a.**\n- x = 8, y = 5\n- x > y, deci x devine 5, y devine 8.\n- nr = 1\n- Bucla: i de la 8 la 5, descrescător\n    - i = 8: afișează 1; nr (1) < x (5), afișează 1; nr = 3\n    - i = 7: afișează 1; nr (3) < x (5), afișează 1; nr = 9\n    - i = 6: afișează 1; nr (9) >= x (5), afișează 2, afișează 1; nr = 27\n    - i = 5: afișează 1; nr (27) >= x (5), afișează 2, afișează 1; nr = 81\nRezultat: 1111121121\n\n**b.**\n- x = 10\n- Cifra 2 trebuie afișată de trei ori.  Asta înseamnă că `nr` trebuie să depășească sau să egaleze pe `x` de trei ori în interiorul buclei.\n-  y = 9:\n    - i = 9: 1, nr=1, 1, nr = 3\n    - i = 8: 1, nr=3, 1, nr = 9\n    - i = 7: 1, nr=9, 1, nr=27. 27>=10, 2, 1.\n    - i = 6: 1, 2, 1\n    - i=5: 1, 2, 1.  De 3 ori.\n- y = 8:\n   - i=8: 1, 1, nr=3\n   - i=7: 1, 1, nr=9\n   - i=6: 1, 1, nr=27. 27>=10. 2, 1\n   - i=5: 1, 2, 1\n   - i=4: 1, 2, 1.\n\nDouă numere posibile sunt 8 și 9.\n\n**c.**\n```cpp\n#include <iostream>\n\nint main() {\n    int x, y, nr, aux;\n    std::cin >> x >> y;\n\n    if (x > y) {\n        aux = x;\n        x = y;\n        y = aux;\n    }\n\n    nr = 1;\n    for (int i = y; i >= x; i--) {\n        std::cout << 1;\n        if (nr >= x) {\n            std::cout << 2;\n        }\n        std::cout << 1;\n        nr = nr * 3;\n    }\n\n    return 0;\n}\n```\n\n**d.**\n```\ncitește x,y\n (numere naturale nenule)\n┌dacă x>y atunci\n|  aux <- x\n|  x <- y\n|  y <- aux\n└■\nnr1\ni <- y\ncat timp i >= x executa\n| scrie 1\n| ┌dacă nr≥x atunci\n| │ scrie 2\n| └■\n| scrie 1\n| nrnr*3\n| i <- i - 1\n└\n```\n\n---\n\n## Subiectul II - Exercițiul 2\n\n### Problem Analysis\nSe generează prin backtracking grupuri de păsări cântătoare, cu restricția ca mierla și privighetoarea să nu fie împreună. Se cere să se scrie două soluții după o soluție dată.\n\n### Solution Approach\nVom continua generarea soluțiilor conform regulilor backtracking, ținând cont de restricție și de ordinea alfabetică implicită a păsărilor.\n\n### Answer\nSoluțiile imediat următoare după (ciocârlie, privighetoare, scatiu) sunt:\n(mierlă, scatiu)\n(scatiu)\n\n---\n\n## Subiectul II - Exercițiul 3\n\n### Problem Analysis\nSe dau două variabile de tip `fractie`, `f` și `fs`. Se cere să se scrie o secvență de instrucțiuni care să calculeze diferența dintre fracția 2020/2021 și fracția `f` și să stocheze rezultatul în `fs`.\n\n### Solution Approach\nVom calcula diferența dintre fracții conform regulilor matematice: a/b - c/d = (ad - bc) / bd.\n\n### Answer\n```cpp\nfs.a = 2020 * f.b - 2021 * f.a;\nfs.b = 2021 * f.b;\n```\n\n---\n\n## Subiectul III - Exercițiul 1\n\n### Problem Analysis\nSe cere definirea unui subprogram `divPrim` care primește un număr natural `n` și returnează prin parametrul `s` suma divizorilor primi ai lui `n` care apar la putere impară în descompunerea în factori primi.\n\n### Solution Approach\nVom parcurge toți posibilii divizori primi ai lui `n`. Pentru fiecare divizor prim, vom determina puterea la care apare în descompunerea lui `n`. Dacă puterea este impară, vom adăuga divizorul la sumă.\n\n### Code Solution\n```cpp\n#include <iostream>\n\nvoid divPrim(int n, int &s) {\n    s = 0;\n    int d = 2;\n    while (n > 1) {\n        int p = 0;\n        while (n % d == 0) {\n            p++;\n            n /= d;\n        }\n        if (p % 2 != 0) {\n            s += d;\n        }\n        if(d==2)\n          d++;\n        else\n          d+=2;\n        if(d*d > n && n > 1){\n            s += n;\n            n = 1;\n        }\n    }\n}\n```\n\n---\n\n## Subiectul III - Exercițiul 2\n\n### Problem Analysis\nSe citesc `n` și `k`, apoi `n` cuvinte. Se cere afișarea primelor `k` cuvinte care se termină cu o vocală, sau mesajul \"nu exista\" dacă nu există suficiente cuvinte.\n\n### Solution Approach\nVom citi cuvintele pe rând. Pentru fiecare cuvânt, vom verifica dacă ultima literă este vocală. Dacă este, vom afișa cuvântul și vom incrementa un contor. Vom continua până când contorul atinge valoarea `k` sau până când am citit toate cuvintele.\n\n### Code Solution\n```cpp\n#include <iostream>\n#include <string>\n\nint main() {\n    int n, k;\n    std::cin >> n >> k;\n    std::string cuvant;\n    int contor = 0;\n    for (int i = 0; i < n; ++i) {\n        std::cin >> cuvant;\n        char ultimaLitera = cuvant[cuvant.length() - 1];\n        if (ultimaLitera == 'a' || ultimaLitera == 'e' || ultimaLitera == 'i' ||\n            ultimaLitera == 'o' || ultimaLitera == 'u') {\n            std::cout << cuvant << std::endl;\n            contor++;\n            if (contor == k) {\n                break;\n            }\n        }\n    }\n    if (contor < k) {\n        std::cout << \"nu exista\" << std::endl;\n    }\n    return 0;\n}\n```\n\n---\n\n## Subiectul III - Exercițiul 3\n\n### Problem Analysis\nSe citește un număr `x` și un șir de numere dintr-un fișier. Se cere afișarea ultimilor doi termeni consecutivi din șir care îl au pe `x` ca sufix, sau mesajul \"nu exista\".\n\n### Solution Approach\nVom citi numerele din fișier pe rând. Vom păstra ultimele două numere citite care au pe `x` ca sufix. Vom actualiza aceste două numere pe măsură ce citim noi numere care îndeplinesc condiția. La final, vom afișa cele două numere sau mesajul \"nu exista\".  Pentru a verifica daca un numar este sufix, vom calcula restul impartirii la 10, 100, 1000, etc. in functie de numarul de cifre al lui x.\n\n### Answer\n**a.** Algoritmul este eficient ca memorie deoarece nu stochează tot șirul, ci doar ultimele două numere care respectă condiția. Este eficient ca timp deoarece parcurge șirul o singură dată.\n\n- Citim numarul x.\n- Initializam doua variabile, `ultimul` si `penultimul` cu -1 (valori care indica faptul ca nu am gasit inca numere care sa respecte conditia)\n- Deschidem fisierul pentru citire.\n- Citim numerele din fisier pe rand.\n- Pentru fiecare numar citit `curent`:\n    - Verificam daca `x` este sufixul lui `curent`.\n    - Daca este sufix:\n        - `penultimul` devine `ultimul`\n        - `ultimul` devine `curent`\n- Dupa ce terminam de citit fisierul:\n    - Daca `penultimul` si `ultimul` sunt diferite de -1, afisam `penultimul` si `ultimul`\n    - Altfel, afisam \"nu exista\"\n\n**b.**\n```cpp\n#include <iostream>\n#include <fstream>\n\nbool esteSufix(int numar, int sufix) {\n    int putere10 = 1;\n    while (sufix >= putere10) {\n        putere10 *= 10;\n    }\n    return numar % putere10 == sufix;\n}\n\nint main() {\n    std::ifstream fisier(\"bac.txt\");\n    int x, ultimul = -1, penultimul = -1, curent;\n    fisier >> x;\n    while (fisier >> curent) {\n        if (esteSufix(curent, x)) {\n            penultimul = ultimul;\n            ultimul = curent;\n        }\n    }\n    fisier.close();\n\n    if (penultimul != -1 && ultimul != -1) {\n        std::cout << penultimul << \" \" << ultimul << std::endl;\n    } else {\n        std::cout << \"nu exista\" << std::endl;\n    }\n\n    return 0;\n}\n```\n"
}