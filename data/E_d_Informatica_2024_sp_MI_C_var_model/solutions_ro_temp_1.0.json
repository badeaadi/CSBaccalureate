{
    "solutions_gpt4o_1.0": "## Subject I - Exercise 1\n### Problem Analysis\nVariabila `x` poate să ia valori în intervalul [0,109). Se cere valoarea maximă pe care o poate avea expresia `x % 2024`.\n\n### Solution Approach\nModulul unui număr `x` cu 2024 returnează restul împărțirii lui `x` la 2024. \nRezultatul maxim al unei astfel de operații este `2024 - 1 = 2023`.\n\n### Answer\nc. 2023\n\n---\n\n## Subject I - Exercise 2\n### Problem Analysis\nSe analizează rezultatele apelurilor subprogramelor f1, f2 și f3 pentru n=24.\n\n### Solution Approach\n- `f1(24)` calculează suma primelor 24 de numere naturale: `24 * (24 + 1) / 2 = 300`.\n- `f2(24)` calculează suma numerelor de la 0 la 24: `sumă = 0 + 1 + ... + 24`. Valoarea este tot `300`.\n- `f3(24)` aplică o serie de operații în funcție de paritatea lui `n`. Verificând rezultatul pas cu pas vedem că și pentru `f3(24)` obținem 300.\n\n### Answer\nd. f1, f2 și f3\n\n---\n\n## Subject I - Exercise 3\n### Problem Analysis\nSe folosește metoda backtracking pentru generarea preparatelor la cuptor și identificarea celui de-al șaptelea preparat.\n\n### Solution Approach\nCondițiile impuse definesc ordinea ingredientelor. Se analizează ordinea generării preparatelor și se identifică a șaptea combinație validă.\n\n### Answer\na. (broccoli, smântână, ou, cașcaval)\n\n---\n\n## Subject I - Exercise 4\n### Problem Analysis\nSe analizează arborii, reprezentarea acestora prin vectorul de „tați” și determinarea numărului de noduri frunză.\n\n### Solution Approach\nNodurile „frunză” sunt cele care nu au altele care le au ca părinte. Se identifică astfel fiecare nod care lipsește ca „tată” în lista dată.\n\n### Answer\na. 6\n\n---\n\n## Subject I - Exercise 5\n### Problem Analysis\nPentru a transforma graful într-un graf eulerian trebuie să verificăm condiţia că toate nodurile au grad par.\n\n### Solution Approach\nDebutând de la configurația dată, adăugăm un număr minim de muchii pentru a atinge criteriul grafului eulerian (grad par).\n\n### Answer\nb. 2\n\n---\n\n## Subject II - Exercise 1\n### Problem Analysis\nAlgoritmul primește un număr natural `n`, apoi procesează un set de numere printr-o serie de verificări și operații iterative.\n\n### Solution Approach\n- **a.** Se calculează rezultatul iterativ pentru cele două seturi de numere citite.\n- **b.** Se determină setul potrivit de numere astfel încât suma finală să fie egală cu `n`.\n- **c.** Se scrie programul în C++ corespunzător algoritmului dat.\n- **d.** Se înlocuiește structură „cât timp” cu „pentru”.\n\n### Answer\n\n**a.** Se afișează `4066`.\n\n**b.** Exemplu de set: 721, 240.\n\n**c. Code Solution**\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, m = 0, i, x;\n    cin >> n;\n    i = n;\n    while (i >= 1) {\n        cin >> x;\n        while (x % 10 <= x / 10 % 10) {\n            x /= 10;\n        }\n        m += x;\n        i--;\n    }\n    if (m != n)\n        cout << m;\n    else\n        cout << \"egal\";\n    return 0;\n}\n```\n\n**d. Pseudocod**\n```\nfunction main()\n    read n\n    m = 0\n    for i from n to 1 step -1 do\n        read x\n        while x % 10 <= [x / 10] do\n            x = [x / 10]\n        end while\n        m = m + x\n    end for\n    if m ≠ n then\n        write m\n    else\n        write \"egal\"\n    end if\nend function\n```\n\n---\n\n## Subject II - Exercise 2\n### Problem Analysis\nSe definește o structură pentru reprezentarea datelor unui telefon, incluzând producătorul, frecvența procesorului și dimensiunea.\n\n### Solution Approach\nCreăm o structură care să conțină câmpurile necesare și declarăm variabila `t`.\n\n### Answer\n```cpp\nstruct Telefon {\n    char producator;\n    int frecventa;\n    double dimensiune[3];\n};\n\nTelefon t;\n```\n\n---\n\n## Subject II - Exercise 3\n### Problem Analysis\nSe afișează indicii coloanelor tabelului bidimensional, unde atât primul cât și ultimul element au valoarea 2024.\n\n### Solution Approach\nSe iterază prin coloane, se verifică condiția de valori egale pentru primul și ultimul element și se afișează indicele coloanei.\n\n### Answer\n```cpp\nfor (int j = 0; j < 24; j++) {\n    if (a[0][j] == 2024 && a[3][j] == 2024) {\n        cout << j << \" \";\n    }\n}\n```\n\n---\n\n## Subject III - Exercise 1\n### Problem Analysis\nSubprogramul are doi parametri, `a` și `b`, și returnează produsul divizorilor comuni celor două numere.\n\n### Solution Approach\nSe determină divizorii comuni ai celor doi parametri și se calculează produsul acestora.\n\n### Answer\n```cpp\n#include <iostream>\nusing namespace std;\n\nint produs(int a, int b) {\n    int prod = 1;\n    for (int i = 1; i <= min(a, b); i++) {\n        if (a % i == 0 && b % i == 0) {\n            prod *= i;\n        }\n    }\n    return prod;\n}\n```\n\n---\n\n## Subject III - Exercise 2\n### Problem Analysis\nProgramul citește un număr `n` și un text, și afișează cuvintele separate pe linii, în funcție de numărul de litere.\n\n### Solution Approach\nSeparăm textul în cuvinte, verificăm lungimea fiecărui cuvânt și le plasăm pe linia corespunzătoare.\n\n### Answer\n```cpp\n#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint main() {\n    int n;\n    string text, word, line1 = \"\", line2 = \"\";\n    \n    cin >> n;\n    cin.ignore(); // Ignorăm newline după n\n    getline(cin, text);\n    \n    stringstream ss(text);\n    while (ss >> word) {\n        if (word.size() < n)\n            line1 += word + \" \";\n        else if (word.size() > n)\n            line2 += word + \" \";\n    }\n    \n    if (!line1.empty())\n        cout << line1 << endl;\n    else\n        cout << \"nu exista\" << endl;\n    \n    if (!line2.empty())\n        cout << line2 << endl;\n    else\n        cout << \"nu exista\" << endl;\n    \n    return 0;\n}\n```\n\n---\n\n## Subject III - Exercise 3\n### Problem Analysis\nFișierul conține premii și prețuri pentru cărți, iar programul trebuie să afișeze prețurile în ordine descrescătoare.\n\n### Solution Approach\nSortăm și countăm prețurile disponibile pentru fiecare premiu, selectând cel mai mare preț pentru care există suficiente cărți.\n\n### Answer\n**a.** Algoritmul sortează prețurile într-un vector, apoi verifică câte cărți sunt disponibile pentru fiecare categorie de premii, alegând cele mai mari prețuri posibile.\n\n**b. Code Solution**\n```cpp\n#include <iostream>\n#include <vector>\n#include <fstream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.txt\");\n    vector<int> preturi;\n    int n1, n2, n3, pret;\n\n    fin >> n1 >> n2 >> n3;\n    while (fin >> pret) {\n        preturi.push_back(pret);\n    }\n\n    fin.close();\n    sort(preturi.begin(), preturi.end(), greater<int>());\n    \n    int pretI = -1, pretII = -1, pretIII = -1;\n    int countI = 0, countII = 0, countIII = 0;\n\n    for (auto &p : preturi) {\n        if (countI < n1) {\n            pretI = p;\n            countI++;\n        } else if (countII < n2 && p < pretI) {\n            pretII = p;\n            countII++;\n        } else if (countIII < n3 && p < pretII) {\n            pretIII = p;\n            countIII++;\n        }\n        if (countI == n1 && countII == n2 && countIII == n3)\n            break;\n    }\n\n    if (pretI != -1 && pretII != -1 && pretIII != -1)\n        cout << pretI << \" \" << pretII << \" \" << pretIII << endl;\n    else\n        cout << \"nu exista\" << endl;\n\n    return 0;\n}\n```",
    "solutions_gemini20pro_1.0": "## Subiectul I - Exercițiul 1\n\n### Problem Analysis\nTrebuie să determinăm valoarea maximă a expresiei `x % 2024`, unde `x` este un număr natural din intervalul [0, 10^9). Operatorul `%` calculează restul împărțirii lui `x` la 2024.\n\n### Solution Approach\nRestul împărțirii unui număr la un alt număr este întotdeauna mai mic decât împărțitorul.  Valoarea maximă a restului se obține când numărul de împărțit este cu o unitate mai mic decât un multiplu al împărțitorului. În cazul nostru, împărțitorul este 2024. Deci, restul maxim posibil este 2024 - 1.\n\n### Answer\nc. 2023\n\n### Code Solution (if needed)\n```cpp\n// Nu este necesar cod pentru această problemă.\n```\n\n---\n\n## Subiectul I - Exercițiul 2\n\n### Problem Analysis\nTrebuie să evaluăm cele trei funcții `f1`, `f2` și `f3` pentru `n = 24` și să determinăm care dintre ele returnează aceeași valoare.\n\n### Solution Approach\n1. **Calculăm f1(24):**\n   `f1(n) = n * (n + 1) / 2`\n   `f1(24) = 24 * (24 + 1) / 2 = 24 * 25 / 2 = 12 * 25 = 300`\n\n2. **Calculăm f2(24):**\n   `f2(n)` este o funcție recursivă care calculează suma numerelor de la 1 la `n`.\n   `f2(24) = 24 + 23 + ... + 1 + 0 = 24 * (24 + 1) / 2 = 300` (putem folosi formula sumei lui Gauss).\n\n3. **Calculăm f3(24):**\n   Funcția `f3` este recursivă și mai complexă.\n   - f3(24): n%2==0, deci return 24*24/4 + 2*f3(12) = 144 + 2*f3(12)\n   - f3(12): n%2==0, deci return 12*12/4 + 2*f3(6) = 36 + 2*f3(6)\n   - f3(6) : n%2==0, deci return 6*6/4 + 2*f3(3) = 9 + 2*f3(3)\n   - f3(3) : n%2==1, deci return 3 + f3(2)\n   - f3(2) : n%2==0, deci return 2*2/4 + 2*f3(1) = 1+ 2*f3(1)\n   - f3(1) : n%2==1, deci return 1 + f3(0)\n   - f3(0) : return 0\n   Calculam invers:\n   - f3(1) = 1 + 0 = 1\n   - f3(2) = 1 + 2*1 = 3\n   - f3(3) = 3 + 3 = 6\n   - f3(6) = 9 + 2*6 = 21\n   - f3(12) = 36 + 2*21 = 78\n   - f3(24) = 144 + 2*78 = 144 + 156 = 300\n\n### Answer\nd. f1, f2 și f3\n\n### Code Solution (if needed)\n```cpp\n// Nu este necesar cod pentru această problemă.\n```\n\n---\n\n## Subiectul I - Exercițiul 3\n\n### Problem Analysis\nSe generează combinații de 4 ingrediente din mulțimea dată, respectând anumite reguli. Trebuie identificat al șaptelea preparat generat.\n\n### Solution Approach\nVom genera preparatele respectând regulile, ținând cont de ordinea din enunț:\n1.  broccoli, cașcaval, ou, pătrunjel\n2.  broccoli, ou, cașcaval, pătrunjel\n3.  broccoli, ou, smântână, cașcaval\n4.  broccoli, ou, smântână, pătrunjel\n5.  broccoli, smântână, cașcaval, ou\n6.  broccoli, smântână, cașcaval, pătrunjel\n7.  broccoli, smântână, ou, cașcaval\n\n### Answer\na. (broccoli, smântână, ou, cașcaval)\n\n---\n\n## Subiectul I - Exercițiul 4\n\n### Problem Analysis\nDat fiind un vector de tați care reprezintă un arbore, trebuie să determinăm numărul de noduri frunză.\n\n### Solution Approach\nUn nod frunză este un nod care nu are copii. În vectorul de tați, un nod *i* este frunză dacă valoarea *i* nu apare în vectorul de tați.\n\nVectorul de tați: (7, 4, 6, 7, 4, 7, 0, 9, 6, 5)\nNodurile: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\nVerificăm care noduri nu apar ca tați:\n- 1 are tatăl 7\n- 2 are tatăl 4\n- 3 are tatăl 6\n- 4 are tatăl 7\n- 5 are tatăl 4\n- 6 are tatăl 7\n- 7 are tatăl 0 (rădăcina)\n- 8 are tatăl 9\n- 9 are tatăl 6\n- 10 are tatăl 5\n\nNumerele care nu apar ca valori in vectorul de tati, in afara de 0 (radacina) sunt: 1, 2, 3, 8, 10 -> 5 noduri\n\nVerificăm:\n1 nu apare ca tată -> frunză\n2 nu apare ca tată -> frunză\n3 nu apare ca tată -> frunză\n8 nu apare ca tată -> frunză\n10 nu apare ca tată -> frunză\n\n### Answer\nb. 5\n\n---\n\n## Subiectul I - Exercițiul 5\n\n### Problem Analysis\nÎntr-un graf neorientat reprezentând piețe și benzi de transport, trebuie să determinăm numărul minim de benzi de adăugat pentru ca graful să devină eulerian.\n\n### Solution Approach\nUn graf neorientat este eulerian dacă și numai dacă are cel mult două noduri cu grad impar, sau toate nodurile au grad par.\nGraful inițial are 5 noduri. Unul dintre noduri este conectat cu celelalte 4, deci are gradul 4 (par). Celelalte 4 noduri sunt conectate doar la nodul central, deci au gradul 1 (impar).\nPentru ca graful să devină eulerian, trebuie ca toate nodurile să aibă grad par. Trebuie sa conectăm nodurile cu grad impar două câte două. Avem 4 noduri cu grad impar. Deci, avem nevoie de 4 / 2 = 2 muchii (benzi) noi.\n\n### Answer\nb. 2\n\n---\n\n## Subiectul al II-lea - Exercițiul 1\n\n### Problem Analysis\nTrebuie analizat un algoritm pseudocod și să se determine:\na. Rezultatul pentru un set dat de date de intrare.\nb. Un set de date de intrare care produce un anumit rezultat.\nc. Implementarea algoritmului în C++.\nd. O variantă a algoritmului cu o structură repetitivă diferită.\n\n### Solution Approach\n\n**a.** Urmărim execuția algoritmului cu datele de intrare: 4, 721, 20020, 1321, 211\n- n = 4\n- m = 0\n- i = 4\n  - i = 4, x = 721\n     -  x%10 (1) <= [x/10]%10 (2) -> adevărat\n        -  x = [x/10] = 72\n     -  x%10 (2) <= [x/10]%10 (7) -> adevărat\n\t    -  x = [x/10] = 7\n     -  x%10 (7) <= [x/10]%10 (0) -> fals\n     -  m = m + x = 0 + 7 = 7\n     -  i = i - 1 = 3\n\n  - i = 3, x = 20020\n     -  x%10(0) <= [x/10]%10(2) -> adevarat\n         x = 2002\n     - x%10(2) <= [x/10]%10(0) -> fals\n     - m = m + x = 7 + 2002 = 2009\n     - i = 2\n\n  - i = 2, x = 1321\n      -  x%10 (1) <= [x/10]%10(2) -> adevarat\n          x = 132\n      - x%10 (2) <= [x/10]%10(3) -> adevarat\n          x = 13\n      - x%10(3) <= [x/10]%10(1) -> fals\n      -  m = 2009 + 13 = 2022\n      - i = 1\n\n   - i= 1, x = 211\n      - x%10(1) <= [x/10]%10 (1) -> adevarat\n         x = 21\n      - x%10 (1) <= [x/10]%10(2) -> adevarat\n        x=2\n      - x%10(2) <= [x/10]%10 (0) -> fals\n      - m = 2022 + 2 = 2024\n      - i = 0\n\n- m (2024) != n(4) -> adevarat. Se afiseaza m.\n\n**b.**  Trebuie să găsim un set de numere astfel încât, după executarea algoritmului, `m` să fie egal cu `n` (care este 2).\nObservăm că algoritmul extrage din fiecare număr `x` citit, cifrele din dreapta spre stânga, până când cifra curentă nu mai este mai mică sau egală decât cifra precedentă. Ulterior adaugă rezultatul la `m`.\nPentru ca m=2, putem alege următoarele numere după citirea lui n=2:\n10, 10.  In acest caz:\n- i=2, x=10, 0<=1, x=1, 1<=0, fals. m=0+1 = 1. i = 1\n- i=1, x=10, 0<=1, x=1, 1<=0, fals, m=1+1=2. i=0.\nm==n(2), se afiseaza \"egal\"\n\n**c.** Implementarea în C++:\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m, i, x;\n    cin >> n;\n    m = 0;\n    i = n;\n    while (i >= 1) {\n        cin >> x;\n        while (x % 10 <= (x / 10) % 10) {\n            x = x / 10;\n        }\n        m = m + x;\n        i = i - 1;\n    }\n    if (m != n) {\n        cout << m << endl;\n    } else {\n        cout << \"egal\" << endl;\n    }\n    return 0;\n}\n```\n\n**d.** Înlocuirea primei structuri `cât timp` cu `pentru`:\n\n```pseudocod\ncitește n (număr natural nenul)\nm0\npentru in, 1, -1 execută\n  citește x (număr natural)\n  ┌cât timp x%10 ≤ [x/10]%10 execută\n  │ x[x/10]\n  └■\n  mm+x\n└■\n┌dacă m≠n atunci scrie m\n│altfel scrie „egal”\n└■\n\n```\n\n### Answer\na. 2024\nb. 10, 10\nc. Vezi codul C++ de mai sus.\nd. Vezi pseudocodul de mai sus.\n\n---\n\n## Subiectul al II-lea - Exercițiul 2\n\n### Problem Analysis\nTrebuie să definim o structură în C++ pentru a stoca informații despre un telefon și să declarăm o variabilă de acest tip.\n\n### Solution Approach\nDefinim structura `telefon` cu câmpurile `producator` (char), `frecventa` (int) și `dimensiune` (tablou de 3 numere reale).\n\n### Answer\n\n```cpp\nstruct telefon {\n    char producator;\n    int frecventa;\n    float dimensiune[3];\n};\n\ntelefon t;\n```\n\n---\n\n## Subiectul al II-lea - Exercițiul 3\n\n### Problem Analysis\nSe dă un tablou bidimensional și trebuie să se afișeze indicii coloanelor pentru care primul și ultimul element sunt egale cu 2024.\n\n### Solution Approach\nParcurgem coloanele tabloului și verificăm dacă primul (`a[0][j]`) și ultimul element (`a[3][j]`) sunt egale cu 2024. Dacă da, afișăm indicele coloanei (`j`).\n\n### Answer\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int a[4][24];\n\n    // Presupunem că tabloul 'a' este deja inițializat.\n    // Înlocuiți secvența următoare cu inițializarea tabloului 'a'.\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 24; j++) {\n            a[i][j] = 0; // Exemplu de inițializare - trebuie modificat cu datele reale\n        }\n    }\n\n        for (int i = 0; i < 4; i++){\n            for(int j = 0; j< 24; j++){\n                if(i==0) a[i][j] = 2024;\n                if(i==3 && j%2==0) a[i][j]=2024;\n            }\n    }\n    for (int j = 0; j < 24; j++) {\n        if (a[0][j] == 2024 && a[3][j] == 2024) {\n            cout << j << \" \";\n        }\n    }\n    cout << endl;\n\n    return 0;\n}\n```\n\n---\n\n## Subiectul al III-lea - Exercițiul 1\n\n### Problem Analysis\nTrebuie să scriem un subprogram care calculează produsul divizorilor comuni a două numere.\n\n### Solution Approach\n1.  Găsim cel mai mic dintre cele două numere (`a` și `b`).\n2.  Parcurgem numerele de la 1 la minimul dintre `a` și `b`.\n3.  Pentru fiecare număr, verificăm dacă este divizor comun al lui `a` și `b`.\n4.  Dacă este divizor comun, îl înmulțim la un produs inițializat cu 1.\n\n### Answer\n\n```cpp\n#include <iostream>\n#include <algorithm> // Pentru std::min\n\nusing namespace std;\n\nint produs(int a, int b) {\n    int p = 1;\n    int m = min(a, b);\n    for (int i = 1; i <= m; i++) {\n        if (a % i == 0 && b % i == 0) {\n            p = p * i;\n        }\n    }\n    return p;\n}\n\nint main(){\n    cout << produs(20, 12) << endl;\n    cout << produs(15, 25) << endl;\n}\n```\n\n---\n\n## Subiectul al III-lea - Exercițiul 2\n\n### Problem Analysis\nTrebuie să citim un text și să-l împărțim în două categorii de cuvinte: cele cu lungimea mai mică decât `n` și cele cu lungimea mai mare decât `n`.\n\n### Solution Approach\n1. Citim `n`.\n2. Citim textul.\n3. Parcurgem textul cuvânt cu cuvânt.\n4. Pentru fiecare cuvânt, verificăm lungimea.\n5. Dacă lungimea este mai mică decât `n`, afișăm cuvântul pe prima linie.\n6. Dacă lungimea este mai mare decât `n`, afișăm cuvântul pe a doua linie.\n7. Dacă una dintre categorii este vidă, afișăm \"nu exista\".\n\n### Answer\n\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    cin.ignore(); // Consumăm newline-ul rămas după citirea lui n\n\n    string text;\n    getline(cin, text);\n\n    vector<string> maiMici;\n    vector<string> maiMari;\n    string cuvant;\n    stringstream ss(text);\n\n    while (ss >> cuvant) {\n        if (cuvant.length() < n) {\n            maiMici.push_back(cuvant);\n        } else if (cuvant.length() > n) {\n            maiMari.push_back(cuvant);\n        }\n    }\n\n    if (maiMici.empty()) {\n        cout << \"nu exista\" << endl;\n    } else {\n        for (const string& cuv : maiMici) {\n            cout << cuv << \" \";\n        }\n        cout << endl;\n    }\n\n    if (maiMari.empty()) {\n        cout << \"nu exista\" << endl;\n    } else {\n        for (const string& cuv : maiMari) {\n            cout << cuv << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```\n\n---\n\n## Subiectul al III-lea - Exercițiul 3\n\n### Problem Analysis\nTrebuie să găsim trei prețuri distincte descrescătoare pentru premii, astfel încât să existe suficiente cărți disponibile la fiecare preț.\n\n### Solution Approach\na. Algoritmul este eficient deoarece parcurge șirul de prețuri o singură dată pentru a construi frecvențele (O(m), unde m este numărul de cărți) și apoi parcurge vectorul de frecvențe, care are dimensiune maximă 1001 (O(1001)), deci complexitate constanta. Complexitatea totală este O(m), unde m este numărul de cărți din fișier, adica liniara.\n\n1. Citim `n1`, `n2`, `n3`.\n2. Citim prețurile din fișier și construim un vector de frecvențe `freq`, unde `freq[i]` reprezintă numărul de cărți cu prețul `i`.\n3. Parcurgem vectorul de frecvențe de la 1000 la 10 (descrescător).\n4. Căutăm primul preț `p1` pentru care `freq[p1] >= n1`.\n5. Căutăm al doilea preț `p2` (mai mic decât `p1`) pentru care `freq[p2] >= n2`.\n6. Căutăm al treilea preț `p3` (mai mic decât `p2`) pentru care `freq[p3] >= n3`.\n7. Dacă găsim toate cele trei prețuri, le afișăm. Altfel, afișăm \"nu exista\".\n\nb. Implementarea în C++:\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.txt\");\n    int n1, n2, n3, pret;\n    fin >> n1 >> n2 >> n3;\n\n    vector<int> freq(1001, 0); // Frecvențele prețurilor\n    while (fin >> pret) {\n        freq[pret]++;\n    }\n\n    int p1 = -1, p2 = -1, p3 = -1;\n    for (int i = 1000; i >= 10; i--) {\n        if (p1 == -1 && freq[i] >= n1) {\n            p1 = i;\n        } else if (p1 != -1 && p2 == -1 && freq[i] >= n2) {\n            p2 = i;\n        } else if (p1 != -1 && p2 != -1 && p3 == -1 && freq[i] >= n3) {\n            p3 = i;\n        }\n    }\n   fin.close();\n\n    if (p1 != -1 && p2 != -1 && p3 != -1) {\n        cout << p1 << \" \" << p2 << \" \" << p3 << endl;\n    } else {\n        cout << \"nu exista\" << endl;\n    }\n\n    return 0;\n}\n```\n",
    "solutions_anthropicclaude37sonnet_1.0": "# Rezolvări Examen Informatică\n\n## Subiectul I - Exercițiul 1\n### Analiză problemă\nSe cere valoarea maximă a expresiei x%2024, unde x este un număr natural din intervalul [0, 10^9).\n\n### Abordare soluție\nOperatorul % (modulo) returnează restul împărțirii lui x la 2024. Valoarea maximă a acestei expresii va fi 2024-1, adică 2023.\n\n### Răspuns\nValoarea maximă a expresiei x%2024 este 2023, deci răspunsul corect este c. 2023.\n\n---\n\n## Subiectul I - Exercițiul 2\n### Analiză problemă\nTrebuie să determinăm pentru care dintre funcțiile f1, f2 și f3 se obține aceeași valoare când sunt apelate cu n=24.\n\n### Abordare soluție\nSă calculăm valoarea returnată de fiecare funcție pentru n=24:\n\n- f1(24) = 24*(24+1)/2 = 24*25/2 = 600/2 = 300\n- f2(24) = 24 + f2(23) = 24 + 23 + f2(22) = ... = 24 + 23 + ... + 1 + 0 = suma primelor 24 de numere naturale = 24*(24+1)/2 = 300\n- f3(24):\n  - n=24: n%2==0, deci returnează 24*24/4 + 2*f3(12) = 144 + 2*f3(12)\n  - n=12: n%2==0, deci returnează 12*12/4 + 2*f3(6) = 36 + 2*f3(6)\n  - n=6: n%2==0, deci returnează 6*6/4 + 2*f3(3) = 9 + 2*f3(3)\n  - n=3: n%2==1, deci returnează 3 + f3(2) = 3 + 2*2/4 + 2*f3(1) = 3 + 1 + 2*f3(1)\n  - n=1: n%2==1, deci returnează 1 + f3(0) = 1 + 0 = 1\n  \n  Deci f3(1) = 1, f3(2) = 1 + 2*1 = 3, f3(3) = 3 + 3 = 6, f3(6) = 9 + 2*6 = 21, f3(12) = 36 + 2*21 = 78, f3(24) = 144 + 2*78 = 144 + 156 = 300\n\n### Răspuns\nToate cele trei funcții returnează valoarea 300 pentru n=24, deci răspunsul corect este d. f1, f2 și f3.\n\n---\n\n## Subiectul I - Exercițiul 3\n### Analiză problemă\nSe generează toate modalitățile de a realiza preparate la cuptor, respectând anumite condiții, și se cere al șaptelea preparat generat.\n\n### Abordare soluție\nCondițiile sunt:\n1. Nu sunt folosite conopidă și broccoli în același preparat; dacă folosim una dintre ele, ea este prima în tavă\n2. Dacă folosim pătrunjel, acesta e ultimul în tavă\n3. Dacă folosim smântână și cașcaval în același preparat, smântâna e înaintea cașcavalului\n\nPrimele 6 preparate generate (sunt date primele 5, și trebuie să deducem al 6-lea):\n1. (broccoli, cașcaval, ou, pătrunjel)\n2. (broccoli, ou, cașcaval, pătrunjel)\n3. (broccoli, ou, smântână, cașcaval)\n4. (broccoli, ou, smântână, pătrunjel)\n5. (broccoli, smântână, cașcaval, ou)\n6. (broccoli, smântână, cașcaval, pătrunjel) - deducția noastră\n\nUrmărind regula de generare, al 7-lea preparat ar fi:\n(broccoli, smântână, ou, pătrunjel)\n\n### Răspuns\nAl șaptelea preparat generat este (broccoli, smântână, ou, pătrunjel), deci răspunsul corect este a.\n\n---\n\n## Subiectul I - Exercițiul 4\n### Analiză problemă\nAvem un arbore cu 10 noduri reprezentat prin vectorul de \"tați\" și trebuie să determinăm numărul de noduri frunză.\n\n### Abordare soluție\nVectorul de tați este (7,4,6,7,4,7,0,9,6,5). Fiecare poziție i reprezintă nodul i+1, iar valoarea reprezintă tatăl nodului.\n\nPentru a determina frunzele, trebuie să vedem care noduri nu sunt tați pentru niciun alt nod (nu apar în vectorul de tați).\n\nNodurile care apar ca tați: 4, 5, 6, 7, 9\nDeci, nodurile care nu sunt tați: 1, 2, 3, 8, 10\n\nVerificând dacă toate acestea sunt într-adevăr prezente în arbore (iar nu sunt rădăcini sau noduri izolate):\n1. Nodul 1 are tatăl 7\n2. Nodul 2 are tatăl 4\n3. Nodul 3 are tatăl 6\n4. Nodul 8 are tatăl 9\n5. Nodul 10 are tatăl 5\n\nToate aceste 5 noduri sunt frunze.\n\n### Răspuns\nNumărul de noduri frunză este 5, deci răspunsul corect este b. 5.\n\n---\n\n## Subiectul I - Exercițiul 5\n### Analiză problemă\nAvem un graf neorientat cu 5 noduri (piețe), unde un nod este conectat direct cu celelalte 4. Trebuie să determinăm numărul minim de muchii care trebuie adăugate pentru ca graful să devină eulerian.\n\n### Abordare soluție\nUn graf este eulerian dacă toate vârfurile au grad par.\n\nSituația actuală:\n- Un nod are grad 4 (conectat cu toate celelalte)\n- Celelalte 4 noduri au grad 1 (conectate doar cu nodul central)\n\nPentru a face graful eulerian, trebuie să adăugăm muchii astfel încât toate nodurile să aibă grad par.\nNodurile cu grad 1 trebuie să devină de grad par, deci trebuie să adăugăm cel puțin o muchie la fiecare.\n\nCea mai eficientă soluție este să adăugăm 2 muchii care să conecteze nodurile cu grad impar astfel:\n- Conectăm primul nod cu al doilea\n- Conectăm al treilea nod cu al patrulea\n\nAstfel toate nodurile vor avea grad par (nodul central are deja grad 4, iar celelalte vor avea grad 2).\n\n### Răspuns\nNumărul minim de muchii care trebuie adăugate este 2, deci răspunsul corect este b. 2.\n\n---\n\n## Subiectul II - Exercițiul 1\n### Analiză problemă\nSe cere analiza unui algoritm care procesează numere naturale, citind mai întâi un număr n și apoi n numere.\n\n### Abordare soluție\na) Algoritmul citește un număr n și apoi n numere. Pentru fiecare număr x, îl transformă succesiv împărțindu-l la 10 atât timp cât ultima sa cifră este mai mică sau egală cu penultima cifră. Apoi adaugă valoarea rezultată la m. La final, compară m cu n și afișează m dacă m≠n, altfel afișează \"egal\".\n\nPentru n=4, și numerele 721, 20020, 1321, 211:\n- Pentru x=721: 721%10=1 ≤ [721/10]%10=2 - fals, deci x rămâne 721, m=0+721=721\n- Pentru x=20020: 20020%10=0 ≤ [20020/10]%10=2 - adevărat, deci x=[20020/10]=2002\n  - 2002%10=2 ≤ [2002/10]%10=0 - fals, deci x rămâne 2002, m=721+2002=2723\n- Pentru x=1321: 1321%10=1 ≤ [1321/10]%10=2 - adevărat, deci x=[1321/10]=132\n  - 132%10=2 ≤ [132/10]%10=3 - adevărat, deci x=[132/10]=13\n  - 13%10=3 ≤ [13/10]%10=1 - fals, deci x rămâne 13, m=2723+13=2736\n- Pentru x=211: 211%10=1 ≤ [211/10]%10=1 - adevărat, deci x=[211/10]=21\n  - 21%10=1 ≤ [21/10]%10=2 - adevărat, deci x=[21/10]=2\n  - 2%10=2 ≤ [2/10]%10=0 - fals, deci x rămâne 2, m=2736+2=2738\n\nLa final, m=2738, n=4, m≠n, deci se afișează 2738.\n\nb) Pentru n=2, avem nevoie ca m=2. Asta înseamnă că suma valorilor finale ale celor două numere trebuie să fie 2.\nUn set de numere ar fi 51 și 51, deoarece:\n- Pentru 51: 51%10=1 ≤ [51/10]%10=5 - adevărat, deci x=[51/10]=5\n  - 5%10=5 ≤ [5/10]%10=0 - fals, deci x rămâne 5, m=0+5=5\n- Pentru 51: Similar ca mai sus, x devine 5, deci m=5+5=10\n\nDar m=10 ≠ n=2. Să încercăm cu 11 și 11:\n- Pentru 11: 11%10=1 ≤ [11/10]%10=1 - adevărat, deci x=[11/10]=1\n  - 1%10=1 ≤ [1/10]%10=0 - fals, deci x rămâne 1, m=0+1=1\n- Pentru 11: Similar ca mai sus, x devine 1, deci m=1+1=2\n\nDeci un set potrivit este 11 și 11.\n\nc) Cod C++ pentru algoritm:\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, m = 0, i, x;\n    cin >> n;\n    i = n;\n    while (i >= 1) {\n        cin >> x;\n        while (x % 10 <= (x / 10) % 10) {\n            x = x / 10;\n        }\n        m = m + x;\n        i = i - 1;\n    }\n    if (m != n)\n        cout << m;\n    else\n        cout << \"egal\";\n    return 0;\n}\n```\n\nd) Algoritm echivalent cu structura pentru...execută:\n\n```\ncitește n (număr natural nenul)\nm0\npentru i<-n,1,-1 execută\n    citește x (număr natural)\n    cât timp x%10 ≤ [x/10]%10 execută\n        x[x/10]\n    ■\n    mm+x\n■\ndacă m≠n atunci scrie m\n    altfel scrie „egal\"\n■\n```\n\n---\n\n## Subiectul II - Exercițiul 2\n### Analiză problemă\nSe cere definiția unei structuri de date pentru un telefon, având în vedere informațiile date.\n\n### Abordare soluție\nDin expresiile C/C++ date, deducem că structura `telefon` trebuie să aibă următoarele câmpuri:\n- `producator` - o literă mare a alfabetului englez\n- `frecventa` - un număr natural\n- `dimensiune` - un array de 3 elemente de tip float (lățime, grosime, lungime)\n\n### Răspuns\n```cpp\nstruct telefon {\n    char producator;\n    int frecventa;\n    float dimensiune[3]; // [0]-latime, [1]-grosime, [2]-lungime\n};\ntelefon t;\n```\n\n---\n\n## Subiectul II - Exercițiul 3\n### Analiză problemă\nAvem un tablou bidimensional `a` cu 4 linii și 24 coloane. Trebuie să afișăm indicii coloanelor care au atât primul cât și ultimul element egal cu 2024.\n\n### Abordare soluție\nPentru fiecare coloană j (de la 0 la 23), verificăm dacă a[0][j] == 2024 și a[3][j] == 2024. Dacă da, afișăm j.\n\n### Răspuns\n```cpp\nfor(i=0; i<24; i++)\n    if(a[0][i]==2024 && a[3][i]==2024)\n        cout << i << \" \";\n```\n\n---\n\n## Subiectul III - Exercițiul 1\n### Analiză problemă\nSe cere să implementăm un subprogram care returnează produsul divizorilor comuni a două numere naturale.\n\n### Abordare soluție\nVom găsi mai întâi cel mai mare divizor comun (cmmdc) al celor două numere, apoi vom calcula produsul tuturor divizorilor acestuia.\n\n### Cod soluție\n```cpp\nint produs(int a, int b) {\n    // Calculăm CMMDC-ul numerelor a și b\n    int cmmdc = a;\n    while (a % b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    cmmdc = b;\n    \n    // Calculăm produsul divizorilor lui CMMDC\n    int prod = 1;\n    for (int i = 1; i <= cmmdc; i++) {\n        if (cmmdc % i == 0) {\n            prod *= i;\n        }\n    }\n    \n    return prod;\n}\n```\n\n---\n\n## Subiectul III - Exercițiul 2\n### Analiză problemă\nSe citește un text și un număr n. Trebuie să afișăm pe o linie cuvintele cu mai puțin de n litere și pe alta cuvintele cu mai mult de n litere.\n\n### Abordare soluție\nVom parcurge textul cuvânt cu cuvânt și vom verifica lungimea fiecăruia. Apoi vom afișa cuvintele sortate conform cerințelor.\n\n### Cod soluție\n```cpp\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n    int n;\n    char text[101], *p;\n    bool existaMaiPutin = false, existaMaiMult = false;\n    \n    cin >> n;\n    cin.get(); // Consumăm newline-ul\n    cin.getline(text, 101);\n    \n    // Prima linie - cuvintele cu mai puțin de n litere\n    p = strtok(text, \" \");\n    while (p) {\n        if (strlen(p) < n) {\n            cout << p << \" \";\n            existaMaiPutin = true;\n        }\n        p = strtok(NULL, \" \");\n    }\n    \n    if (!existaMaiPutin)\n        cout << \"nu exista\";\n    \n    cout << endl;\n    \n    // A doua linie - cuvintele cu mai mult de n litere\n    strcpy(text, text); // Restaurăm textul original\n    p = strtok(text, \" \");\n    while (p) {\n        if (strlen(p) > n) {\n            cout << p << \" \";\n            existaMaiMult = true;\n        }\n        p = strtok(NULL, \" \");\n    }\n    \n    if (!existaMaiMult)\n        cout << \"nu exista\";\n    \n    return 0;\n}\n```\n\nObservație: Există o problemă în codul de mai sus, deoarece strtok modifică șirul original. Ar trebui să facem o copie a șirului original înainte de a-l parsa a doua oară:\n\n```cpp\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n    int n;\n    char text[101], copie[101], *p;\n    bool existaMaiPutin = false, existaMaiMult = false;\n    \n    cin >> n;\n    cin.get(); // Consumăm newline-ul\n    cin.getline(text, 101);\n    strcpy(copie, text);\n    \n    // Prima linie - cuvintele cu mai puțin de n litere\n    p = strtok(text, \" \");\n    while (p) {\n        if (strlen(p) < n) {\n            cout << p << \" \";\n            existaMaiPutin = true;\n        }\n        p = strtok(NULL, \" \");\n    }\n    \n    if (!existaMaiPutin)\n        cout << \"nu exista\";\n    \n    cout << endl;\n    \n    // A doua linie - cuvintele cu mai mult de n litere\n    p = strtok(copie, \" \");\n    while (p) {\n        if (strlen(p) > n) {\n            cout << p << \" \";\n            existaMaiMult = true;\n        }\n        p = strtok(NULL, \" \");\n    }\n    \n    if (!existaMaiMult)\n        cout << \"nu exista\";\n    \n    return 0;\n}\n```\n\n---\n\n## Subiectul III - Exercițiul 3\n### Analiză problemă\nAvem de rezolvat problema cărților pentru premianți, unde trebuie să determinăm prețurile pentru cele trei categorii de premii, astfel încât ele să fie în ordine strict descrescătoare și să existe suficiente cărți pentru fiecare premiu.\n\n### Abordare soluție\na) Descrierea algoritmului:\n1. Citim n1, n2, n3 (numărul de concurenți pentru fiecare premiu)\n2. Citim toate preturile cărților și le numărăm pe cele cu aceeași valoare (folosim un vector de frecvență)\n3. Parcurgem vectorul de frecvență în ordine descrescătoare a prețurilor și găsim cele mai mari trei prețuri care îndeplinesc condițiile:\n   - Avem cel puțin n1 cărți la prețul pentru premiul I\n   - Avem cel puțin n2 cărți la prețul pentru premiul II (mai mic decât premiul I)\n   - Avem cel puțin n3 cărți la prețul pentru premiul III (mai mic decât premiul II)\n4. Afișăm prețurile găsite sau \"nu exista\" dacă nu se pot îndeplini condițiile\n\nAcest algoritm este eficient deoarece:\n- Folosim un vector de frecvență pentru a evita sortarea tuturor prețurilor\n- Complexitatea temporală este O(N + MaxPret), unde N este numărul de cărți și MaxPret este prețul maxim (10^3)\n- Complexitatea spațială este O(MaxPret)\n\nb) Implementare:\n\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.txt\");\n    int n1, n2, n3;\n    int frecventa[1001] = {0}; // Vector de frecvență pentru prețuri (10-1000)\n    int pret;\n    \n    fin >> n1 >> n2 >> n3;\n    \n    // Citim preturile și actualizăm vectorul de frecvență\n    while (fin >> pret) {\n        frecventa[pret]++;\n    }\n    \n    // Găsim prețurile pentru cele trei premii\n    int p1 = -1, p2 = -1, p3 = -1; // Inițializăm cu valori negative\n    \n    // Căutăm prețul pentru premiul I\n    for (int i = 1000; i >= 10; i--) {\n        if (frecventa[i] >= n1) {\n            p1 = i;\n            frecventa[i] -= n1; // Actualizăm numărul disponibil de cărți\n            break;\n        }\n    }\n    \n    // Căutăm prețul pentru premiul II\n    if (p1 != -1) {\n        for (int i = p1 - 1; i >= 10; i--) {\n            if (frecventa[i] >= n2) {\n                p2 = i;\n                frecventa[i] -= n2;\n                break;\n            }\n        }\n    }\n    \n    // Căutăm prețul pentru premiul III\n    if (p2 != -1) {\n        for (int i = p2 - 1; i >= 10; i--) {\n            if (frecventa[i] >= n3) {\n                p3 = i;\n                break;\n            }\n        }\n    }\n    \n    // Afișăm rezultatele\n    if (p1 != -1 && p2 != -1 && p3 != -1) {\n        cout << p1 << \" \" << p2 << \" \" << p3;\n    } else {\n        cout << \"nu exista\";\n    }\n    \n    return 0;\n}\n```"
}