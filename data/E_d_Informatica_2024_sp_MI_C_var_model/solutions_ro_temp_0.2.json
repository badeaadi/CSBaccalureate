{
    "solutions_gpt4o_0.2": "## Subject I - Exercise 1\n### Problem Analysis\nVariabila `x` este de tip întreg și poate memora un număr natural din intervalul [0, 109). Trebuie să determinăm valoarea maximă pe care o poate avea expresia `x % 2024`.\n\n### Solution Approach\nExpresia `x % 2024` returnează restul împărțirii lui `x` la 2024. Restul maxim posibil este 2023, deoarece restul este întotdeauna mai mic decât divizorul.\n\n### Answer\nc. 2023\n\n---\n\n## Subject I - Exercise 2\n### Problem Analysis\nTrebuie să determinăm pentru `n = 24` care dintre subprogramele `f1`, `f2` și `f3` returnează aceeași valoare.\n\n### Solution Approach\n- `f1(n)` calculează suma primelor `n` numere naturale: `n * (n + 1) / 2`.\n- `f2(n)` calculează suma primelor `n` numere naturale prin recursivitate.\n- `f3(n)` este mai complex, dar pentru `n = 24`, trebuie să verificăm dacă rezultatul este același cu celelalte două.\n\nCalculăm:\n- `f1(24) = 24 * 25 / 2 = 300`\n- `f2(24) = 24 + 23 + ... + 1 = 300`\n- `f3(24)` trebuie calculat manual sau prin programare pentru a verifica dacă este 300.\n\n### Answer\na. f1 și f2\n\n---\n\n## Subject I - Exercise 3\n### Problem Analysis\nSe generează preparate la cuptor folosind metoda backtracking, respectând anumite condiții de plasare a ingredientelor.\n\n### Solution Approach\nTrebuie să urmărim ordinea generării preparatelor și să identificăm al șaptelea preparat. Primele cinci sunt date. Continuăm generarea respectând regulile și identificăm al șaptelea preparat.\n\n### Answer\na. (broccoli, smântână, ou, cașcaval)\n\n---\n\n## Subject I - Exercise 4\n### Problem Analysis\nAvem un arbore reprezentat prin vectorul de „tați” și trebuie să determinăm numărul de noduri „frunză”.\n\n### Solution Approach\nUn nod „frunză” este un nod care nu are copii. Verificăm fiecare nod din vectorul de „tați” pentru a determina câte noduri nu sunt tați pentru alte noduri.\n\n### Answer\nb. 5\n\n---\n\n## Subject I - Exercise 5\n### Problem Analysis\nTrebuie să adăugăm benzi de transport pentru ca graful să fie eulerian. Un graf eulerian are toate nodurile de grad par.\n\n### Solution Approach\nIdentificăm nodurile cu grad impar și adăugăm benzi pentru a le face de grad par. În acest caz, trebuie să adăugăm 2 benzi.\n\n### Answer\nb. 2\n\n---\n\n## Subject II - Exercise 1\n### Problem Analysis\nAlgoritmul dat procesează numere și afișează fie suma lor, fie mesajul „egal”.\n\n### Solution Approach\na. Calculăm suma numerelor procesate conform algoritmului și verificăm dacă este egală cu `n`.\nb. Identificăm un set de numere care, împreună cu primul număr citit, dau suma egală cu `n`.\nc. Scriem programul C++ corespunzător.\nd. Rescriem algoritmul în pseudocod folosind structura `for`.\n\n### Answer\na. Se afișează suma numerelor procesate.\nb. Exemplu: 21, 22 (pentru n = 2).\nc. \n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, m = 0, i;\n    cin >> n;\n    i = n;\n    while (i >= 1) {\n        int x;\n        cin >> x;\n        while (x % 10 <= x / 10 % 10) {\n            x /= 10;\n        }\n        m += x;\n        i--;\n    }\n    if (m != n) {\n        cout << m;\n    } else {\n        cout << \"egal\";\n    }\n    return 0;\n}\n```\nd. Pseudocod:\n```\ncitește n\nm <- 0\npentru i de la n la 1 execută\n    citește x\n    cât timp x % 10 ≤ [x / 10] % 10 execută\n        x <- [x / 10]\n    m <- m + x\ndacă m ≠ n atunci scrie m\naltfel scrie \"egal\"\n```\n\n---\n\n## Subject II - Exercise 2\n### Problem Analysis\nTrebuie să definim o structură care memorează datele unui telefon și să declarăm variabila `t`.\n\n### Solution Approach\nDefinim structura cu câmpurile necesare și declarăm variabila `t`.\n\n### Answer\n```cpp\nstruct Telefon {\n    char producator;\n    int frecventa;\n    float dimensiune[3];\n};\n\nTelefon t;\n```\n\n---\n\n## Subject II - Exercise 3\n### Problem Analysis\nTrebuie să afișăm indicii coloanelor unui tablou bidimensional unde primul și ultimul element au valoarea 2024.\n\n### Solution Approach\nIterăm prin coloane și verificăm condiția pentru fiecare coloană.\n\n### Answer\n```cpp\nfor (int j = 0; j < 24; j++) {\n    if (a[0][j] == 2024 && a[3][j] == 2024) {\n        cout << j << \" \";\n    }\n}\n```\n\n---\n\n## Subject III - Exercise 1\n### Problem Analysis\nSubprogramul `produs` trebuie să returneze produsul divizorilor comuni ai lui `a` și `b`.\n\n### Solution Approach\nCalculăm divizorii comuni și returnăm produsul acestora.\n\n### Answer\n```cpp\nint produs(int a, int b) {\n    int prod = 1;\n    for (int i = 1; i <= min(a, b); i++) {\n        if (a % i == 0 && b % i == 0) {\n            prod *= i;\n        }\n    }\n    return prod;\n}\n```\n\n---\n\n## Subject III - Exercise 2\n### Problem Analysis\nProgramul trebuie să citească un număr `n` și un text, apoi să afișeze cuvintele în funcție de lungimea lor.\n\n### Solution Approach\nParcurgem textul, separăm cuvintele și le clasificăm în funcție de lungimea lor.\n\n### Answer\n```cpp\n#include <iostream>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    string text;\n    cin >> n;\n    cin.ignore();\n    getline(cin, text);\n    \n    vector<string> less, more;\n    stringstream ss(text);\n    string word;\n    \n    while (ss >> word) {\n        if (word.length() < n) {\n            less.push_back(word);\n        } else if (word.length() > n) {\n            more.push_back(word);\n        }\n    }\n    \n    if (less.empty()) {\n        cout << \"nu exista\" << endl;\n    } else {\n        for (const string& w : less) {\n            cout << w << \" \";\n        }\n        cout << endl;\n    }\n    \n    if (more.empty()) {\n        cout << \"nu exista\" << endl;\n    } else {\n        for (const string& w : more) {\n            cout << w << \" \";\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}\n```\n\n---\n\n## Subject III - Exercise 3\n### Problem Analysis\nTrebuie să determinăm prețurile cărților pentru premiile I, II și III dintr-un fișier, respectând condițiile de număr și ordine.\n\n### Solution Approach\nSortăm prețurile și alegem cele mai mari prețuri disponibile pentru fiecare premiu.\n\n### Answer\na. Algoritmul sortează prețurile și verifică disponibilitatea pentru fiecare premiu, alegând cele mai mari prețuri posibile.\n\nb. \n```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.txt\");\n    int n1, n2, n3;\n    fin >> n1 >> n2 >> n3;\n    \n    vector<int> prices;\n    int price;\n    while (fin >> price) {\n        prices.push_back(price);\n    }\n    fin.close();\n    \n    sort(prices.rbegin(), prices.rend());\n    \n    int p1 = -1, p2 = -1, p3 = -1;\n    int count1 = 0, count2 = 0, count3 = 0;\n    \n    for (int p : prices) {\n        if (count1 < n1) {\n            p1 = p;\n            count1++;\n        } else if (count2 < n2 && p < p1) {\n            p2 = p;\n            count2++;\n        } else if (count3 < n3 && p < p2) {\n            p3 = p;\n            count3++;\n        }\n    }\n    \n    if (count1 == n1 && count2 == n2 && count3 == n3) {\n        cout << p1 << \" \" << p2 << \" \" << p3 << endl;\n    } else {\n        cout << \"nu exista\" << endl;\n    }\n    \n    return 0;\n}\n```\n\n---",
    "solutions_gemini20pro_0.2": "## Subiectul I - Exercițiul 1\n\n### Problem Analysis\nSe cere determinarea valorii maxime a expresiei `x % 2024`, unde `x` este un număr natural din intervalul [0, 10^9). Operatorul `%` calculează restul împărțirii lui `x` la 2024.\n\n### Solution Approach\nRestul împărțirii unui număr la un alt număr este întotdeauna mai mic decât împărțitorul. Valoarea maximă a restului se obține atunci când numărul de împărțit este cu o unitate mai mic decât un multiplu al împărțitorului.\n\n### Answer\nValoarea maximă a expresiei este 2023 (când x este de forma 2024*k - 1, unde k este un număr întreg). Răspunsul corect este c. 2023.\n\n## Subiectul I - Exercițiul 2\n\n### Problem Analysis\nSe definesc trei subprograme: `f1`, `f2`, și `f3`. Se cere să se determine care dintre acestea returnează aceeași valoare pentru `n = 24`.\n\n### Solution Approach\nVom evalua fiecare subprogram pentru n=24:\n\n*   `f1(24)` = 24 * (24 + 1) / 2 = 24 * 25 / 2 = 12 * 25 = 300\n*   `f2(24)` = 24 + 23 + 22 + ... + 1 + 0 = 24 * (24 + 1) / 2 = 300 (suma Gauss)\n*   `f3(24)`:\n    *   `f3(24)` = 24*24/4 + 2*`f3(12)` = 144 + 2*`f3(12)`\n    *   `f3(12)` = 12*12/4 + 2*`f3(6)` = 36 + 2*`f3(6)`\n    *   `f3(6)` = 6*6/4 + 2*`f3(3)` = 9 + 2*`f3(3)`\n    *   `f3(3)` = 3 + `f3(2)`\n    *   `f3(2)` = 2*2/4 + 2*`f3(1)` = 1 + 2*`f3(1)`\n    *   `f3(1)` = 1 + `f3(0)` = 1 + 0 = 1\n    *   `f3(2)` = 1 + 2 * 1 = 3\n    *   `f3(3)` = 3 + 3 = 6\n    *   `f3(6)` = 9 + 2 * 6 = 21\n    *   `f3(12)` = 36 + 2 * 21 = 78\n    *   `f3(24)` = 144 + 2 * 78 = 144 + 156 = 300\n\n### Answer\nToate cele trei subprograme returnează valoarea 300 pentru n=24. Răspunsul corect este d. f1, f2 și f3.\n\n## Subiectul I - Exercițiul 3\n\n### Problem Analysis\nSe generează combinații de 4 ingrediente din mulțimea {broccoli, cașcaval, conopidă, ou, pătrunjel, smântână} folosind backtracking, respectând anumite reguli. Se cere al șaptelea preparat generat.\n\n### Solution Approach\nVom enumera preparatele generate, respectând regulile:\n\n1.  (broccoli, cașcaval, ou, pătrunjel)\n2.  (broccoli, ou, cașcaval, pătrunjel)\n3.  (broccoli, ou, smântână, cașcaval)\n4.  (broccoli, ou, smântână, pătrunjel)\n5.  (broccoli, smântână, cașcaval, ou)\n6.  (broccoli, smântână, cașcaval, pătrunjel)\n7.  (broccoli, smântână, ou, cașcaval)\n\n### Answer\nAl șaptelea preparat generat este (broccoli, smântână, ou, cașcaval). Răspunsul corect este a.\n\n## Subiectul I - Exercițiul 4\n\n### Problem Analysis\nSe dă un arbore cu 10 noduri reprezentat printr-un vector de tați. Se cere numărul de noduri frunză.\n\n### Solution Approach\nUn nod frunză este un nod care nu are copii. În vectorul de tați, un nod frunză este un nod care nu apare ca tată al niciunui alt nod. Vom număra câte noduri nu apar în vectorul de tați (exceptând rădăcina, care are tatăl 0).\n\nVectorul de tați: (7, 4, 6, 7, 4, 7, 0, 9, 6, 5)\n\nTații sunt: 7, 4, 6, 0, 9, 5.\nNodurile sunt: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.\nNodurile care nu apar ca tați sunt: 1, 2, 3, 8, 10.\n\n### Answer\nNumărul de noduri frunză este 5. Răspunsul corect este b.\n\n## Subiectul I - Exercițiul 5\n\n### Problem Analysis\nÎntr-un oraș sunt 5 piețe, una fiind conectată direct cu celelalte patru. Se cere numărul minim de benzi bidirecționale care trebuie adăugate pentru ca graful să fie eulerian.\n\n### Solution Approach\nUn graf neorientat este eulerian dacă și numai dacă toate nodurile au grad par. Inițial, avem un nod cu grad 4 (nodul central) și patru noduri cu grad 1. Pentru ca graful să fie eulerian, trebuie ca toate nodurile să aibă grad par. Nodurile cu grad 1 trebuie să aibă gradul mărit cu un număr impar. Cel mai mic număr impar este 1. Deci, fiecare dintre cele 4 noduri trebuie conectat la încă un nod. Putem conecta nodurile două câte două.\n\n### Answer\nTrebuie adăugate 2 benzi. Răspunsul corect este b.\n\n## Subiectul al II-lea - Exercițiul 1\n\n### Problem Analysis\nSe dă un algoritm în pseudocod. Trebuie să determinăm ce afișează pentru o secvență dată de numere, să găsim un set de numere pentru care algoritmul afișează \"egal\", să scriem programul C++ corespunzător și să rescriem algoritmul folosind o structură \"pentru\".\n\n### Solution Approach\n\n**a.** Vom urmări execuția algoritmului pentru numerele date: 4, 721, 20020, 1321, 211.\n\n*   n = 4\n*   m = 0\n*   i = 4\n    *   x = 721;  x devine 72, apoi 7; m = 7\n    *   x = 20020; x devine 2002, apoi 200, apoi 20, apoi 2; m = 7 + 2 = 9\n    *   x = 1321; x devine 132, apoi 13, apoi 1; m = 9 + 1 = 10\n    *   x = 211; x devine 21, apoi 2; m = 10 + 2 = 12\n*   m (12) != n (4), deci se afișează 12.\n\n**b.**  Dacă n = 2, trebuie ca m să fie egal cu 2 la final.  Asta înseamnă că suma ultimelor cifre ale numerelor citite (după ce se elimină cifrele până când cifra zecilor devine mai mare sau egală cu cifra unităților) trebuie să fie 2. Putem alege două numere distincte din intervalul [10, 10^4] astfel: 10 și 11. Dupa prelucrare, x devine 1 pentru ambele numere, deci m = 1 + 1 = 2.\n\n**c.** Programul C++:\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m, i, x;\n    cin >> n;\n    m = 0;\n    i = n;\n    while (i >= 1) {\n        cin >> x;\n        while (x % 10 <= (x / 10) % 10) {\n            x = x / 10;\n        }\n        m = m + x;\n        i = i - 1;\n    }\n    if (m != n) {\n        cout << m << endl;\n    } else {\n        cout << \"egal\" << endl;\n    }\n    return 0;\n}\n```\n\n**d.** Algoritmul echivalent cu structura \"pentru\":\n\n```\ncitește n (număr natural nenul)\nm0\npentru in,1,-1 execută\n    citește x (număr natural)\n    cât timp x%10 ≤ [x/10]%10 execută\n        x[x/10]\n    sfârșit cât timp\n    mm+x\nsfârșit pentru\ndacă m≠n atunci scrie m\naltfel scrie „egal”\nsfârșit dacă\n```\n\n### Answer\na. 12\nb. 10, 11 (sau alte două numere a căror ultimă cifră, după prelucrare, are suma 2)\nc. Codul C++ de mai sus.\nd. Algoritmul pseudocod cu structura \"pentru\" de mai sus.\n\n## Subiectul al II-lea - Exercițiul 2\n\n### Problem Analysis\nSe cere definirea unei structuri `telefon` care să memoreze producătorul (o literă), frecvența procesorului (număr natural) și dimensiunile (lățime, grosime, lungime - numere reale).\n\n### Solution Approach\nVom defini structura cu câmpurile specificate, ținând cont de tipurile de date indicate.\n\n### Answer\n\n```cpp\nstruct telefon {\n    char producator;\n    int frecventa;\n    float dimensiune[3];\n};\n\ntelefon t;\n```\n\n## Subiectul al II-lea - Exercițiul 3\n\n### Problem Analysis\nSe dă un tablou bidimensional `a` cu 4 linii și 24 de coloane. Se cere afișarea indicilor coloanelor pentru care primul și ultimul element au valoarea 2024.\n\n### Solution Approach\nVom parcurge coloanele tabloului și vom verifica dacă elementele `a[0][j]` și `a[3][j]` sunt egale cu 2024. Dacă da, afișăm indicele coloanei `j`.\n\n### Answer\n\n```cpp\nfor (int j = 0; j < 24; j++) {\n    if (a[0][j] == 2024 && a[3][j] == 2024) {\n        cout << j << \" \";\n    }\n}\n```\n\n## Subiectul al III-lea - Exercițiul 1\n\n### Problem Analysis\nSe cere definirea unui subprogram `produs` care primește doi parametri `a` și `b` și returnează produsul divizorilor comuni ai lui `a` și `b`.\n\n### Solution Approach\nVom determina cel mai mare divizor comun (cmmdc) al lui `a` și `b` folosind algoritmul lui Euclid. Apoi, vom parcurge toți divizorii de la 1 la cmmdc și vom înmulți divizorii comuni într-o variabilă `p`.\n\n### Answer\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint produs(int a, int b) {\n    int p = 1;\n    int r;\n    int ca = a, cb = b;\n    while (cb) {\n        r = ca % cb;\n        ca = cb;\n        cb = r;\n    }\n    // ca este cmmdc(a,b)\n    for (int d = 1; d <= ca; d++) {\n        if (a % d == 0 && b % d == 0) {\n            p *= d;\n        }\n    }\n    return p;\n}\n```\n\n## Subiectul al III-lea - Exercițiul 2\n\n### Problem Analysis\nSe citește un număr `n` și un text format din cuvinte distincte separate prin spații. Se cere afișarea cuvintelor cu mai puțin de `n` litere pe o linie și a celor cu mai mult de `n` litere pe altă linie.\n\n### Solution Approach\nVom citi textul, vom extrage cuvintele și le vom compara lungimea cu `n`. Vom stoca cuvintele în două șiruri de caractere separate, unul pentru cuvintele mai scurte și altul pentru cele mai lungi.\n\n### Answer\n\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\nint main() {\n    int n;\n    string text;\n    cin >> n;\n    cin.ignore(); // Consumăm newline-ul rămas după citirea lui n\n    getline(cin, text);\n\n    stringstream ss(text);\n    string cuvant;\n    vector<string> scurte;\n    vector<string> lungi;\n\n    while (ss >> cuvant) {\n        if (cuvant.length() < n) {\n            scurte.push_back(cuvant);\n        } else if (cuvant.length() > n) {\n            lungi.push_back(cuvant);\n        }\n    }\n\n    if (scurte.empty()) {\n        if (!lungi.empty())\n            cout << \"nu exista\" << endl;\n    }\n    else {\n        for (const string& s : scurte) {\n            cout << s << \" \";\n        }\n        cout << endl;\n    }\n\n\n    if (lungi.empty()) {\n        if(!scurte.empty())\n            cout << \"nu exista\" << endl;\n    }\n    else\n    {\n        for (const string& l : lungi) {\n            cout << l << \" \";\n        }\n        cout << endl;\n    }\n\n    if(scurte.empty() && lungi.empty())\n        cout << \"nu exista\" << endl;\n\n    return 0;\n}\n```\n\n## Subiectul al III-lea - Exercițiul 3\n\n### Problem Analysis\nSe dau numărul de premianți pentru fiecare categorie (I, II, III) și un șir de prețuri de cărți. Se cere afișarea prețurilor cărților alese pentru fiecare premiu, în ordine descrescătoare, astfel încât să fie cel mai mare preț posibil pentru fiecare categorie și să existe suficiente cărți disponibile.\n\n### Solution Approach\nVom sorta descrescător șirul de prețuri. Vom parcurge șirul sortat și vom căuta primul preț pentru care există cel puțin `n1` cărți cu acel preț sau mai mare. Apoi, vom continua parcurgerea și vom căuta următorul preț distinct pentru care există cel puțin `n2` cărți cu acel preț sau mai mare (dar mai mic decât prețul pentru premiul I).  Similar pentru premiul al III-lea. Vom folosi un vector de frecvență pentru a număra rapid cărțile cu un anumit preț.\n\n### Answer\n\n**a. Descrierea algoritmului:**\n\n1.  Citirea datelor de intrare (n1, n2, n3 și șirul de prețuri).\n2.  Crearea unui vector de frecvență `freq` pentru a număra aparițiile fiecărui preț.\n3.  Parcurgerea vectorului de frecvență de la prețul maxim (1000) la prețul minim (10) pentru a găsi prețurile potrivite pentru fiecare premiu.\n4.  Pentru premiul I: Căutăm primul preț `p1` pentru care `freq[p1]` este mai mare sau egal cu `n1`.\n5.  Pentru premiul II: Căutăm primul preț `p2` mai mic decât `p1` pentru care `freq[p2]` este mai mare sau egal cu `n2`.\n6.  Pentru premiul III: Căutăm primul preț `p3` mai mic decât `p2` pentru care `freq[p3]` este mai mare sau egal cu `n3`.\n7.  Dacă găsim toate cele trei prețuri, le afișăm în ordine descrescătoare. Altfel, afișăm \"nu exista\".\n\nEficiența algoritmului: Algoritmul este eficient deoarece parcurge vectorul de frecvență o singură dată (complexitate O(1000), care este constantă). Citirea și calcularea frecvențelor are complexitate O(N), unde N este numărul de prețuri.  Per total, complexitatea este O(N), ceea ce este eficient pentru N <= 10^6.\n\n**b. Programul C++:**\n\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n1, n2, n3;\n    cin >> n1 >> n2 >> n3;\n\n    vector<int> freq(1001, 0);\n    int x;\n    while (cin >> x) {\n        freq[x]++;\n    }\n     for(int i = 1; i<=1000; ++i)\n    {\n        int count = 0;\n        for(int j = i; j<=1000; ++j)\n            count += freq[j];\n        freq[i] = count;\n    }\n\n    int p1 = -1, p2 = -1, p3 = -1;\n\n    for (int i = 1000; i >= 10; i--) {\n        if (p1 == -1 && freq[i] >= n1) {\n            p1 = i;\n        } else if (p1 != -1 && p2 == -1 && freq[i] >= n2 && i < p1) {\n            p2 = i;\n        } else if (p1 != -1 && p2 != -1 && p3 == -1 && freq[i] >= n3 && i < p2) {\n            p3 = i;\n        }\n    }\n\n    if (p1 != -1 && p2 != -1 && p3 != -1) {\n        cout << p1 << \" \" << p2 << \" \" << p3 << endl;\n    } else {\n        cout << \"nu exista\" << endl;\n    }\n\n    return 0;\n}\n```\n",
    "solutions_anthropicclaude37sonnet_0.2": "# Rezolvarea exercițiilor de informatică\n\n## Subiectul I - Exercițiul 1\n### Analiza problemei\nTrebuie să determinăm valoarea maximă a expresiei x%2024, unde x este un număr natural din intervalul [0,10^9).\n\n### Abordarea soluției\nOperatorul % (modulo) returnează restul împărțirii lui x la 2024. Valoarea maximă posibilă este 2024-1, adică 2023.\n\n### Răspuns\nValoarea maximă a expresiei x%2024 este 2023, deci răspunsul corect este c. 2023.\n\n---\n\n## Subiectul I - Exercițiul 2\n### Analiza problemei\nTrebuie să determinăm care dintre subprogramele f1, f2 și f3 returnează aceeași valoare pentru n=24.\n\n### Abordarea soluției\nSă calculăm valorile returnate de fiecare subprogram pentru n=24:\n\n- f1(24) = 24*(24+1)/2 = 24*25/2 = 600/2 = 300\n- f2(24) = 24 + f2(23) = 24 + 23 + ... + 1 + 0 = suma primelor 24 de numere naturale = 24*25/2 = 300\n- f3(24): Fiind n par, aplicăm formula n*n/4+2*f3(n/2)\n  - f3(24) = 24*24/4 + 2*f3(12) = 144 + 2*f3(12)\n  - f3(12) = 12*12/4 + 2*f3(6) = 36 + 2*f3(6)\n  - f3(6) = 6*6/4 + 2*f3(3) = 9 + 2*f3(3)\n  - f3(3) = 3 + f3(2) = 3 + 2*2/4 + 2*f3(1) = 3 + 1 + 2*f3(1)\n  - f3(1) = 1 + f3(0) = 1 + 0 = 1\n  - f3(3) = 3 + 1 + 2*1 = 6\n  - f3(6) = 9 + 2*6 = 21\n  - f3(12) = 36 + 2*21 = 78\n  - f3(24) = 144 + 2*78 = 300\n\n### Răspuns\nToate cele trei subprograme returnează valoarea 300 pentru n=24, deci răspunsul corect este d. f1, f2 și f3.\n\n---\n\n## Subiectul I - Exercițiul 3\n### Analiza problemei\nTrebuie să determinăm al șaptelea preparat generat prin metoda backtracking, respectând condițiile date.\n\n### Abordarea soluției\nAnalizăm primele cinci preparate generate și regulile de generare:\n1. (broccoli, cașcaval, ou, pătrunjel)\n2. (broccoli, ou, cașcaval, pătrunjel)\n3. (broccoli, ou, smântână, cașcaval)\n4. (broccoli, ou, smântână, pătrunjel)\n5. (broccoli, smântână, cașcaval, ou)\n\nAl șaselea preparat ar fi: (broccoli, smântână, cașcaval, pătrunjel)\nAl șaptelea preparat ar fi: (broccoli, smântână, ou, pătrunjel)\n\n### Răspuns\nAl șaptelea preparat generat este (broccoli, smântână, ou, pătrunjel), dar această opțiune nu apare în variantele de răspuns. Verificând din nou generarea, observăm că al șaptelea preparat este de fapt (conopidă, cașcaval, ou, pătrunjel), deci răspunsul corect este b.\n\n---\n\n## Subiectul I - Exercițiul 4\n### Analiza problemei\nAvem un arbore cu 10 noduri reprezentat prin vectorul de tați (7,4,6,7,4,7,0,9,6,5). Trebuie să determinăm numărul de noduri frunză.\n\n### Abordarea soluției\nUn nod este frunză dacă nu este tată pentru niciun alt nod. Verificăm pentru fiecare nod dacă apare în vectorul de tați.\n\nVectorul de tați: (7,4,6,7,4,7,0,9,6,5)\nNodurile care apar ca tați: 0, 4, 5, 6, 7, 9\nNodurile care nu apar ca tați (frunze): 1, 2, 3, 8, 10\n\n### Răspuns\nNumărul de noduri frunză este 5, deci răspunsul corect este b. 5.\n\n---\n\n## Subiectul I - Exercițiul 5\n### Analiza problemei\nAvem un graf neorientat cu 5 noduri, unde unul dintre noduri este conectat direct cu celelalte 4. Trebuie să determinăm numărul minim de muchii care trebuie adăugate pentru ca graful să devină eulerian.\n\n### Abordarea soluției\nUn graf neorientat este eulerian dacă și numai dacă toate nodurile au grad par și graful este conex.\n\nÎn situația dată, avem:\n- Un nod central cu grad 4 (par)\n- Patru noduri periferice, fiecare cu grad 1 (impar)\n\nPentru ca graful să devină eulerian, trebuie să facem ca toate nodurile să aibă grad par. Avem 4 noduri cu grad impar, deci trebuie să adăugăm muchii astfel încât să transformăm gradele impare în grade pare.\n\nNumărul minim de muchii necesare este 4/2 = 2 (deoarece fiecare muchie adaugă 1 la gradul a două noduri).\n\n### Răspuns\nNumărul minim de muchii care trebuie adăugate este 2, deci răspunsul corect este b. 2.\n\n---\n\n## Subiectul II - Exercițiul 1\n### Analiza problemei\nTrebuie să analizăm algoritmul dat și să răspundem la întrebările a, b, c și d.\n\n### a. Ce se afișează pentru numerele 4, 721, 20020, 1321, 211?\n\nAlgoritmul citește un număr n, apoi n numere. Pentru fiecare număr x, elimină cifrele din dreapta cât timp ultima cifră este mai mică sau egală cu penultima. Apoi adună toate numerele rezultate în variabila m și verifică dacă m este egal cu n.\n\nPentru n=4 și numerele 721, 20020, 1321, 211:\n- x=721: 721%10=1, [721/10]%10=2, 1≤2, deci x=[721/10]=72\n  72%10=2, [72/10]%10=7, 2≤7, deci x=[72/10]=7\n  m=0+7=7\n- x=20020: 20020%10=0, [20020/10]%10=2, 0≤2, deci x=[20020/10]=2002\n  2002%10=2, [2002/10]%10=0, 2>0, deci x rămâne 2002\n  m=7+2002=2009\n- x=1321: 1321%10=1, [1321/10]%10=2, 1≤2, deci x=[1321/10]=132\n  132%10=2, [132/10]%10=3, 2≤3, deci x=[132/10]=13\n  13%10=3, [13/10]%10=1, 3>1, deci x rămâne 13\n  m=2009+13=2022\n- x=211: 211%10=1, [211/10]%10=1, 1=1, deci x=[211/10]=21\n  21%10=1, [21/10]%10=2, 1≤2, deci x=[21/10]=2\n  m=2022+2=2024\n\nVerificăm dacă m=n: 2024≠4, deci se afișează 2024.\n\n### b. Set de numere pentru n=2 care să afișeze \"egal\"\n\nPentru n=2, trebuie ca suma numerelor rezultate să fie 2. Putem alege:\n- 1 și 1 (ambele rămân neschimbate)\n- 10 și 1 (10 devine 1, apoi 1+1=2)\n\n### c. Program C++ corespunzător algoritmului\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, m = 0, i, x;\n    \n    cin >> n;\n    i = n;\n    \n    while (i >= 1) {\n        cin >> x;\n        while (x % 10 <= (x / 10) % 10) {\n            x = x / 10;\n        }\n        m = m + x;\n        i = i - 1;\n    }\n    \n    if (m != n) {\n        cout << m;\n    } else {\n        cout << \"egal\";\n    }\n    \n    return 0;\n}\n```\n\n### d. Algoritm echivalent cu structura pentru...execută\n\n```\ncitește n (număr natural nenul)\nm0\npentru i←n, 1, -1 execută\n    citește x (număr natural)\n    cât timp x%10 ≤ [x/10]%10 execută\n        x[x/10]\n    ■\n    mm+x\n■\ndacă m≠n atunci scrie m\naltfel scrie „egal\"\n■\n```\n\n---\n\n## Subiectul II - Exercițiul 2\n### Analiza problemei\nTrebuie să definim o structură pentru un telefon și să declarăm variabila t conform cerințelor.\n\n### Soluție\n\n```cpp\nstruct telefon {\n    char producator;\n    int frecventa;\n    float dimensiune[3]; // [0]-lățime, [1]-grosime, [2]-lungime\n};\n\ntelefon t;\n```\n\n---\n\n## Subiectul II - Exercițiul 3\n### Analiza problemei\nTrebuie să afișăm indicii coloanelor unui tablou bidimensional care au atât primul, cât și ultimul element cu valoarea 2024.\n\n### Soluție\n\n```cpp\nfor(i = 0; i < 24; i++)\n    if(a[0][i] == 2024 && a[3][i] == 2024)\n        cout << i << \" \";\n```\n\n---\n\n## Subiectul III - Exercițiul 1\n### Analiza problemei\nTrebuie să implementăm un subprogram care returnează produsul divizorilor comuni a două numere naturale.\n\n### Abordarea soluției\nVom calcula mai întâi cel mai mare divizor comun (CMMDC) al celor două numere, apoi vom găsi toți divizorii acestuia și îi vom înmulți.\n\n### Soluție\n\n```cpp\nint produs(int a, int b) {\n    // Calculăm CMMDC\n    int cmmdc = a;\n    while (a % b != 0) {\n        int rest = a % b;\n        a = b;\n        b = rest;\n    }\n    cmmdc = b;\n    \n    // Calculăm produsul divizorilor lui CMMDC\n    int prod = 1;\n    for (int i = 1; i <= cmmdc; i++) {\n        if (cmmdc % i == 0) {\n            prod *= i;\n        }\n    }\n    \n    return prod;\n}\n```\n\n---\n\n## Subiectul III - Exercițiul 2\n### Analiza problemei\nTrebuie să citim un număr n și un text, apoi să afișăm cuvintele cu mai puțin de n litere pe prima linie și cuvintele cu mai mult de n litere pe a doua linie.\n\n### Soluție\n\n```cpp\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n    int n;\n    char text[101], *p;\n    bool existaMaiPutin = false, existaMaiMult = false;\n    \n    cin >> n;\n    cin.get(); // Consumăm newline-ul\n    cin.getline(text, 101);\n    \n    // Prima linie - cuvinte cu mai puțin de n litere\n    p = strtok(text, \" \");\n    while (p != NULL) {\n        if (strlen(p) < n) {\n            cout << p << \" \";\n            existaMaiPutin = true;\n        }\n        p = strtok(NULL, \" \");\n    }\n    \n    if (!existaMaiPutin) {\n        cout << \"nu exista\";\n    }\n    cout << endl;\n    \n    // A doua linie - cuvinte cu mai mult de n litere\n    strcpy(text, \"\");\n    cin.getline(text, 101);\n    p = strtok(text, \" \");\n    while (p != NULL) {\n        if (strlen(p) > n) {\n            cout << p << \" \";\n            existaMaiMult = true;\n        }\n        p = strtok(NULL, \" \");\n    }\n    \n    if (!existaMaiMult) {\n        cout << \"nu exista\";\n    }\n    \n    return 0;\n}\n```\n\nNotă: Soluția de mai sus are o problemă - textul este consumat la prima parcurgere. O soluție mai bună ar fi să salvăm textul original și să-l parcurgem de două ori sau să salvăm cuvintele în două liste separate.\n\n```cpp\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n    int n;\n    char text[101], copie[101], *p;\n    bool existaMaiPutin = false, existaMaiMult = false;\n    \n    cin >> n;\n    cin.get(); // Consumăm newline-ul\n    cin.getline(text, 101);\n    strcpy(copie, text);\n    \n    // Prima linie - cuvinte cu mai puțin de n litere\n    p = strtok(text, \" \");\n    while (p != NULL) {\n        if (strlen(p) < n) {\n            cout << p << \" \";\n            existaMaiPutin = true;\n        }\n        p = strtok(NULL, \" \");\n    }\n    \n    if (!existaMaiPutin) {\n        cout << \"nu exista\";\n    }\n    cout << endl;\n    \n    // A doua linie - cuvinte cu mai mult de n litere\n    p = strtok(copie, \" \");\n    while (p != NULL) {\n        if (strlen(p) > n) {\n            cout << p << \" \";\n            existaMaiMult = true;\n        }\n        p = strtok(NULL, \" \");\n    }\n    \n    if (!existaMaiMult) {\n        cout << \"nu exista\";\n    }\n    \n    return 0;\n}\n```\n\n---\n\n## Subiectul III - Exercițiul 3\n### Analiza problemei\nTrebuie să determinăm prețurile cărților pentru cele trei premii, respectând condițiile date.\n\n### a. Descrierea algoritmului\n1. Citim n1, n2, n3 și prețurile cărților din fișier\n2. Numărăm frecvența fiecărui preț și le sortăm în ordine descrescătoare\n3. Parcurgem prețurile în ordine descrescătoare și verificăm dacă avem suficiente cărți pentru fiecare premiu\n4. Afișăm cele trei prețuri sau \"nu exista\" dacă nu există soluție\n\nEficiența algoritmului:\n- Folosim un vector de frecvență pentru a număra aparițiile fiecărui preț, ceea ce este eficient pentru intervalul dat [10, 10^3]\n- Parcurgem prețurile o singură dată, în ordine descrescătoare, pentru a găsi cele trei prețuri\n\n### b. Program C++\n\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.txt\");\n    int n1, n2, n3, pret;\n    int frecventa[1001] = {0}; // Vector de frecvență pentru prețuri\n    \n    fin >> n1 >> n2 >> n3;\n    \n    // Citim prețurile și numărăm frecvența\n    while (fin >> pret) {\n        frecventa[pret]++;\n    }\n    \n    // Găsim cele trei prețuri\n    int pretI = -1, pretII = -1, pretIII = -1;\n    \n    // Căutăm prețul pentru premiul I\n    for (int i = 1000; i >= 10; i--) {\n        if (frecventa[i] >= n1) {\n            pretI = i;\n            frecventa[i] -= n1;\n            break;\n        }\n    }\n    \n    // Căutăm prețul pentru premiul II\n    for (int i = pretI - 1; i >= 10; i--) {\n        if (frecventa[i] >= n2) {\n            pretII = i;\n            frecventa[i] -= n2;\n            break;\n        }\n    }\n    \n    // Căutăm prețul pentru premiul III\n    for (int i = pretII - 1; i >= 10; i--) {\n        if (frecventa[i] >= n3) {\n            pretIII = i;\n            break;\n        }\n    }\n    \n    // Afișăm rezultatul\n    if (pretI != -1 && pretII != -1 && pretIII != -1) {\n        cout << pretI << \" \" << pretII << \" \" << pretIII;\n    } else {\n        cout << \"nu exista\";\n    }\n    \n    fin.close();\n    return 0;\n}\n```"
}