{
    "solutions_gemini20pro_0.4": "Numim secvență paritară a unui șir de numere naturale un subșir al acestuia, format din termeni cu\naceeași paritate, aflați pe poziții consecutive în șirul dat. Lungimea secvenței este egală cu numărul de\ntermeni ai acesteia.\nFișierul bac.txt conține un șir de cel puțin două și cel mult 106 numere naturale din intervalul [0, 109].\nNumerele sunt separate prin câte un spațiu, iar în șir există cel puțin doi termeni cu aceeași paritate pe\npoziții consecutive.\nSe cere să se afişeze pe ecran numărul secvențelor paritare de lungime maximă din șirul aflat în fișier,\nprecum și această lungime maximă. Numerele afişate sunt separate printr-un spațiu. Proiectați un\nalgoritm eficient din punctul de vedere al timpului de executare și al memoriei utilizate.\nExemplu: dacă fişierul conţine numerele\n2 3 5 1 7 9 8 4 4 11 15 17 21 11 6 11 15 17 21 11 6 5 2 6 4 0 16\natunci pe ecran se afișează valorile 4 5\na. Descrieți în limbaj natural algoritmul proiectat, justificând eficiența acestuia. (2p.)\nb. Scrieți programul C/C++ corespunzător algoritmului proiectat. (8p.)",
    "solutions_gpt4o_0.4": "## Subject I - Exercise 1\n### Problem Analysis\nTrebuie să identificăm expresia logică care are valoarea 1 dacă și numai dacă expresia `x>=3 && x<10` are valoarea 1.\n\n### Solution Approach\nExpresia `x>=3 && x<10` este adevărată dacă x este între 3 și 9 inclusiv. Trebuie să găsim o expresie echivalentă care să fie adevărată exact în aceleași condiții.\n\n### Answer\nb. !(x<3 || x>=10)\n\n---\n\n## Subject I - Exercise 2\n### Problem Analysis\nSubprogramul `f` trebuie să returneze 1 pentru orice număr prim `n` și 0 în caz contrar. Trebuie să completăm funcția astfel încât să verifice dacă `n` este prim.\n\n### Solution Approach\nFuncția utilizează testul de primalitate prin divizori. Trebuie să incrementăm `y` pentru a verifica toți divizorii posibili până la rădăcina pătrată a lui `x`.\n\n### Answer\na. y+2\n\n---\n\n## Subject I - Exercise 3\n### Problem Analysis\nSe generează platouri de fructe fără gutuie și piersică simultan. Trebuie să identificăm următoarea soluție după `(gutuie, prună, caisă)`.\n\n### Solution Approach\nVerificăm ordinea generării soluțiilor și respectăm restricția dată.\n\n### Answer\nb. (gutuie, prună, piersică)\n\n---\n\n## Subject I - Exercise 4\n### Problem Analysis\nElementul `A[20][j]` se află pe diagonala secundară a unui tablou 100x100. Trebuie să determinăm valoarea lui `j`.\n\n### Solution Approach\nDiagonala secundară are elementele unde `i + j = n - 1`, unde `n` este dimensiunea tabloului.\n\n### Answer\nc. 79\n\n---\n\n## Subject I - Exercise 5\n### Problem Analysis\nAvem un graf neorientat și trebuie să identificăm două muchii suplimentare care permit existența unui lanț elementar de lungime maximă.\n\n### Solution Approach\nAnalizăm structura grafului și verificăm care muchii permit extinderea lanțului elementar existent.\n\n### Answer\nb. [1,4] și [5,7]\n\n---\n\n## Subject II - Exercise 1\n### Problem Analysis\nAlgoritmul dat calculează cel mai mare divizor comun (GCD) folosind metoda lui Euclid. Trebuie să determinăm rezultatele pentru diferite valori ale lui `m` și `n`.\n\n### Solution Approach\nAnalizăm algoritmul pentru a înțelege cum se modifică variabilele și cum se calculează GCD.\n\n### Answer\na. Se afișează 1.\nb. Valorile posibile pentru `n` sunt 9 și 10.\nc. \n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    int x = 1;\n    while (x == 1) {\n        x = m;\n        int y = n;\n        n = n - 1;\n        while (x != y) {\n            if (x > y) {\n                x = x - y;\n            } else {\n                y = y - x;\n            }\n        }\n    }\n    cout << n + 1;\n    return 0;\n}\n```\nd. \n```\nciteşte m, n\nx <- 1\nrepetă\n    x <- m; y <- n; n <- n - 1\n    repetă\n        dacă x > y atunci x <- x - y\n        altfel y <- y - x\n    până când x = y\npână când x ≠ 1\nscrie n + 1\n```\n\n---\n\n## Subject II - Exercise 2\n### Problem Analysis\nTrebuie să alegem două noduri drept rădăcină astfel încât nodul 5 să aibă doi frați.\n\n### Solution Approach\nAnalizăm structura arborelui pentru a identifica nodurile care permit ca 5 să aibă doi frați.\n\n### Answer\nNodurile 2 și 8 pot fi alese drept rădăcină.\n\n---\n\n## Subject II - Exercise 3\n### Problem Analysis\nTrebuie să afișăm un mesaj bazat pe temperatura înregistrată în structura `meteo`.\n\n### Solution Approach\nUtilizăm instrucțiuni condiționale pentru a verifica temperatura și a afișa mesajul corespunzător.\n\n### Code Solution\n```cpp\n#include <iostream>\nusing namespace std;\n\nstruct meteo {\n    int an, temperatura;\n} x;\n\nint main() {\n    // Exemplu de inițializare\n    x.an = 2023;\n    x.temperatura = 12; // Modificați după caz\n\n    if (x.temperatura > 11) {\n        cout << \"CALDUROS\";\n    } else if (x.temperatura < 10) {\n        cout << \"RACOROS\";\n    } else {\n        cout << \"NORMAL\";\n    }\n    return 0;\n}\n```\n\n---\n\n## Subject III - Exercise 1\n### Problem Analysis\nSubprogramul `schimb` trebuie să înlocuiască cifra de pe poziția `p` cu cifra `x` în numărul `n`.\n\n### Solution Approach\nCalculăm poziția cifrei și utilizăm operații aritmetice pentru a modifica numărul.\n\n### Code Solution\n```cpp\nvoid schimb(int &n, int x, int p) {\n    int factor = 1;\n    for (int i = 0; i < p; ++i) {\n        factor *= 10;\n    }\n    int cifra_veche = (n / factor) % 10;\n    n = n - cifra_veche * factor + x * factor;\n}\n```\n\n---\n\n## Subject III - Exercise 2\n### Problem Analysis\nParola trebuie codificată prin înlocuirea fiecărei consoane cu vocala prietenă.\n\n### Solution Approach\nParcurgem parola și înlocuim consoanele conform regulilor date.\n\n### Code Solution\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nchar vocala_prietena(char c) {\n    if (c >= 'b' && c <= 'd') return 'a';\n    if (c >= 'f' && c <= 'h') return 'e';\n    if (c >= 'j' && c <= 'n') return 'i';\n    if (c >= 'p' && c <= 't') return 'o';\n    if (c >= 'v' && c <= 'z') return 'u';\n    return c;\n}\n\nint main() {\n    string parola;\n    cin >> parola;\n    for (char &c : parola) {\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n            c = vocala_prietena(c);\n        }\n    }\n    cout << parola;\n    return 0;\n}\n```\n\n---\n\n## Subject III - Exercise 3\n### Problem Analysis\nTrebuie să identificăm secvențele paritare de lungime maximă și să afișăm numărul acestora și lungimea maximă.\n\n### Solution Approach\nParcurgem șirul și calculăm lungimea secvențelor paritare, păstrând lungimea maximă și numărul acestora.\n\n### Code Solution\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nint main() {\n    ifstream file(\"bac.txt\");\n    int numar, lungime_curenta = 1, lungime_maxima = 1, numar_secvente = 0;\n    int paritate_anterior = -1, paritate_curenta;\n    \n    file >> numar;\n    paritate_anterior = numar % 2;\n    \n    while (file >> numar) {\n        paritate_curenta = numar % 2;\n        if (paritate_curenta == paritate_anterior) {\n            lungime_curenta++;\n        } else {\n            if (lungime_curenta > lungime_maxima) {\n                lungime_maxima = lungime_curenta;\n                numar_secvente = 1;\n            } else if (lungime_curenta == lungime_maxima) {\n                numar_secvente++;\n            }\n            lungime_curenta = 1;\n        }\n        paritate_anterior = paritate_curenta;\n    }\n    \n    // Verificăm ultima secvență\n    if (lungime_curenta > lungime_maxima) {\n        lungime_maxima = lungime_curenta;\n        numar_secvente = 1;\n    } else if (lungime_curenta == lungime_maxima) {\n        numar_secvente++;\n    }\n    \n    cout << numar_secvente << \" \" << lungime_maxima;\n    return 0;\n}\n```\n\n---\n\nAcestea sunt soluțiile complete pentru exercițiile din examenul de informatică. Dacă aveți întrebări suplimentare sau nevoie de clarificări, nu ezitați să întrebați!",
    "solutions_anthropicclaude37sonnet_0.4": "# Rezolvarea exercițiilor de informatică\n\n## Subiectul I - Exercițiul 1\n### Analiză problemă\nTrebuie să găsim o expresie echivalentă cu expresia `x>=3 && x<10`. Putem folosi legile lui De Morgan și alte proprietăți logice pentru a determina care dintre opțiunile date este echivalentă.\n\n### Abordare soluție\nExpresia `x>=3 && x<10` înseamnă că x este în intervalul [3,10). Negația acestei expresii ar fi `!(x>=3 && x<10)` care este echivalentă cu `x<3 || x>=10`. Aplicând din nou negația, obținem `!(x<3 || x>=10)` care, conform legii lui De Morgan, este echivalentă cu `!(x<3) && !(x>=10)`, adică `x>=3 && x<10`.\n\n### Răspuns\nRăspunsul corect este b. `!(x<3 || x>=10)`\n\n## Subiectul I - Exercițiul 2\n### Analiză problemă\nAvem un subprogram recursiv care verifică dacă un număr este prim. Trebuie să completăm expresia pentru apelul recursiv astfel încât funcția să returneze 1 pentru numere prime și 0 pentru celelalte.\n\n### Abordare soluție\nAnalizăm funcția:\n- Prima linie verifică dacă numărul este par și diferit de 2, caz în care returnează 0 (numărul nu este prim)\n- A doua linie verifică dacă y² > x, caz în care returnează 1 (numărul este prim)\n- A treia linie verifică dacă y este divizor al lui x, caz în care returnează 0 (numărul nu este prim)\n- În final, face un apel recursiv cu x și o expresie ce implică y\n\nPentru a verifica dacă un număr este prim, trebuie să testăm divizibilitatea cu numere de la 2 până la √x. Observăm că y este incrementat la fiecare apel recursiv.\n\n### Răspuns\nRăspunsul corect este a. `y+2`\n\n## Subiectul I - Exercițiul 3\n### Analiză problemă\nSe generează combinații de 3 fructe din 5 disponibile, cu condiția că gutuia și piersica nu pot fi împreună. Trebuie să identificăm soluția care urmează după (gutuie, prună, caisă).\n\n### Abordare soluție\nAvem fructele: măr, gutuie, prună, caisă, piersică.\nCondiția: gutuia și piersica nu pot fi împreună.\n\nPrimele patru soluții sunt:\n1. (măr, gutuie, prună)\n2. (măr, gutuie, caisă)\n3. (măr, prună, caisă)\n4. (măr, prună, piersică)\n\nContinuând generarea în ordine lexicografică, după (gutuie, prună, caisă) ar trebui să urmeze (gutuie, prună, piersică), dar această combinație nu este validă conform condiției. Deci următoarea soluție validă ar fi (prună, caisă, piersică).\n\n### Răspuns\nRăspunsul corect este d. (prună, caisă, piersică)\n\n## Subiectul I - Exercițiul 4\n### Analiză problemă\nAvem un tablou bidimensional A cu 100 de linii și 100 de coloane (indexate de la 0 la 99). Trebuie să găsim valoarea lui j astfel încât A[20][j] să fie pe diagonala secundară.\n\n### Abordare soluție\nDiagonala secundară a unui tablou cu n linii și n coloane conține elementele A[i][j] unde i+j=n-1. În cazul nostru, n=100, deci i+j=99.\nDacă i=20, atunci 20+j=99, de unde j=79.\n\n### Răspuns\nRăspunsul corect este c. 79\n\n## Subiectul I - Exercițiul 5\n### Analiză problemă\nAvem un graf neorientat cu 7 noduri și 8 muchii, dintre care 6 sunt cunoscute. Știm că unul dintre lanțurile elementare de lungime maximă este 1, 2, 7, 5, 4, 6. Trebuie să determinăm celelalte două muchii.\n\n### Abordare soluție\nDin lanțul dat, putem deduce că există muchiile [2,7], [7,5], [5,4] și [4,6]. Comparând cu muchiile cunoscute ([1,2], [2,4], [2,7], [3,4], [4,5], [4,6]), observăm că muchia [7,5] nu este printre cele cunoscute, deci este una dintre cele două necunoscute.\n\nMai avem nevoie de încă o muchie. Analizând opțiunile:\na. [1,4] și [4,7] - ar crea un ciclu 1-4-2-1\nb. [1,4] și [5,7] - [5,7] este muchia necesară\nc. [2,5] și [4,7] - ar crea un ciclu 2-5-4-2\nd. [3,6] și [5,7] - [5,7] este muchia necesară și [3,6] nu creează probleme\n\n### Răspuns\nRăspunsul corect este d. [3,6] și [5,7]\n\n## Subiectul II - Exercițiul 1\n### Analiză problemă\nTrebuie să analizăm algoritmul dat în pseudocod și să răspundem la întrebările a, b, c și d.\n\n### a. Ce se afișează pentru m=21 și n=47?\nUrmărind execuția:\n- x devine 1\n- Intrăm în primul cât timp (x=1)\n  - x devine 21, y devine 47, n devine 46\n  - Intrăm în al doilea cât timp (x≠y)\n    - x=21, y=47, deci x<y, y devine 47-21=26\n    - x=21, y=26, deci x<y, y devine 26-21=5\n    - x=21, y=5, deci x>y, x devine 21-5=16\n    - x=16, y=5, deci x>y, x devine 16-5=11\n    - x=11, y=5, deci x>y, x devine 11-5=6\n    - x=6, y=5, deci x>y, x devine 6-5=1\n    - x=1, y=5, deci x<y, y devine 5-1=4\n    - x=1, y=4, deci x<y, y devine 4-1=3\n    - x=1, y=3, deci x<y, y devine 3-1=2\n    - x=1, y=2, deci x<y, y devine 2-1=1\n    - x=1, y=1, deci x=y, ieșim din al doilea cât timp\n  - x=1, deci continuăm primul cât timp\n  - ...\n  - După mai multe iterații, x devine 1 și y devine 1, iar n devine 1\n- Ieșim din primul cât timp și afișăm n+1=2\n\n### b. Pentru m=5, care sunt valorile lui n pentru care se afișează 10?\nPentru ca rezultatul să fie 10, n trebuie să ajungă la 9 în algoritm.\nAnalizând algoritmul, observăm că el calculează CMMDC(m,n) și decrementează n până când CMMDC(m,n)=1.\nPentru m=5, n trebuie să fie un număr care, după ce îi scădem de atâtea ori cât e nevoie pentru a ajunge la CMMDC(5,n)=1, să ajungă la 9.\nValorile posibile sunt n=19 și n=29.\n\n### c. Program C++ corespunzător algoritmului\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int m, n, x, y;\n    \n    cin >> m >> n;\n    x = 1;\n    \n    while (x == 1) {\n        x = m;\n        y = n;\n        n = n - 1;\n        \n        while (x != y) {\n            if (x > y)\n                x = x - y;\n            else\n                y = y - x;\n        }\n    }\n    \n    cout << n + 1;\n    \n    return 0;\n}\n```\n\n### d. Algoritm echivalent cu structură repetitivă cu test final\n```\ncitește m,n (numere naturale nenule, m<n)\nx←1\nrepetă\n    x←m; y←n; n←n-1\n    repetă\n        dacă x>y atunci x←x-y\n        altfel y←y-x\n    până când x=y\npână când x≠1\nscrie n+1\n```\n\n### Răspuns\na. Se afișează 2\nb. n=19 și n=29\nc. Program C++ prezentat mai sus\nd. Algoritm echivalent prezentat mai sus\n\n## Subiectul II - Exercițiul 2\n### Analiză problemă\nAvem un arbore cu 9 noduri și muchiile date. Trebuie să găsim două noduri care pot fi alese drept rădăcină astfel încât nodul 5 să aibă doi \"frați\".\n\n### Abordare soluție\nÎn arbori, nodurile \"frați\" sunt nodurile care au același părinte. Dacă nodul 5 trebuie să aibă doi frați, atunci părintele său trebuie să aibă cel puțin 3 copii (inclusiv nodul 5).\n\nAnalizând muchiile:\n[1,8], [2,3], [2,5], [2,7], [4,5], [5,6], [5,8], [8,9]\n\nObservăm că:\n- Dacă rădăcina ar fi nodul 2, atunci 5 ar fi copilul lui 2, dar nu ar avea doi frați (ar avea doar nodurile 3 și 7 ca frați).\n- Dacă rădăcina ar fi nodul 8, atunci 5 ar fi copilul lui 8, dar nu ar avea doi frați (ar avea doar nodul 9 ca frate).\n\nTrebuie să găsim un nod care, ales ca rădăcină, ar face ca nodul 5 să aibă doi frați.\n\n### Răspuns\nDouă noduri care pot fi alese drept rădăcină astfel încât nodul 5 să aibă doi frați sunt 1 și 9.\n\n## Subiectul II - Exercițiul 3\n### Analiză problemă\nAvem o structură care memorează un an calendaristic și o temperatură. Trebuie să afișăm un mesaj în funcție de temperatura înregistrată.\n\n### Abordare soluție\nTrebuie să verificăm condițiile:\n- Dacă temperatura > 11°C, afișăm \"CALDUROS\"\n- Dacă temperatura < 10°C, afișăm \"RACOROS\"\n- În orice alt caz (adică temperatura = 10°C sau temperatura = 11°C), afișăm \"NORMAL\"\n\n### Răspuns\n```cpp\nif (x.temperatura > 11)\n    cout << \"CALDUROS\";\nelse if (x.temperatura < 10)\n    cout << \"RACOROS\";\nelse\n    cout << \"NORMAL\";\n```\n\n## Subiectul III - Exercițiul 1\n### Analiză problemă\nTrebuie să definim un subprogram care înlocuiește cifra de pe poziția p a numărului n cu cifra x.\n\n### Abordare soluție\nPentru a înlocui o cifră de pe o anumită poziție, putem:\n1. Descompune numărul în cifre\n2. Înlocui cifra de pe poziția p cu x\n3. Recompune numărul\n\nO abordare mai eficientă este să folosim operații aritmetice:\n1. Calculăm puterea lui 10 corespunzătoare poziției p: 10^p\n2. Eliminăm cifra de pe poziția p: n = n - (n / 10^p % 10) * 10^p\n3. Adăugăm noua cifră x pe poziția p: n = n + x * 10^p\n\n### Răspuns\n```cpp\nvoid schimb(int &n, int x, int p) {\n    // Calculăm puterea lui 10 corespunzătoare poziției p\n    long long putere = 1;\n    for (int i = 0; i < p; i++)\n        putere *= 10;\n    \n    // Eliminăm cifra de pe poziția p\n    int cifraVeche = (n / putere) % 10;\n    n = n - cifraVeche * putere;\n    \n    // Adăugăm noua cifră x pe poziția p\n    n = n + x * putere;\n}\n```\n\n## Subiectul III - Exercițiul 2\n### Analiză problemă\nTrebuie să codificăm o parolă înlocuind fiecare consoană cu vocala sa prietenă (vocala care o precede în alfabet și între care nu există altă vocală).\n\n### Abordare soluție\n1. Parcurgem fiecare caracter din parolă\n2. Dacă caracterul este o consoană, o înlocuim cu vocala sa prietenă\n3. Dacă caracterul este o vocală, îl păstrăm neschimbat\n\nPentru a găsi vocala prietenă a unei consoane, parcurgem alfabetul în sens invers începând de la consoană și ne oprim la prima vocală întâlnită.\n\n### Răspuns\n```cpp\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nbool esteVocala(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n}\n\nchar vocalaprietena(char c) {\n    char vocala = c;\n    while (vocala >= 'a' && !esteVocala(vocala)) {\n        vocala--;\n    }\n    return vocala;\n}\n\nint main() {\n    char parola[51];\n    char parolaCodificata[51];\n    \n    cin >> parola;\n    \n    int lungime = strlen(parola);\n    for (int i = 0; i < lungime; i++) {\n        if (esteVocala(parola[i])) {\n            parolaCodificata[i] = parola[i];\n        } else {\n            parolaCodificata[i] = vocalaprietena(parola[i]);\n        }\n    }\n    parolaCodificata[lungime] = '\\0';\n    \n    cout << parolaCodificata;\n    \n    return 0;\n}\n```\n\n## Subiectul III - Exercițiul 3\n### Analiză problemă\nTrebuie să determinăm numărul secvențelor paritare de lungime maximă dintr-un șir de numere naturale și lungimea acestora. O secvență paritară este formată din termeni consecutivi cu aceeași paritate.\n\n### a. Descrierea algoritmului\n1. Citim primul număr din fișier și determinăm paritatea sa\n2. Inițializăm lungimea curentă a secvenței cu 1 și lungimea maximă cu 1\n3. Inițializăm numărul de secvențe de lungime maximă cu 1\n4. Pentru fiecare număr rămas din fișier:\n   - Citim numărul și determinăm paritatea sa\n   - Dacă paritatea este aceeași cu paritatea numărului anterior, incrementăm lungimea curentă\n   - Altfel, resetăm lungimea curentă la 1 și actualizăm paritatea curentă\n   - Dacă lungimea curentă este egală cu lungimea maximă, incrementăm numărul de secvențe\n   - Dacă lungimea curentă este mai mare decât lungimea maximă, actualizăm lungimea maximă și resetăm numărul de secvențe la 1\n5. Afișăm numărul de secvențe de lungime maximă și lungimea maximă\n\nAlgoritmul este eficient deoarece:\n- Parcurge șirul o singură dată (complexitate O(n))\n- Folosește memorie constantă (nu stochează întregul șir)\n\n### b. Program C++ corespunzător algoritmului\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.txt\");\n    \n    int numarCurent, numarAnterior;\n    int lungimeCurenta = 1, lungimeMaxima = 1;\n    int numarSecvente = 1;\n    \n    fin >> numarAnterior;\n    bool paritateaCurenta = (numarAnterior % 2 == 0);\n    \n    while (fin >> numarCurent) {\n        bool paritateaNoua = (numarCurent % 2 == 0);\n        \n        if (paritateaNoua == paritateaCurenta) {\n            lungimeCurenta++;\n            \n            if (lungimeCurenta > lungimeMaxima) {\n                lungimeMaxima = lungimeCurenta;\n                numarSecvente = 1;\n            } else if (lungimeCurenta == lungimeMaxima) {\n                numarSecvente++;\n            }\n        } else {\n            lungimeCurenta = 1;\n            paritateaCurenta = paritateaNoua;\n        }\n        \n        numarAnterior = numarCurent;\n    }\n    \n    cout << numarSecvente << \" \" << lungimeMaxima;\n    \n    fin.close();\n    return 0;\n}\n```\n\n### Răspuns\na. Descrierea algoritmului prezentată mai sus\nb. Program C++ prezentat mai sus"
}