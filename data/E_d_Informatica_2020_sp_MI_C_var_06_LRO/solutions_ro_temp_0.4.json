{
    "solutions_gpt4o_0.4": "## Subject I - Exercise 1\n### Problem Analysis\nTrebuie să determinăm valoarea expresiei `3+5.0/2+2` în C/C++. Este important să observăm că `5.0` este un număr de tip `double`, ceea ce va influența rezultatul operațiilor.\n\n### Solution Approach\n1. În C/C++, operația de împărțire între un `double` și un `int` va produce un `double`.\n2. `5.0/2` va fi evaluat la `2.5`.\n3. Adunăm `3` și `2` la `2.5`, obținând `7.5`.\n\n### Answer\nd. 7.5\n\n---\n\n## Subject I - Exercise 2\n### Problem Analysis\nSubprogramul `f` este recursiv și modifică valorile tabloului `v` în funcție de condiția `i >= 3`. Trebuie să determinăm valorile inițiale ale tabloului astfel încât să se afișeze `2020`.\n\n### Solution Approach\n1. Funcția `f` începe cu `i=0` și continuă recursiv până `i` ajunge la `3`.\n2. Pentru `i >= 3`, se incrementează `v[i]` și se afișează `v[i]`.\n3. Trebuie să ajustăm valorile inițiale ale tabloului astfel încât să obținem `2020`.\n\n### Answer\na. -1,1,0,2\n\n---\n\n## Subject I - Exercise 3\n### Problem Analysis\nSe generează soluții pentru suma de 200 lei, respectând condițiile de ordonare și divizibilitate. Trebuie să identificăm a șasea soluție.\n\n### Solution Approach\n1. Folosim metoda backtracking pentru a genera soluții.\n2. Verificăm divizibilitatea cu 10 și ordonarea descrescătoare a sumelor.\n3. Identificăm soluțiile în ordinea generării.\n\n### Answer\nb. (80,60,50,10)\n\n---\n\n## Subject I - Exercise 4\n### Problem Analysis\nAvem un arbore reprezentat prin vectorul de \"tați\". Trebuie să identificăm numărul de noduri \"frunză\".\n\n### Solution Approach\n1. Un nod \"frunză\" este un nod care nu are copii.\n2. Verificăm nodurile care nu apar ca \"tați\" pentru alte noduri.\n\n### Answer\nc. 5\n\n---\n\n## Subject I - Exercise 5\n### Problem Analysis\nAvem un graf neorientat reprezentat prin matricea de adiacență. Trebuie să determinăm numărul de grafuri parțiale conexe diferite de graful dat.\n\n### Solution Approach\n1. Identificăm subgrafurile conexe prin eliminarea unor noduri și muchii.\n2. Calculăm numărul subgrafurilor care sunt conexe și diferite de graful dat.\n\n### Answer\nb. 6\n\n---\n\n## Subject II - Exercise 1\n### Problem Analysis\nAlgoritmul dat în pseudocod verifică anumite condiții pentru cifrele unui număr. Trebuie să determinăm valorile afișate și să scriem programul corespunzător.\n\n### Solution Approach\na. Calculăm valorile afișate pentru numărul `240107`.\nb. Identificăm numerele din intervalul `[105,106)` cu cifre distincte care îndeplinesc condițiile.\nc. Scriem programul C/C++ corespunzător.\nd. Modificăm structura repetitivă în pseudocod.\n\n### Answer\na. Valorile afișate: 0 1 0 1 0 1\nb. Cel mai mic număr: 123456, cel mai mare număr: 987654\nc. Programul C/C++:\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a;\n    cin >> a;\n    int c = 0;\n    do {\n        int b = a, x = 0;\n        do {\n            if (b % 10 == c) x = 1;\n            b /= 10;\n        } while (b != 0 && x != 1);\n        cout << x << ' ';\n        c += 2;\n    } while (c <= 9);\n    return 0;\n}\n```\nd. Algoritm echivalent în pseudocod:\n```\ncitește a (număr natural)\nc ← 0\nrepetă\n    b ← a; x ← 0\n    cât timp b ≠ 0 și x ≠ 1 execută\n        dacă b % 10 = c atunci\n            x ← 1\n        b ← [b / 10]\n    scrie x, ' '\n    c ← c + 2\npână când c > 9\n```\n\n---\n\n## Subject II - Exercise 2\n### Problem Analysis\nTrebuie să definim o structură pentru un calculator care memorează capacitatea memoriei și tipul monitorului.\n\n### Solution Approach\n1. Definim structura `calculator` cu câmpurile necesare.\n2. Declarăm variabila `c` de tipul acestei structuri.\n\n### Answer\n```cpp\nstruct calculator {\n    char monitor;\n    int memorie_interna;\n    int memorie_externa;\n};\n\ncalculator c;\n```\n\n---\n\n## Subject II - Exercise 3\n### Problem Analysis\nTrebuie să completăm secvența astfel încât tabloul să fie actualizat conform unui model specific.\n\n### Solution Approach\n1. Identificăm modelul de actualizare a elementelor tabloului.\n2. Implementăm logica în buclele `for`.\n\n### Answer\n```cpp\nfor (i = 0; i < 9; i++)\n    for (j = 0; j < 9; j++)\n        if (i <= j)\n            a[i][j] = '>';\n        else\n            a[i][j] = '<';\n```\n\n---\n\n## Subject III - Exercise 1\n### Problem Analysis\nTrebuie să scriem un subprogram care returnează suma divizorilor comuni a două numere naturale.\n\n### Solution Approach\n1. Determinăm divizorii comuni ai numerelor `a` și `b`.\n2. Calculăm suma acestor divizori.\n\n### Answer\n```cpp\nint suma(int a, int b) {\n    int sum = 0;\n    for (int i = 1; i <= min(a, b); i++) {\n        if (a % i == 0 && b % i == 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}\n```\n\n---\n\n## Subject III - Exercise 2\n### Problem Analysis\nTrebuie să rotim spre stânga cuvintele dintr-un text care au cel puțin trei litere.\n\n### Solution Approach\n1. Citim textul și îl împărțim în cuvinte.\n2. Rotim cuvintele care au cel puțin trei litere.\n3. Afișăm textul modificat sau mesajul corespunzător.\n\n### Answer\n```cpp\n#include <iostream>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    string text;\n    getline(cin, text);\n    stringstream ss(text);\n    string word;\n    vector<string> words;\n    bool exists = false;\n\n    while (ss >> word) {\n        if (word.length() >= 3) {\n            exists = true;\n            word = word.substr(1) + word[0];\n        }\n        words.push_back(word);\n    }\n\n    if (exists) {\n        for (const auto& w : words) {\n            cout << w << ' ';\n        }\n    } else {\n        cout << \"nu exista\";\n    }\n\n    return 0;\n}\n```\n\n---\n\n## Subject III - Exercise 3\n### Problem Analysis\nTrebuie să determinăm dacă un șir de numere poate fi rearanjat astfel încât să formeze un șir palindromic.\n\n### Solution Approach\n1. Verificăm frecvența fiecărui număr din șir.\n2. Un șir poate fi palindromic dacă cel mult un număr apare de un număr impar de ori.\n\n### Answer\na. Algoritmul:\n- Calculăm frecvența fiecărui număr.\n- Verificăm dacă cel mult un număr are frecvență impară.\n- Dacă da, afișăm \"DA\", altfel \"NU\".\n\nb. Programul C/C++:\n```cpp\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.in\");\n    unordered_map<int, int> freq;\n    int num;\n    while (fin >> num) {\n        freq[num]++;\n    }\n    fin.close();\n\n    int odd_count = 0;\n    for (const auto& pair : freq) {\n        if (pair.second % 2 != 0) {\n            odd_count++;\n        }\n    }\n\n    if (odd_count <= 1) {\n        cout << \"DA\";\n    } else {\n        cout << \"NU\";\n    }\n\n    return 0;\n}\n```\n\n---",
    "solutions_gemini20pro_0.4": "## Subiectul I - Exercițiul 1\n\n### Problemă Analiză\nTrebuie să evaluăm o expresie aritmetică simplă, respectând ordinea operațiilor.\n\n### Soluție Abordare\n1. Împărțirea are prioritate: 5.0 / 2 = 2.5\n2. Adunăm rezultatele: 3 + 2.5 + 2 = 7.5\n\n### Răspuns\nd. 7.5\n\n---\n\n## Subiectul I - Exercițiul 2\n\n### Problemă Analiză\nTrebuie să determinăm starea inițială a unui vector `v` astfel încât, după apelul recursiv al funcției `f`, să se afișeze \"2020\". Funcția incrementează `v[i]` doar dacă `i >= 3`.\n\n### Soluție Abordare\n1. Urmărim execuția funcției `f(0, v)`:\n    - `f(0, v)`: `i` (0) nu e >= 3, deci se apelează `f(1, v)`\n    - `f(1, v)`: `i` (1) nu e >= 3, deci se apelează `f(2, v)`\n    - `f(2, v)`: `i` (2) nu e >= 3, deci se apelează `f(3, v)`\n    - `f(3, v)`: `i` (3) >= 3, deci `v[3] = v[3] + 1`. Se afișează `v[3]`.\n    - Revenire din `f(3, v)`: se afișează `v[2]`.\n    - Revenire din `f(2, v)`: se afișează `v[1]`.\n    - Revenire din `f(1, v)`: se afișează `v[0]`.\n2. Pentru a afișa \"2020\", trebuie ca `v[3]`, `v[2]`, `v[1]`, `v[0]` să fie, în ordine, 0, 2, 0, 2 după execuția lui `f`.\n3. Deoarece doar `v[3]` este modificat (incrementat cu 1), valorile inițiale trebuie să fie:\n    - `v[0] = 2`\n    - `v[1] = 0`\n    - `v[2] = 2`\n    - `v[3] = -1` (pentru ca după incrementare să devină 0)\n4. Ordinea elementelor este `v[0]`, `v[1]`, `v[2]`, `v[3]`.\n\n### Răspuns\na. -1,1,0,2  *Răspunsul corect este d. 2,0,2,-1. Am corectat greșeala de logică.*\n\n### Răspuns Corect\nd. 2,0,2,-1\n\n---\n\n## Subiectul I - Exercițiul 3\n\n### Problemă Analiză\nTrebuie să găsim a șasea soluție generată prin backtracking pentru problema plății unei sume de 200 lei de către patru persoane, respectând condițiile date.\n\n### Soluție Abordare\n1. Condițiile sunt:\n    - Fiecare sumă este nenulă și divizibilă cu 10.\n    - Sumele sunt în ordine descrescătoare (persoana 1 plătește mai mult decât persoana 2, etc.).\n    - Suma totală este 200.\n2. Listăm soluțiile generate, continuând de la cele date:\n    1. (70, 60, 40, 30)\n    2. (70, 60, 50, 20)\n    3. (80, 50, 40, 30)\n    4. (80, 60, 40, 20)\n    5. (80, 60, 50, 10)\n    6. (90, 50, 40, 20)\n\n### Răspuns\nNu există printre variantele date. Răspunsul corect este (90, 50, 40, 20). Cea mai apropiată variantă, dar incorectă, este b. (80, 60, 50, 10).\n\n---\n\n## Subiectul I - Exercițiul 4\n\n### Problemă Analiză\nTrebuie să determinăm numărul de noduri frunză (noduri fără copii) într-un arbore dat prin vectorul său de tați.\n\n### Soluție Abordare\n1. Un nod este frunză dacă nu apare ca tată pentru niciun alt nod.\n2. Vectorul de tați este: (7, 5, 6, 5, 7, 0, 6, 3, 3, 8).\n3. Identificăm nodurile care apar ca tați:\n    - 7 (apare pentru 1 și 5)\n    - 5 (apare pentru 2 și 4)\n    - 6 (apare pentru 3 și 7)\n    - 0 (rădăcina, nu e frunză)\n    - 3 (apare pentru 8 și 9)\n    - 8 (apare pentru 10)\n4. Nodurile care nu apar în vectorul de tați (în afară de 0, care este rădăcina) sunt frunze: 1, 2, 4, 9, 10.\n5. Există 4 noduri care *nu* sunt parinti: 1, 2, 4, 10.\n\n### Răspuns\nc. *5. Răspunsul corect este 4. Am corectat numărătoarea.*\n\n### Răspuns Corect\nb. 4\n\n---\n\n## Subiectul I - Exercițiul 5\n\n### Problemă Analiză\nTrebuie să determinăm numărul de grafuri parțiale conexe ale unui graf dat, diferite de graful original.\n\n### Soluție Abordare\n1. Un graf parțial se obține eliminând una sau mai multe muchii din graful original.\n2. Graful este conex.\n3. Trebuie să numărăm grafurile parțiale care rămân conexe *după* eliminarea muchiilor.\n4. Matricea de adiacență:\n```\n0 1 0 1 1\n1 0 1 0 0\n0 1 0 1 0\n1 0 1 0 0\n1 0 0 0 0\n```\n5. Graful are 5 noduri și 5 muchii.\n6.  Identificăm muchiile: (1,2), (1,4), (1,5), (2,3), (3,4).\n7.  Numărăm câte muchii putem elimina, păstrând graful conex:\n    - Putem elimina oricare 1 muchie: 5 posibilități.\n    - Putem elimina oricare 2 muchii, mai putin perechile (1,2)-(2,3) si (1,4)-(3,4) :  10 - 2 = 8 posibilitati. Dar, graful trebuie sa ramana conex.\n    - Putem elimina muchiile: (1,2) si (1,4) - conex\n    - Putem elimina muchiile: (1,2) si (1,5) - conex\n    - Putem elimina muchiile: (1,2) si (3,4) - conex\n    - Putem elimina muchiile: (1,4) si (1,5) - conex\n    - Putem elimina muchiile: (1,4) si (2,3) - conex\n    - Putem elimina muchiile: (1,5) si (2,3) - conex\n    - Putem elimina muchiile: (1,5) si (3,4) - conex\n    - Putem elimina muchiile: (2,3) si (3,4) - conex\n    - Nu putem elimina 3 muchii fara sa-l deconectam.\n    - In total, avem 5 (eliminand 1 muchie) + 8 (eliminand 2 muchii) = 5 + 8 = 13. Dar, graful dat este si el conex. Deci, trebuie sa scadem 1.\n8.  Avem 5 muchii. Putem elimina oricare muchie, rezultand 5 grafuri conexe.\n9.  Putem elimina oricare doua muchii, dar graful sa ramana conex. Perechile posibile sunt:\n    - (1,2), (1,4)\n    - (1,2), (1,5)\n    - (1,2), (3,4)\n    - (1,4), (1,5)\n    - (1,4), (2,3)\n    - (1,5), (2,3)\n    - (1,5), (3,4)\n    - (2,3), (3,4)\n    Avem 8 perechi.\n10. In total, 5 + 8 = 13. Scadem graful initial. 13-1=12.\n\n### Răspuns\nNu există printre variantele date. Răspunsul corect este 12.\n\n---\n\n## Subiectul II - Exercițiul 1\n\n### Problemă Analiză\nTrebuie să analizăm un algoritm pseudocod și să răspundem la mai multe întrebări legate de acesta.\n\n### a. Valori afișate pentru 240107\n\n### Soluție Abordare\nUrmărim execuția algoritmului cu a = 240107:\n\n- c = 0\n- Repetă:\n    - b = 240107; x = 0\n    - Repetă:\n        - Dacă b % 10 == c (0):\n            - b % 10 = 7, 7 != 0\n        - b = 24010\n        - Dacă b % 10 == c (0):\n            - b % 10 = 0, 0 == 0, x = 1\n    - Scrie x (1), ' '\n    - c = 2\n- Repetă:\n    - b = 240107; x = 0\n    - Repetă:\n        - Dacă b % 10 == c (2):\n           -  b%10 = 7, 7!=2\n        - b = 24010\n        - Dacă b%10 == c(2):\n            - b%10=0, 0!=2\n        - ...\n        - b = 24, b%10 = 4, 4!=2\n        - b = 2, b%10 = 2, 2==2, x=1\n    - Scrie x (1), ' '\n    - c = 4\n- Repetă:\n    - b = 240107, x=0\n    - Repeta:\n        - Daca b%10 == c(4)\n            - b%10 = 7, 7!=4\n        - b = 24010\n        - b%10 = 0, 0!=4\n        - ...\n        - b = 24, b%10 = 4, 4==4, x=1\n    - Scrie x(1), ' '\n    - c = 6\n- Repeta:\n    - b = 240107, x=0\n        - Daca b%10 == c(6):\n            - b%10=7, 7!=6\n        - b = 24010\n        - b%10 = 0, 0!=6\n        - ...\n        - b = 24010, b%10 = 0, 0 != 6\n        - b = 2401, b%10 = 1, 1 != 6\n        - b = 240, b%10 = 0, 0 != 6\n        - b=24, b%10 = 4, 4!=6\n        - b=2, b%10=2, 2!=6\n    - Scrie x(0), ' '\n    - c = 8\n- Repeta:\n    - b = 240107, x=0\n    - ...\n    - Scrie x(0), ' '\n    - c=10\n- c > 9, deci se opreste.\n\n### Răspuns\n1 1 1 0 0\n\n### b. Cel mai mic și cel mai mare număr\n\n### Soluție Abordare\nToate valorile afișate trebuie să fie nenule (adică 1). Asta înseamnă că pentru fiecare `c` (0, 2, 4, 6, 8), cifra `c` trebuie să existe în număr. Numerele trebuie să fie între 100000 (inclusiv) și 1000000 (exclusiv) și să aibă cifre distincte.\n\n- Cel mai mic: Trebuie să conțină cifrele 0, 2, 4, 6, 8. Cea mai mică cifră nenulă trebuie să fie prima. Deci, numărul este 102468.\n- Cel mai mare: Trebuie să conțină cifrele 0, 2, 4, 6, 8. Cea mai mare cifră trebuie să fie prima. Pentru a maximiza, ordonăm descrescător cifrele rămase. Deci, numărul este 986420.\n\n### Răspuns\nCel mai mic: 102468\nCel mai mare: 986420\n\n### c. Program C++\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int a, b, c, x;\n    cin >> a;\n    c = 0;\n    do {\n        b = a;\n        x = 0;\n        do {\n            if (b % 10 == c) {\n                x = 1;\n            }\n            b = b / 10;\n        } while (b != 0 && x != 1);\n        cout << x << \" \";\n        c = c + 2;\n    } while (c <= 9);\n    cout << endl;\n    return 0;\n}\n```\n\n### d. Algoritm echivalent\n\n```\ncitește a (număr natural)\nc←0\n┌repetă\n│ b←a; x←0\n│┌cât timp b≠0 și x=0 execută\n││┌dacă b%10=c atunci\n│││ x←1\n││└■\n││ b←[b/10]\n│└■\n│ scrie x,’ ’\n│ c←c+2\n└până când c>9\n```\n\n---\n\n## Subiectul II - Exercițiul 2\n\n### Problemă Analiză\nTrebuie să definim o structură `calculator` care să stocheze informații despre un calculator (capacitatea memoriei interne, externe și tipul monitorului).\n\n### Soluție Abordare\nDefinim structura cu câmpurile corespunzătoare și declarăm variabila `c`.\n\n### Răspuns\n```cpp\nstruct memorie {\n    int interna;\n    int externa;\n};\n\nstruct calculator {\n    char monitor;\n    memorie memorie;\n};\n\ncalculator c;\n```\n\n---\n\n## Subiectul II - Exercițiul 3\n\n### Problemă Analiză\nTrebuie să completăm o secvență de cod C++ care inițializează o matrice bidimensională cu anumite valori.\n\n### Soluție Abordare\nAnalizăm matricea rezultată și observăm relația dintre indicii `i` și `j` și caracterele afișate:\n- `>` este peste tot\n- `<` apare cand i > j si i + j > 8\n\n### Răspuns\n```cpp\nfor(i=0;i<9;i++)\n for(j=0;j<9;j++)\n    if(i>j && i+j>8)\n        a[i][j]='<';\n    else\n        a[i][j]='>';\n```\n\n---\n\n## Subiectul III - Exercițiul 1\n\n### Problemă Analiză\nTrebuie să scriem definiția completă a unui subprogram `suma` care calculează suma divizorilor comuni a două numere.\n\n### Soluție Abordare\n1. Parcurgem toate numerele de la 1 la minimul dintre `a` și `b`.\n2. Verificăm dacă fiecare număr este divizor comun al lui `a` și `b`.\n3. Dacă este divizor comun, îl adăugăm la sumă.\n\n### Răspuns\n```cpp\n#include <iostream>\nusing namespace std;\n\nint suma(int a, int b) {\n    int s = 0;\n    int m = (a < b) ? a : b;\n    for (int i = 1; i <= m; i++) {\n        if (a % i == 0 && b % i == 0) {\n            s = s + i;\n        }\n    }\n    return s;\n}\n```\n\n---\n\n## Subiectul III - Exercițiul 2\n\n### Problemă Analiză\nTrebuie să scriem un program care rotește spre stânga cuvintele dintr-un text, dacă acestea au cel puțin trei litere.\n\n### Soluție Abordare\n1. Citim textul.\n2. Parcurgem textul cuvânt cu cuvânt.\n3. Pentru fiecare cuvânt, verificăm lungimea.\n4. Dacă lungimea este >= 3, rotim cuvântul.\n5. Afișăm textul modificat.\n\n### Răspuns\n```cpp\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint main() {\n    char text[101], *cuvant, text_nou[101] = \"\";\n    cin.getline(text, 101);\n    bool exista = false;\n\n    cuvant = strtok(text, \" \");\n    while (cuvant != NULL) {\n        if (strlen(cuvant) >= 3) {\n            exista = true;\n            char prima_litera = cuvant[0];\n            strcpy(cuvant, cuvant + 1);\n            cuvant[strlen(cuvant)] = prima_litera;\n            cuvant[strlen(cuvant) + 1] = '\\0';\n        }\n        strcat(text_nou, cuvant);\n        strcat(text_nou, \" \");\n        cuvant = strtok(NULL, \" \");\n    }\n\n    if (exista) {\n        cout << text_nou << endl;\n    } else {\n        cout << \"nu exista\" << endl;\n    }\n\n    return 0;\n}\n```\n\n---\n\n## Subiectul III - Exercițiul 3\n\n### Problemă Analiză\nTrebuie să verificăm dacă un șir de numere poate fi rearanjat pentru a forma un palindrom.\n\n### Soluție Abordare\n1. Un șir poate fi rearanjat ca palindrom dacă și numai dacă există cel mult un număr cu frecvență impară.\n2. Folosim un vector de frecvență pentru a număra aparițiile fiecărui număr.\n3. Parcurgem vectorul de frecvență și numărăm câte elemente au frecvență impară.\n4. Dacă numărul de elemente cu frecvență impară este <= 1, afișăm \"DA\", altfel afișăm \"NU\".\n\n### a. Descriere algoritm\n\nAlgoritmul este eficient ca timp de executare deoarece parcurge șirul de numere o singură dată pentru a construi vectorul de frecvență (complexitate O(n), unde n este numărul de elemente din șir) și apoi parcurge vectorul de frecvență o singură dată (complexitate O(m), unde m este numărul maxim posibil de valori distincte, care este constant - 1000 in acest caz). Complexitatea totală este O(n), fiind dominată de citirea șirului.\n\n### b. Program C++\n\n```cpp\n#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.in\");\n    int frecventa[1001] = {0};\n    int x, nr_impare = 0;\n\n    while (fin >> x) {\n        frecventa[x]++;\n    }\n\n    for (int i = 1; i <= 1000; i++) {\n        if (frecventa[i] % 2 != 0) {\n            nr_impare++;\n        }\n    }\n\n    if (nr_impare <= 1) {\n        cout << \"DA\" << endl;\n    } else {\n        cout << \"NU\" << endl;\n    }\n\n    fin.close();\n    return 0;\n}\n```\n",
    "solutions_anthropicclaude37sonnet_0.4": "# Rezolvarea exercițiilor de informatică\n\n## Subiectul I - Exercițiul 1\n### Analiza problemei\nTrebuie să evaluăm expresia C/C++ `3+5.0/2+2`.\n\n### Abordarea soluției\nÎn C/C++, operațiile se efectuează conform priorității operatorilor. Împărțirea are prioritate mai mare decât adunarea.\n\nEvaluăm expresia pas cu pas:\n1. `5.0/2` = `2.5` (împărțire reală pentru că unul din operanzi este real)\n2. `3+2.5+2` = `7.5`\n\n### Răspuns\nRăspunsul corect este d. 7.5\n\n## Subiectul I - Exercițiul 2\n### Analiza problemei\nAvem un subprogram recursiv `f` care primește un indice `i` și un vector `v` cu 4 elemente. Trebuie să determinăm valorile inițiale ale vectorului pentru care apelul `f(0,v)` afișează `2020`.\n\n### Abordarea soluției\nSă analizăm funcția `f`:\n- Dacă `i>=3`, atunci incrementează `v[i]` și afișează `v[i]`\n- Altfel, apelează recursiv `f(i+1,v)` și apoi afișează `v[i]`\n\nDeci ordinea de afișare va fi: `v[3]` (posibil incrementat), `v[2]`, `v[1]`, `v[0]`.\nPentru a obține `2020`, avem nevoie ca aceste valori să fie afișate în ordinea `2`, `0`, `2`, `0`.\n\nAnalizând recursivitatea:\n- Apelul inițial `f(0,v)` va apela `f(1,v)`\n- `f(1,v)` va apela `f(2,v)`\n- `f(2,v)` va apela `f(3,v)`\n- `f(3,v)` va incrementa `v[3]` și va afișa `v[3]`\n- Apoi se revine la `f(2,v)` care afișează `v[2]`\n- Apoi se revine la `f(1,v)` care afișează `v[1]`\n- Apoi se revine la `f(0,v)` care afișează `v[0]`\n\n### Răspuns\nPentru ca afișarea să fie `2020`, avem nevoie ca:\n- `v[3]` să fie inițial `1` (pentru ca după incrementare să devină `2`)\n- `v[2]` să fie `0`\n- `v[1]` să fie `2`\n- `v[0]` să fie `0`\n\nDeci răspunsul corect este b. 0,2,0,1\n\n## Subiectul I - Exercițiul 3\n### Analiza problemei\nSe generează toate variantele prin care patru persoane pot plăti o consumație de 200 de lei, cu condiția că fiecare sumă este nenulă, divizibilă cu 10, și sumele sunt în ordine strict descrescătoare.\n\n### Abordarea soluției\nPrimele patru soluții sunt:\n1. (70, 60, 40, 30)\n2. (70, 60, 50, 20)\n3. (80, 50, 40, 30)\n4. (80, 60, 40, 20)\n\nTrebuie să determinăm a șasea soluție. Pentru aceasta, continuăm generarea în ordine lexicografică:\n5. A cincea soluție: (80, 60, 50, 10)\n6. A șasea soluție: trebuie să o determinăm\n\nPentru a determina a șasea soluție, trebuie să vedem care este următoarea după (80, 60, 50, 10).\nDacă analizăm pattern-ul, următoarea soluție ar trebui să fie (80, 70, 30, 20).\n\n### Răspuns\nRăspunsul corect este c. (80,70,30,20)\n\n## Subiectul I - Exercițiul 4\n### Analiza problemei\nAvem un arbore reprezentat prin vectorul de tați (7,5,6,5,7,0,6,3,3,8). Trebuie să determinăm numărul de noduri frunză.\n\n### Abordarea soluției\nUn nod este frunză dacă nu este tată pentru niciun alt nod. Deci trebuie să identificăm nodurile care nu apar în vectorul de tați.\n\nVectorul de tați este: (7,5,6,5,7,0,6,3,3,8)\nNodurile sunt numerotate de la 1 la 10.\n\nVerificăm pentru fiecare nod dacă apare ca tată:\n- Nodul 1: nu apare ca tată\n- Nodul 2: nu apare ca tată\n- Nodul 3: apare ca tată pentru nodurile 8 și 9\n- Nodul 4: nu apare ca tată\n- Nodul 5: apare ca tată pentru nodurile 2 și 4\n- Nodul 6: apare ca tată pentru nodurile 3 și 7\n- Nodul 7: apare ca tată pentru nodurile 1 și 5\n- Nodul 8: apare ca tată pentru nodul 10\n- Nodul 9: nu apare ca tată\n- Nodul 10: nu apare ca tată\n\nDeci nodurile frunză sunt: 1, 2, 4, 9, 10 (5 noduri).\n\n### Răspuns\nRăspunsul corect este c. 5\n\n## Subiectul I - Exercițiul 5\n### Analiza problemei\nAvem un graf neorientat cu 5 noduri reprezentat prin matricea de adiacență dată. Trebuie să determinăm numărul grafurilor parțiale conexe diferite de graful dat.\n\n### Abordarea soluției\nUn graf parțial se obține eliminând una sau mai multe muchii din graful original, păstrând toate nodurile.\nPentru ca graful parțial să fie conex, trebuie să existe un drum între oricare două noduri.\n\nDin matricea de adiacență, putem vedea că graful original are muchiile:\n(1,2), (1,4), (1,5), (2,3), (3,4)\n\nGraful are 5 muchii. Numărul total de grafuri parțiale este 2^5 = 32 (pentru fiecare muchie, avem opțiunea de a o păstra sau elimina).\n\nDin aceste 32 de grafuri parțiale, trebuie să excludem:\n- Graful original (1 graf)\n- Grafurile neconexe\n\nPentru a verifica conexitatea, putem elimina fiecare combinație posibilă de muchii și verifica dacă graful rezultat rămâne conex.\n\nDupă analiză, rezultă că există 8 grafuri parțiale conexe diferite de graful original.\n\n### Răspuns\nRăspunsul corect este c. 8\n\n## Subiectul II - Exercițiul 1\n### Analiza problemei\nAvem un algoritm în pseudocod care verifică pentru fiecare cifră pară c (0, 2, 4, 6, 8) dacă aceasta apare în numărul a.\n\n### Abordarea soluției\na) Pentru a=240107:\n   - c=0: Verificăm dacă 0 apare în 240107 -> Da, afișăm 1\n   - c=2: Verificăm dacă 2 apare în 240107 -> Da, afișăm 1\n   - c=4: Verificăm dacă 4 apare în 240107 -> Da, afișăm 1\n   - c=6: Verificăm dacă 6 apare în 240107 -> Nu, afișăm 0\n   - c=8: Verificăm dacă 8 apare în 240107 -> Nu, afișăm 0\n   Rezultatul afișat este: 1 1 1 0 0\n\nb) Pentru ca toate valorile afișate să fie nenule, numărul trebuie să conțină toate cifrele pare (0, 2, 4, 6, 8).\n   - Cel mai mic număr din [10^5, 10^6) cu cifre distincte care conține toate cifrele pare: 102468\n   - Cel mai mare număr din [10^5, 10^6) cu cifre distincte care conține toate cifrele pare: 986420\n\nc) Programul C++ corespunzător:\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, c, b, x;\n    cin >> a;\n    c = 0;\n    do {\n        b = a;\n        x = 0;\n        do {\n            if (b % 10 == c) {\n                x = 1;\n            }\n            b = b / 10;\n        } while (b != 0 && x != 1);\n        cout << x << \" \";\n        c = c + 2;\n    } while (c <= 9);\n    return 0;\n}\n```\n\nd) Algoritmul echivalent, înlocuind a doua structură repetitivă:\n```\ncitește a (număr natural)\nc←0\n┌repetă\n│ b←a; x←0\n│ cât timp b≠0 și x≠1 execută\n│   ┌dacă b%10=c atunci\n│   │ x←1\n│   └■\n│   b←[b/10]\n│ \n│ scrie x,' '\n│ c←c+2\n└până când c>9\n```\n\n## Subiectul II - Exercițiul 2\n### Analiza problemei\nTrebuie să definim o structură `calculator` care să permită memorarea tipului de monitor și a capacităților memoriei interne și externe.\n\n### Abordarea soluției\nDin expresiile date, observăm că avem nevoie de:\n- Un câmp `monitor` de tip caracter\n- O structură internă `memorie` cu două câmpuri: `interna` și `externa`, ambele de tip întreg\n\n### Răspuns\n```cpp\nstruct calculator {\n    char monitor;\n    struct {\n        int interna;\n        int externa;\n    } memorie;\n} c;\n```\n\n## Subiectul II - Exercițiul 3\n### Analiza problemei\nAvem un tablou bidimensional inițializat cu caracterul '=' și trebuie să-l modificăm pentru a obține configurația dată.\n\n### Abordarea soluției\nAnalizând tabloul final, observăm că acesta conține caracterele '>' și '<'. Caracterul '>' apare în partea superioară și în partea dreaptă, iar '<' apare în partea inferioară stângă. Limita între aceste două zone pare să urmeze o diagonală.\n\n### Răspuns\n```cpp\nif(i+j<8) a[i][j]='<'; else a[i][j]='>';\n```\n\n## Subiectul III - Exercițiul 1\n### Analiza problemei\nTrebuie să implementăm un subprogram care returnează suma divizorilor comuni a două numere naturale.\n\n### Abordarea soluției\nPentru a găsi divizorii comuni ai două numere, putem:\n1. Găsi toți divizorii primului număr\n2. Pentru fiecare divizor al primului număr, verificăm dacă este și divizor al celui de-al doilea număr\n3. Adunăm toți divizorii comuni\n\n### Răspuns\n```cpp\nint suma(int a, int b) {\n    int s = 0;\n    for (int d = 1; d <= min(a, b); d++) {\n        if (a % d == 0 && b % d == 0) {\n            s += d;\n        }\n    }\n    return s;\n}\n```\n\n## Subiectul III - Exercițiul 2\n### Analiza problemei\nTrebuie să implementăm un program care rotește spre stânga fiecare cuvânt cu cel puțin trei litere dintr-un text.\n\n### Abordarea soluției\n1. Citim textul\n2. Parcurgem textul cuvânt cu cuvânt\n3. Pentru fiecare cuvânt cu cel puțin trei litere, aplicăm operația de rotire spre stânga\n4. Afișăm textul modificat sau mesajul \"nu exista\" dacă nu există cuvinte cu cel puțin trei litere\n\n### Răspuns\n```cpp\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n    char text[101], *p;\n    bool exista = false;\n    cin.getline(text, 101);\n    \n    p = strtok(text, \" \");\n    while (p != NULL) {\n        if (strlen(p) >= 3) {\n            exista = true;\n            char first = p[0];\n            for (int i = 0; i < strlen(p) - 1; i++) {\n                p[i] = p[i + 1];\n            }\n            p[strlen(p) - 1] = first;\n        }\n        cout << p << \" \";\n        p = strtok(NULL, \" \");\n    }\n    \n    if (!exista) {\n        cout << \"nu exista\";\n    }\n    \n    return 0;\n}\n```\n\n## Subiectul III - Exercițiul 3\n### Analiza problemei\nTrebuie să verificăm dacă numerele dintr-un șir pot fi rearanjate pentru a forma un șir palindromic.\n\n### Abordarea soluției\nUn șir poate fi rearanjat pentru a forma un palindrom dacă și numai dacă cel mult un număr apare de un număr impar de ori, iar toate celelalte apar de un număr par de ori.\n\na. Descrierea algoritmului:\n1. Citim numerele din fișier și numărăm frecvența fiecărui număr\n2. Verificăm câte numere apar de un număr impar de ori\n3. Dacă sunt cel mult un număr cu frecvență impară, atunci șirul poate fi rearanjat pentru a forma un palindrom\n\nEficiența algoritmului:\n- Timp: O(n), unde n este numărul de elemente din șir\n- Spațiu: O(1), deoarece avem maxim 1000 de valori posibile\n\nb. Implementarea în C++:\n\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.in\");\n    int frecventa[1001] = {0};\n    int x;\n    \n    while (fin >> x) {\n        frecventa[x]++;\n    }\n    \n    int impare = 0;\n    for (int i = 1; i <= 1000; i++) {\n        if (frecventa[i] % 2 == 1) {\n            impare++;\n        }\n    }\n    \n    if (impare <= 1) {\n        cout << \"DA\";\n    } else {\n        cout << \"NU\";\n    }\n    \n    fin.close();\n    return 0;\n}\n```"
}