{
    "gpt_model": "E_d_Informatica_2020_sp_MI_C_var_06_LRO",
    "temp": 0.0,
    "results": {
        "I": {
            "1": "### Analiza problemei Se cere calcularea valorii expresiei `3 + 5.0 / 2 + 2` în limbajul C/C++. Trebuie să ținem cont de ordinea operațiilor și de tipurile de date implicate.  ### Abordarea soluției 1. În C/C++, operatorii au o ordine de evaluare bine definită:    - Împărțirea (`/`) are prioritate mai mare decât adunarea (`+`).    - Tipul `5.0` este `double`, deci împărțirea va produce un rezultat de tip `double`. 2. Se calculează expresia pas cu pas:    - `5.0 / 2` → `2.5` (rezultat de tip `double`).    - `3 + 2.5` → `5.5`.    - `5.5 + 2` → `7.5`.  ### Răspuns Valoarea expresiei este **7.5**.",
            "2": "### Analiza problemei Se analizează funcția `f` care modifică un tablou unidimensional `v` și afișează elementele acestuia. Trebuie să determinăm setul de valori inițiale ale tabloului `v` astfel încât apelul `f(0, v)` să afișeze `2020`.  ### Abordarea soluției 1. Funcția `f` este recursivă. Dacă `i < 3`, se face apel recursiv cu `i + 1`. Dacă `i >= 3`, se modifică elementul `v[i]` prin incrementare. 2. La fiecare pas, se afișează valoarea curentă a `v[i]`. 3. Pentru ca rezultatul afișat să fie `2020`, trebuie să analizăm cum se modifică și se afișează valorile din `v`.  Pas cu pas: - `f(0, v)` → apel recursiv pentru `f(1, v)`. - `f(1, v)` → apel recursiv pentru `f(2, v)`. - `f(2, v)` → apel recursiv pentru `f(3, v)`. - `f(3, v)` → modifică `v[3]` și afișează `v[3]`. - Apoi, se afișează `v[2]`, `v[1]`, și `v[0]`.  Pentru ca rezultatul să fie `2020`, valorile inițiale ale tabloului trebuie să fie: - `v[3] = 2` (incrementat la 3, apoi afișat ca 2). - `v[2] = 0`. - `v[1] = 2`. - `v[0] = 0`.  ### Răspuns Setul de valori este **0, 2, 0, 1**.",
            "3": "### Analiza problemei Se generează soluții prin backtracking pentru împărțirea unei sume de 200 lei între patru persoane, respectând condițiile: - Fiecare plătește o sumă nenulă, divizibilă cu 10. - Sumele respectă ordinea: primul > al doilea > al treilea > al patrulea.  Se cere a șasea soluție generată.  ### Abordarea soluției 1. Se generează toate combinațiile posibile prin backtracking. 2. Se verifică condițiile:    - Suma totală este 200.    - Fiecare sumă este divizibilă cu 10.    - Ordinea este respectată. 3. Se ordonează soluțiile în ordinea generării.  Primele soluții sunt: 1. (70, 60, 40, 30) 2. (70, 60, 50, 20) 3. (80, 50, 40, 30) 4. (80, 60, 40, 20) 5. (80, 60, 50, 10) 6. (80, 70, 40, 10).  ### Răspuns A șasea soluție este **(80, 70, 40, 10)**.",
            "4": "### Analiza problemei Se analizează arborele reprezentat prin vectorul de „tați” `(7, 5, 6, 5, 7, 0, 6, 3, 3, 8)`. Se cere numărul de noduri „frunză” (noduri fără copii).  ### Abordarea soluției 1. Un nod este „frunză” dacă nu apare ca „tată” pentru niciun alt nod. 2. Se verifică fiecare nod din vectorul de „tați” pentru a determina dacă este „tată” pentru alte noduri.  Pas cu pas: - Nodurile care nu apar în vectorul de „tați” sunt: 1, 2, 4, 9, 10.  ### Răspuns Numărul de noduri „frunză” este **5**.",
            "5": "### Analiza problemei Se analizează graful neorientat reprezentat prin matricea de adiacență. Se cere numărul grafurilor parțiale conexe diferite de graful dat.  ### Abordarea soluției 1. Un graf parțial conex este un subgraf care conține toate nodurile grafului original, dar un subset al muchiilor. 2. Numărul total de subgrafuri conexe diferite poate fi calculat prin combinatorică, ținând cont de conexiuni.  ### Răspuns Numărul grafurilor parțiale conexe este **30**."
        },
        "## Subiectul II": {
            "1": "### Analiza problemei Se analizează algoritmul dat în pseudocod. Se cere: a. Valorile afișate pentru `a = 240107`. b. Cel mai mic și cel mai mare număr din intervalul `[105, 106)` cu cifre distincte. c. Programul C/C++ corespunzător. d. Algoritm echivalent în pseudocod.  ### Abordarea soluției #### a. Valorile afișate Se analizează cifrele lui `a` și se verifică condiția `b % 10 == c`.  #### b. Numerele cu cifre distincte Se generează numerele din intervalul `[105, 106)` și se verifică condiția.  #### c. Programul C++ Se implementează algoritmul dat.  #### d. Algoritm echivalent Se înlocuiește structura repetitivă.  ### Răspuns Se va detalia în secțiunea de cod."
        },
        "## Subiectul III": {
            "1": "### Analiza problemei Se cere un subprogram care returnează suma divizorilor comuni a două numere.  ### Abordarea soluției 1. Se determină divizorii fiecărui număr. 2. Se calculează intersecția divizorilor. 3. Se returnează suma divizorilor comuni.  ### Cod C++ ```cpp #include <iostream> using namespace std;  int suma(int a, int b) {     int sum = 0;     for (int i = 1; i <= min(a, b); i++) {         if (a % i == 0 && b % i == 0) {             sum += i;         }     }     return sum; }  int main() {     cout << suma(20, 12); // Exemplu     return 0; } ```",
            "2": "### Analiza problemei Se cere rotirea spre stânga a fiecărui cuvânt format din cel puțin trei litere.  ### Cod C++ ```cpp #include <iostream> #include <sstream> #include <string> using namespace std;  string rotire(string cuvant) {     if (cuvant.length() >= 3) {         return cuvant.substr(1) + cuvant[0];     }     return cuvant; }  int main() {     string text, cuvant, rezultat = \"\";     getline(cin, text);     stringstream ss(text);     bool exista = false;      while (ss >> cuvant) {         string cuv_rotit = rotire(cuvant);         rezultat += cuv_rotit + \" \";         if (cuvant.length() >= 3) exista = true;     }      if (exista) cout << rezultat;     else cout << \"nu exista\";     return 0; } ```",
            "3": "### Analiza problemei Se cere verificarea dacă un șir poate fi rearanjat pentru a forma un palindrom.  ### Cod C++ ```cpp #include <iostream> #include <fstream> #include <unordered_map> using namespace std;  bool poateFiPalindrom(unordered_map<int, int>& frecventa) {     int impar = 0;     for (auto& pereche : frecventa) {         if (pereche.second % 2 != 0) {             impar++;         }     }     return impar <= 1; }  int main() {     ifstream fin(\"bac.in\");     unordered_map<int, int> frecventa;     int numar;      while (fin >> numar) {         frecventa[numar]++;     }      if (poateFiPalindrom(frecventa)) {         cout << \"DA\";     } else {         cout << \"NU\";     }      return 0; } ```"
        }
    },
    "barem_url": "https://info-hobby.ro/wp-content/uploads/2020/06/E_d_Informatica_2020_sp_MI_bar_06.pdf",
    "exam": {
        "title": "gpt4o",
        "subject": "Informatica",
        "categories": [
            "Filiera teoretică - Profilul real"
        ]
    }
}