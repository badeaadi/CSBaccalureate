{
    "solutions_gpt4o_0.6": "## Subject I - Exercise 1\n### Problem Analysis\nTrebuie să determinăm valoarea expresiei matematice `3+5.0/2+2` în C/C++. Este important să înțelegem tipurile de date implicate și ordinea operațiilor.\n\n### Solution Approach\n1. Identificăm operațiile de bază: împărțirea și adunarea.\n2. Observăm că `5.0` este un număr în virgulă mobilă, deci împărțirea va rezulta într-un număr real.\n3. Calculăm `5.0/2`, care este `2.5`.\n4. Adunăm rezultatul la restul expresiei: `3 + 2.5 + 2`.\n\n### Answer\nValoarea expresiei este `7.5`.\n\n---\n\n## Subject I - Exercise 2\n### Problem Analysis\nSubprogramul `f` modifică un tablou și afișează elementele în funcție de condiția `i>=3`. Trebuie să identificăm ordinea elementelor astfel încât să se afișeze `2020`.\n\n### Solution Approach\n1. Analizăm comportamentul funcției `f`. Dacă `i < 3`, se apelează recursiv cu `i+1`.\n2. Dacă `i >= 3`, se incrementează `v[i]` și se afișează `v[i]`.\n3. Calculăm modificările asupra vectorului pentru fiecare caz posibil și verificăm afișarea.\n\n### Answer\nSetul de elemente este `d. 2,0,1,0`.\n\n---\n\n## Subject I - Exercise 3\n### Problem Analysis\nMetoda backtracking generează sume divizibile cu 10, respectând ordinea descrescătoare a plăților. A șasea soluție trebuie să fie identificată.\n\n### Solution Approach\n1. Generăm soluțiile posibile respectând constrângerile.\n2. Urmărim ordinea generării soluțiilor.\n3. Identificăm a șasea soluție.\n\n### Answer\nCea de a șasea soluție este `b. (80,60,50,10)`.\n\n---\n\n## Subject I - Exercise 4\n### Problem Analysis\nAvem un arbore reprezentat prin vectorul de „tați” și trebuie să determinăm numărul de noduri frunză.\n\n### Solution Approach\n1. Identificăm nodurile care nu sunt tați pentru alte noduri (adică frunze).\n2. Numărăm aceste noduri.\n\n### Answer\nNumărul de noduri frunză este `c. 5`.\n\n---\n\n## Subject I - Exercise 5\n### Problem Analysis\nTrebuie să determinăm numărul de grafuri parțiale conexe diferite de graful dat, folosind matricea de adiacență.\n\n### Solution Approach\n1. Verificăm toate combinațiile posibile de subgrafuri.\n2. Numărăm cele care sunt conexe și diferite de graful complet.\n\n### Answer\nNumărul de grafuri parțiale conexe diferite este `b. 6`.\n\n---\n\n## Subject II - Exercise 1\n### Problem Analysis\nAlgoritmul în pseudocod determină anumite valori bazate pe cifrele unui număr natural și o variabilă `c`.\n\n### Solution Approach\na. Calculăm valorile afișate pentru `240107`.\nb. Identificăm numerele din intervalul [105,106) cu cifre distincte care respectă condițiile.\nc. Convertim algoritmul în C/C++.\nd. Rescriem pseudocodul utilizând alt tip de structură repetitivă.\n\n### Answer\na. Valorile afișate sunt `0 0 1 0 0`.\nb. Cel mai mic număr este `105`, iar cel mai mare este `987`.\nc. Codul C/C++ este prezentat mai jos.\nd. Algoritmul echivalent în pseudocod este prezentat mai jos.\n\n### Code Solution\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a = 240107;\n    int c = 0;\n    do {\n        int b = a, x = 0;\n        while (b != 0 && x != 1) {\n            if (b % 10 == c) {\n                x = 1;\n            }\n            b /= 10;\n        }\n        cout << x << \" \";\n        c += 2;\n    } while (c <= 9);\n    return 0;\n}\n```\n\n### Pseudocod Echivalent\n```plaintext\nc ← 0\nrepeta\n    b ← a; x ← 0\n    while b ≠ 0 și x ≠ 1 do\n        if b % 10 = c then\n            x ← 1\n        end if\n        b ← [b / 10]\n    end while\n    scrie x, ' '\n    c ← c + 2\npana cand c > 9\n```\n\n---\n\n## Subject II - Exercise 2\n### Problem Analysis\nTrebuie să definim o structură care să memoreze informații despre un calculator: capacitatea memoriei și tipul monitorului.\n\n### Solution Approach\n1. Definim structura cu eticheta `calculator`.\n2. Adăugăm câmpurile necesare: tipul monitorului și capacitatea memoriei interne și externe.\n\n### Answer\nStructura este definită astfel.\n\n### Code Solution\n```cpp\nstruct calculator {\n    char monitor;\n    unsigned int memorie_interna;\n    unsigned int memorie_externa;\n};\n\ncalculator c;\n```\n\n---\n\n## Subject II - Exercise 3\n### Problem Analysis\nTrebuie să completăm secvența de cod pentru a genera un tablou bidimensional specificat.\n\n### Solution Approach\n1. Observăm modelul tabloului.\n2. Identificăm condițiile pentru a completa matricea cu simboluri `>` și `<`.\n\n### Answer\nCodul completat este prezentat mai jos.\n\n### Code Solution\n```cpp\nfor (i = 0; i < 9; i++) {\n    for (j = 0; j < 9; j++) {\n        if (i < 5 || i > j) {\n            a[i][j] = '>';\n        } else {\n            a[i][j] = '<';\n        }\n    }\n}\n```\n\n---\n\n## Subject III - Exercise 1\n### Problem Analysis\nSubprogramul `suma` trebuie să returneze suma divizorilor comuni a două numere naturale.\n\n### Solution Approach\n1. Calculăm divizorii comuni ai lui `a` și `b`.\n2. Adunăm acești divizori pentru a returna suma.\n\n### Answer\nDefiniția subprogramului este prezentată mai jos.\n\n### Code Solution\n```cpp\nint suma(int a, int b) {\n    int sum = 0;\n    for (int i = 1; i <= min(a, b); i++) {\n        if (a % i == 0 && b % i == 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}\n```\n\n---\n\n## Subject III - Exercise 2\n### Problem Analysis\nProgramul trebuie să rotească spre stânga cuvintele dintr-un text care au cel puțin trei litere.\n\n### Solution Approach\n1. Citim textul și îl împărțim în cuvinte.\n2. Rotim fiecare cuvânt conform cerinței.\n3. Afișăm rezultatul sau mesajul corespunzător.\n\n### Answer\nProgramul C++ este prezentat mai jos.\n\n### Code Solution\n```cpp\n#include <iostream>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nstring rotateWord(const string& word) {\n    if (word.length() < 3) return word;\n    return word.substr(1) + word[0];\n}\n\nint main() {\n    string text, word, result;\n    getline(cin, text);\n    stringstream ss(text);\n\n    bool exists = false;\n    while (ss >> word) {\n        if (word.length() >= 3) {\n            exists = true;\n            result += rotateWord(word) + \" \";\n        } else {\n            result += word + \" \";\n        }\n    }\n\n    if (exists) {\n        cout << result << endl;\n    } else {\n        cout << \"nu exista\" << endl;\n    }\n\n    return 0;\n}\n```\n\n---\n\n## Subject III - Exercise 3\n### Problem Analysis\nTrebuie să determinăm dacă un șir de numere poate fi rearanjat pentru a forma un palindrom.\n\n### Solution Approach\n1. Numărăm frecvențele fiecărui număr.\n2. Verificăm condițiile de formare a unui palindrom (cel mult un număr cu frecvență impară).\n\n### Answer\nAlgoritmul și programul corespunzător sunt prezentate mai jos.\n\n### Description\nPentru a verifica dacă un șir poate fi palindromic, numărăm aparițiile fiecărui număr. Dacă cel mult un număr are o frecvență impară, șirul poate fi rearanjat într-un palindrom. Algoritmul este eficient, deoarece folosește un singur parcurs al șirului de numere.\n\n### Code Solution\n```cpp\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.in\");\n    unordered_map<int, int> freq;\n    int num;\n\n    while (fin >> num) {\n        freq[num]++;\n    }\n\n    int oddCount = 0;\n    for (const auto& pair : freq) {\n        if (pair.second % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    if (oddCount <= 1) {\n        cout << \"DA\" << endl;\n    } else {\n        cout << \"NU\" << endl;\n    }\n\n    return 0;\n}\n```\n\n---",
    "solutions_gemini20pro_0.6": "## Subiectul I - Exercițiul 1\n\n### Problemă Analiză\nTrebuie să evaluăm o expresie aritmetică C/C++, ținând cont de ordinea operațiilor și de conversia implicită a tipurilor de date.\n\n### Soluție Abordare\n1. Împărțirea 5.0 / 2 este evaluată prima, rezultând 2.5 (deoarece 5.0 este de tip double, rezultatul este de asemenea double).\n2. Adunăm 3 + 2.5 + 2.\n3. Rezultatul final este 7.5.\n\n### Răspuns\nd. 7.5\n\n---\n\n## Subiectul I - Exercițiul 2\n\n### Problemă Analiză\nAvem un subprogram recursiv `f` care modifică un tablou unidimensional `v`. Trebuie să determinăm ce valori inițiale ale tabloului `v` vor duce la afișarea \"2020\" în urma apelului `f(0, v)`.\n\n### Soluție Abordare\n1. Urmărim execuția recursivă a funcției `f`.\n2. `f(0, v)` apelează `f(1, v)`, care apelează `f(2, v)`, care apelează `f(3, v)`.\n3. `f(3, v)`: `v[3] = v[3] + 1`.\n4. Apoi, în ordine inversă a apelurilor, se afișează `v[2]`, `v[1]`, `v[0]`.\n5. Pentru a afișa 2020, trebuie să avem `v[0] = 2`, `v[1] = 0`, `v[2] = 2`, și inițial `v[3]` trebuie sa fie `0`, ca sa devina `1` dupa incrementare in `f(3,v)`.\n6. Deci, tabloul inițial trebuie să fie (2, 0, 2, 0).\n\n### Răspuns\nd. 2,0,1,0 nu este raspunsul corect, pentru ca la final v[3] va fi 1, nu 0.\nSingurul raspuns care indeplineste conditiile este a. -1, 1, 0, 2, pentru ca:\nf(3,v) -> v[3] = 2 + 1 = 3\ncout << v[2] -> 0\ncout << v[1] -> 1\ncout << v[0] -> -1 + 3 = 2\nDar nu se afiseaza 2020.\n\nb. 0, 2, 0, 1\nf(3, v) -> v[3] = 1 + 1 = 2\ncout << v[2] = 0\ncout << v[1] = 2\ncout << v[0] = 0\nNu se afiseaza 2020\n\nc. 1, -1, 0, 1\nf(3, v) -> v[3] = 1+1 = 2\ncout << v[2] = 0\ncout << v[1] = -1 + 2 = 1\ncout << v[0] = 1+1=2\n\nd. 2, 0, 2, 0\nf(3,v) -> v[3] = 0 + 1 = 1\ncout << v[2] = 2\ncout << v[1] = 0\ncout << v[0] = 2\nDeci, tabloul initial trebuie să fie 2 0 2 0, iar dupa executia lui f(3,v), v[3] devine 1.\nf(0,v)\nf(1,v)\nf(2,v)\nf(3,v) -> v[3] devine v[3] + 1\napoi, se afiseaza in ordine inversa: v[2], v[1], v[0].\nPentru a avea 2020:\nv[2] = 2\nv[1] = 0\nv[0] = 2\nsi v[3] = 0, ca sa devina 1 dupa incrementare.\n\n### Răspuns\nd. 2,0,2,0\n\n---\n\n## Subiectul I - Exercițiul 3\n\n### Problemă Analiză\nSe generează prin backtracking sumele a patru persoane care totalizează 200 lei, respectând anumite condiții. Trebuie să găsim a șasea soluție generată.\n\n### Soluție Abordare\n1. Condițiile sunt: fiecare sumă este nenulă și divizibilă cu 10; sumele sunt în ordine descrescătoare.\n2. Listăm soluțiile generate, începând cu cele date:\n    1. (70, 60, 40, 30)\n    2. (70, 60, 50, 20)\n    3. (80, 50, 40, 30)\n    4. (80, 60, 40, 20)\n    5. (80, 60, 50, 10)\n    6. (90, 40, 30, 40) - Nu e bun, a[2] <= a[3]\n    7. (90, 50, 30, 30)\n    8. (90, 50, 40, 20)\n    9. (90, 60, 30, 20)\n    10. (90, 60, 40, 10)\n    11. (100, 40, 30, 30)\n\n3. Continuam generarea, tinand cont de ordinea lexicografica:\n    (80, 60, 50, 10)\n\n### Răspuns\nb. (80, 60, 50, 10)\n\n---\n\n## Subiectul I - Exercițiul 4\n\n### Problemă Analiză\nAvem un arbore cu 10 noduri reprezentat printr-un vector de tați. Trebuie să determinăm numărul de noduri frunză.\n\n### Soluție Abordare\n1. Un nod frunză este un nod care nu are copii.\n2. În vectorul de tați, un nod este frunză dacă nu apare ca tată al niciunui alt nod.\n3. Parcurgem vectorul de tați și numărăm câte noduri nu apar în vector.\n4. Vectorul de tati: (7,5,6,5,7,0,6,3,3,8)\n5. Nodurile sunt numerotate de la 1 la 10.\n6. Tatal radacinii este 0.\n7. Verificam care noduri nu apar in vectorul de tati: 1, 2, 4, 9, 10.\n8.  1, 2, 4, 9, 10 - 5 noduri frunza\n\n### Răspuns\nc. 5\n\n---\n\n## Subiectul I - Exercițiul 5\n\n### Problemă Analiză\nAvem un graf neorientat reprezentat prin matricea de adiacență. Trebuie să găsim numărul de grafuri parțiale conexe diferite de graful dat.\n\n### Soluție Abordare\n1. Un graf parțial se obține eliminând una sau mai multe muchii din graful original.\n2. Graful trebuie să rămână conex.\n3. Graful dat are muchiile: (1,2), (1,4), (1,5), (2,3), (3,4).\n4. Numaram muchiile: 5 muchii.\n5.  Putem elimina:\n    - 0 muchii: 1 graf (graful initial)\n    - 1 muchie: 5 grafuri\n    - 2 muchii: Trebuie sa vedem cate combinatii de 2 muchii putem elimina, fara a deconecta graful.\n(1,2) si (1,4) - merge\n(1,2) si (1,5) - merge\n(1,2) si (2,3) - nu merge\n(1,2) si (3,4) - merge\n\n6. Graful are 5 muchii. Un graf partial conex are cel putin n-1 muchii, unde n este numarul de noduri. Aici, n=5, deci cel putin 4 muchii. Graful dat are 5 muchii. Deci putem elimina maxim o muchie.\n7. Graful dat este conex.\n8.  Daca eliminam o muchie, graful ramane conex.\n9.  Numarul de grafuri partiale conexe diferite de graful dat este egal cu numarul de muchii pe care le putem elimina (una cate una) astfel incat graful sa ramana conex.\n10. Putem elimina oricare din cele 5 muchii.\n\n### Răspuns\na. 4 - gresit, sunt 5 muchii.\nb. 6\nc. 8\nd. 30\n\nRaspunsul corect este 5, dar nu este printre optiuni. Cea mai apropiata optiune este a.4.\n\n### Răspuns\na. 4\n\n---\n\n## Subiectul al II-lea - Exercițiul 1\n\n### Problemă Analiză\nAvem un algoritm în pseudocod care prelucrează un număr natural `a`. Trebuie să analizăm algoritmul, să răspundem la subpunctele a, b, c și d.\n\n### Soluție Abordare\n\n**a.**\n1. Urmărim execuția algoritmului pentru a = 240107.\n2. c = 0:  b = 240107; x = 0; b%10 = 7 != 0; ... b = 0; x = 0;  Scrie 0\n3. c = 2:  b = 240107; x = 0; b%10 = 7 != 2; ... b = 0; x = 0; Scrie 0\n4. c = 4:  b = 240107; x = 0; b%10 = 7 != 4; ... b = 0; x = 0; Scrie 0\n5. c = 6:  b = 240107; x = 0; b%10 = 7 != 6; ... b = 0; x = 0; Scrie 0\n6. c = 8:  b = 240107; x = 0; b%10 = 7 != 8; ... b = 0; x = 0; Scrie 0\n\n**b.**\nCel mai mic: 102345.\nCel mai mare: 987654.\nPentru ca toate valorile afisate sa fie nenule, trebuie ca pentru fiecare c (0, 2, 4, 6, 8) sa existe cel putin o cifra in numar egala cu c.\nCel mai mic numar: 102468\nCel mai mare numar: 986420\n\n**c.**\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n  int a, b, c, x;\n  cin >> a;\n  c = 0;\n  do {\n    b = a;\n    x = 0;\n    do {\n      if (b % 10 == c) {\n        x = 1;\n      }\n      b = b / 10;\n    } while (b != 0 && x != 1);\n    cout << x << \" \";\n    c = c + 2;\n  } while (c <= 9);\n  return 0;\n}\n```\n\n**d.**\n\n```\ncitește a (număr natural)\nc←0\n┌repetă\n│ b←a; x←0\n│┌cât timp b≠0 și x=0 execută\n││┌dacă b%10=c atunci\n│││ x←1\n││└■\n││ b←[b/10]\n│└■\n│ scrie x,’ ’\n│ c←c+2\n└până când c>9\n```\n\n### Răspuns\na. 0 0 0 0 0\nb. Cel mai mic: 102468; Cel mai mare: 986420\nc. Codul C++ de mai sus.\nd. Algoritmul pseudocod modificat de mai sus.\n\n---\n\n## Subiectul al II-lea - Exercițiul 2\n\n### Problemă Analiză\nTrebuie să definim o structură `calculator` care să memoreze date despre un calculator (capacitatea memoriei interne, externe și tipul monitorului).\n\n### Soluție Abordare\n1. Definim o structură cu membrii: `monitor` (char), `memorie` (o sub-structură cu `interna` și `externa`, ambele int).\n\n### Răspuns\n\n```cpp\nstruct memorie {\n    int interna;\n    int externa;\n};\n\nstruct calculator {\n    char monitor;\n    memorie memorie;\n};\n\ncalculator c;\n```\n\n---\n\n## Subiectul al II-lea - Exercițiul 3\n\n### Problemă Analiză\nAvem un tablou bidimensional 9x9 inițializat cu '='. Trebuie să modificăm secvența de cod pentru a obține un tablou specific.\n\n### Soluție Abordare\n1. Observăm că tabloul are '>' deasupra diagonalei secundare, '<' sub diagonala secundară și pe diagonala secundară, și '=' în rest.\n2. Condiția pentru diagonala secundară este i + j = 8.\n3. Condiția pentru elementele de deasupra diagonalei secundare este i + j < 8.\n4. Condiția pentru elementele de sub diagonala secundară este i + j > 8.\n\n### Răspuns\n\n```cpp\nfor(i=0;i<9;i++)\n for(j=0;j<9;j++)\n    if (i + j < 8) {\n        a[i][j] = '>';\n    } else if (i + j > 8) {\n        a[i][j] = '<';\n    } else {\n      a[i][j] = '<';\n    }\n```\n\n---\n\n## Subiectul al III-lea - Exercițiul 1\n\n### Problemă Analiză\nTrebuie să scriem definiția completă a subprogramului `suma` care primește doi parametri `a` și `b` și returnează suma divizorilor comuni ai lui `a` și `b`.\n\n### Soluție Abordare\n1. Parcurgem toți divizorii posibili de la 1 la minimul dintre a și b.\n2. Verificăm dacă fiecare divizor este comun lui a și b.\n3. Dacă este comun, îl adăugăm la sumă.\n\n### Răspuns\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint suma(int a, int b) {\n  int s = 0;\n  int min_val = (a < b) ? a : b;\n  for (int i = 1; i <= min_val; i++) {\n    if (a % i == 0 && b % i == 0) {\n      s = s + i;\n    }\n  }\n  return s;\n}\n```\n\n---\n\n## Subiectul al III-lea - Exercițiul 2\n\n### Problemă Analiză\nTrebuie să scriem un program C++ care citește un text, rotește spre stânga cuvintele de cel puțin trei litere și afișează textul modificat.\n\n### Soluție Abordare\n1. Citim textul.\n2. Parcurgem textul cuvânt cu cuvânt.\n3. Pentru fiecare cuvânt, verificăm lungimea.\n4. Dacă lungimea este >= 3, rotim cuvântul spre stânga.\n5. Afișăm textul modificat sau mesajul \"nu exista\".\n\n### Răspuns\n\n```cpp\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nvoid roteste(char s[]) {\n  if (strlen(s) >= 3) {\n    char primaLitera = s[0];\n    for (int i = 0; i < strlen(s) - 1; i++) {\n      s[i] = s[i + 1];\n    }\n    s[strlen(s) - 1] = primaLitera;\n  }\n}\n\nint main() {\n  char text[101];\n  char *cuvant;\n  bool existaCuvinte = false;\n\n  cin.getline(text, 101);\n\n  cuvant = strtok(text, \" \");\n  while (cuvant != NULL) {\n    if (strlen(cuvant) >= 3) {\n      existaCuvinte = true;\n      roteste(cuvant);\n    }\n    cout << cuvant << \" \";\n    cuvant = strtok(NULL, \" \");\n  }\n\n  if (!existaCuvinte) {\n    cout << \"nu exista\";\n  }\n  cout << endl;\n\n  return 0;\n}\n```\n\n---\n\n## Subiectul al III-lea - Exercițiul 3\n\n### Problemă Analiză\nTrebuie să verificăm dacă un șir de numere din fișierul `bac.in` poate fi rearanjat pentru a forma un palindrom.\n\n### Soluție Abordare\n1. Un șir poate fi rearanjat ca palindrom dacă cel mult un număr apare de un număr impar de ori.\n2. Folosim un vector de frecvență pentru a număra aparițiile fiecărui număr.\n3. Parcurgem vectorul de frecvență și numărăm câte elemente au frecvență impară.\n4. Dacă numărul de elemente cu frecvență impară este <= 1, afișăm \"DA\", altfel afișăm \"NU\".\n\n**a.** Algoritmul este eficient ca timp de executare deoarece parcurge șirul o singură dată pentru a construi vectorul de frecvență (complexitate O(n), unde n este numărul de elemente din șir) și apoi parcurge vectorul de frecvență o singură dată (complexitate O(m), unde m este numărul de elemente distincte, care este cel mult 1000 in cazul nostru). Complexitatea totala este O(n+m) = O(n) pentru ca m este constant.  Nu se folosește sortare, care ar fi avut complexitate O(n log n).\n\n**b.**\n\n```cpp\n#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint main() {\n  ifstream fin(\"bac.in\");\n  int frecventa[1001] = {0}; // Initializam toate frecventele cu 0\n  int x;\n  int nrImpare = 0;\n\n  while (fin >> x) {\n    frecventa[x]++;\n  }\n\n  for (int i = 1; i <= 1000; i++) {\n    if (frecventa[i] % 2 != 0) {\n      nrImpare++;\n    }\n  }\n\n  if (nrImpare <= 1) {\n    cout << \"DA\";\n  } else {\n    cout << \"NU\";\n  }\n\n  fin.close();\n  return 0;\n}\n```\n",
    "solutions_anthropicclaude37sonnet_0.6": "# Soluții pentru Exerciții de Informatică\n\n## Subiectul I - Exercițiul 1\n### Analiza problemei\nTrebuie să evaluăm expresia C/C++ `3+5.0/2+2` respectând ordinea operațiilor.\n\n### Abordarea soluției\nÎn C/C++, operațiile se execută conform priorității: mai întâi împărțirea, apoi adunarea de la stânga la dreapta.\n- 5.0/2 = 2.5 (împărțire în virgulă mobilă deoarece 5.0 este float)\n- 3+2.5+2 = 7.5\n\n### Răspuns\nRăspunsul corect este d. 7.5\n\n## Subiectul I - Exercițiul 2\n### Analiza problemei\nAvem un subprogram recursiv care modifică un tablou și afișează valorile elementelor. Trebuie să determinăm ce valori inițiale trebuie să aibă tabloul pentru a afișa 2020.\n\n### Abordarea soluției\nSă analizăm funcția `f`:\n- Dacă i>=3, incrementează v[i] și afișează v[i]\n- Altfel, apelează recursiv f(i+1,v) și apoi afișează v[i]\n\nLa apelul f(0,v), execuția va fi:\n1. i=0<3, deci apelează f(1,v)\n2. i=1<3, deci apelează f(2,v)\n3. i=2<3, deci apelează f(3,v)\n4. i=3>=3, deci v[3]=v[3]+1, apoi afișează v[3]\n5. Revine la i=2, afișează v[2]\n6. Revine la i=1, afișează v[1]\n7. Revine la i=0, afișează v[0]\n\nDeci afișarea va fi în ordinea: v[3], v[2], v[1], v[0], iar aceste valori trebuie să fie 2, 0, 2, 0.\n\n### Răspuns\nPentru ca afișarea să fie 2020, tabloul inițial trebuie să fie: v[0]=0, v[1]=2, v[2]=0, v[3]=1 (pentru că v[3] va fi incrementat).\nRăspunsul corect este b. 0,2,0,1\n\n## Subiectul I - Exercițiul 3\n### Analiza problemei\nSe generează prin backtracking toate modalitățile în care 4 persoane pot plăti 200 lei, cu condiția ca fiecare sumă să fie divizibilă cu 10 și sumele să fie în ordine strict descrescătoare.\n\n### Abordarea soluției\nAvem primele patru soluții generate:\n1. (70, 60, 40, 30)\n2. (70, 60, 50, 20)\n3. (80, 50, 40, 30)\n4. (80, 60, 40, 20)\n\nPentru a determina a șasea soluție, trebuie să găsim mai întâi a cincea și apoi a șasea, respectând regulile de generare.\n\nA cincea soluție: După (80, 60, 40, 20) ar trebui să urmeze (80, 60, 50, 10)\nA șasea soluție: După (80, 60, 50, 10) ar trebui să urmeze (80, 70, 30, 20)\n\n### Răspuns\nRăspunsul corect este c. (80,70,30,20)\n\n## Subiectul I - Exercițiul 4\n### Analiza problemei\nAvem un arbore reprezentat prin vectorul de tați și trebuie să determinăm numărul de noduri frunză.\n\n### Abordarea soluției\nVectorul de tați este (7,5,6,5,7,0,6,3,3,8). Un nod este frunză dacă nu este tatăl niciunui alt nod.\nPentru a găsi frunzele, vom marca nodurile care sunt tați și apoi vom număra câte noduri nu sunt marcate.\n\nNodurile care sunt tați: 0, 3, 5, 6, 7, 8\nNodurile care nu sunt tați (frunze): 1, 2, 4, 9, 10\n\n### Răspuns\nArborele are 5 noduri frunză.\nRăspunsul corect este c. 5\n\n## Subiectul I - Exercițiul 5\n### Analiza problemei\nAvem un graf neorientat reprezentat prin matricea de adiacență și trebuie să determinăm numărul de grafuri parțiale conexe diferite de graful dat.\n\n### Abordarea soluției\nUn graf parțial se obține eliminând muchii din graful original, păstrând toate nodurile. Pentru ca graful parțial să fie conex, trebuie să existe un drum între oricare două noduri.\n\nGraful dat are 6 muchii: (1,2), (1,4), (1,5), (2,3), (3,4), (4,5). Pentru ca un graf parțial să fie conex, trebuie să aibă cel puțin 4 muchii (numărul minim de muchii pentru un graf conex cu 5 noduri).\n\nNumărul total de grafuri parțiale este 2^6 = 64, dar trebuie să excludem:\n- Graful original\n- Grafurile neconexe\n- Grafurile cu mai puțin de 4 muchii\n\nDupă analiză, rezultă că există 8 grafuri parțiale conexe diferite de graful dat.\n\n### Răspuns\nRăspunsul corect este c. 8\n\n## Subiectul II - Exercițiul 1\n### Analiza problemei\nTrebuie să analizăm un algoritm în pseudocod care verifică prezența anumitor cifre într-un număr.\n\n### Abordarea soluției\nAlgoritmul verifică pentru fiecare valoare a lui c (0, 2, 4, 6, 8) dacă cifra respectivă apare în numărul a. Afișează 1 dacă cifra apare și 0 dacă nu.\n\na) Pentru a=240107:\n- c=0: verifică dacă cifra 0 apare în 240107 -> apare -> afișează 1\n- c=2: verifică dacă cifra 2 apare în 240107 -> apare -> afișează 1\n- c=4: verifică dacă cifra 4 apare în 240107 -> apare -> afișează 1\n- c=6: verifică dacă cifra 6 apare în 240107 -> nu apare -> afișează 0\n- c=8: verifică dacă cifra 8 apare în 240107 -> nu apare -> afișează 0\n\nb) Pentru ca toate valorile afișate să fie nenule, numărul trebuie să conțină cifrele 0, 2, 4, 6 și 8.\nCel mai mic număr din [10^5, 10^6) cu aceste cifre: 102468\nCel mai mare număr din [10^5, 10^6) cu aceste cifre: 986420\n\nc) Programul C++ corespunzător:\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, c, b, x;\n    cin >> a;\n    c = 0;\n    do {\n        b = a; \n        x = 0;\n        do {\n            if (b % 10 == c)\n                x = 1;\n            b = b / 10;\n        } while (b != 0 && x != 1);\n        cout << x << \" \";\n        c = c + 2;\n    } while (c <= 9);\n    return 0;\n}\n```\n\nd) Algoritmul echivalent, înlocuind a doua structură repetă...până când cu o structură while:\n```\ncitește a (număr natural)\nc←0\n┌repetă\n│ b←a; x←0\n│ cat timp b≠0 și x≠1 execută\n│ │┌dacă b%10=c atunci\n│ ││ x←1\n│ │└■\n│ │ b←[b/10]\n│ │\n│ scrie x,' '\n│ c←c+2\n└până când c>9\n```\n\n### Răspuns\na) Valorile afișate pentru 240107 sunt: 1 1 1 0 0\nb) Cel mai mic număr: 102468, cel mai mare număr: 986420\nc) Programul C++ este prezentat mai sus\nd) Algoritmul echivalent este prezentat mai sus\n\n## Subiectul II - Exercițiul 2\n### Analiza problemei\nTrebuie să definim o structură pentru un calculator care să conțină informații despre monitor și memorie.\n\n### Abordarea soluției\nDin cerință, avem nevoie de:\n- O literă pentru tipul monitorului\n- Două numere naturale pentru capacitatea memoriei interne și externe\n\n### Răspuns\n```cpp\nstruct memorie {\n    int interna;\n    int externa;\n};\n\nstruct calculator {\n    char monitor;\n    struct memorie memorie;\n};\n\ncalculator c;\n```\n\n## Subiectul II - Exercițiul 3\n### Analiza problemei\nTrebuie să completăm o secvență de cod pentru a obține un tablou bidimensional cu un anumit model.\n\n### Abordarea soluției\nAnalizând tabloul rezultat, observăm un model de caractere '>' și '<'. Caracterul '<' apare doar când i+j >= 13.\n\n### Răspuns\nSecvența completată:\n```cpp\nfor(i=0;i<9;i++)\n    for(j=0;j<9;j++)\n        if(i+j >= 13) a[i][j]='<';\n        else a[i][j]='>';\n```\n\n## Subiectul III - Exercițiul 1\n### Analiza problemei\nTrebuie să implementăm un subprogram care calculează suma divizorilor comuni a două numere naturale.\n\n### Abordarea soluției\nVom găsi toți divizorii primului număr și vom verifica dacă sunt și divizori ai celui de-al doilea număr.\n\n### Răspuns\n```cpp\nint suma(int a, int b) {\n    int s = 0;\n    for(int d = 1; d <= a; d++) {\n        if(a % d == 0 && b % d == 0) {\n            s += d;\n        }\n    }\n    return s;\n}\n```\n\n## Subiectul III - Exercițiul 2\n### Analiza problemei\nTrebuie să implementăm un program care rotește spre stânga fiecare cuvânt cu cel puțin 3 litere dintr-un text.\n\n### Abordarea soluției\nVom parcurge textul cuvânt cu cuvânt, și pentru fiecare cuvânt cu cel puțin 3 litere, vom efectua operația de rotire.\n\n### Răspuns\n```cpp\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n    char text[101], *p, rezultat[101] = \"\", cuvant[101];\n    bool exista = false;\n    \n    cin.getline(text, 101);\n    \n    p = strtok(text, \" \");\n    while(p != NULL) {\n        if(strlen(p) >= 3) {\n            exista = true;\n            char prima = p[0];\n            for(int i = 0; i < strlen(p) - 1; i++)\n                p[i] = p[i + 1];\n            p[strlen(p) - 1] = prima;\n        }\n        \n        strcat(rezultat, p);\n        strcat(rezultat, \" \");\n        \n        p = strtok(NULL, \" \");\n    }\n    \n    if(exista)\n        cout << rezultat;\n    else\n        cout << \"nu exista\";\n    \n    return 0;\n}\n```\n\n## Subiectul III - Exercițiul 3\n### Analiza problemei\nTrebuie să verificăm dacă un șir de numere poate fi rearanjat pentru a forma un șir palindromic.\n\n### Abordarea soluției\nUn șir poate fi rearanjat pentru a forma un palindrom dacă și numai dacă cel mult un număr apare de un număr impar de ori, iar toate celelalte apar de un număr par de ori.\n\na) Descrierea algoritmului:\n1. Citim numerele din fișier și numărăm frecvența fiecărui număr.\n2. Verificăm câte numere apar de un număr impar de ori.\n3. Dacă există cel mult un număr cu frecvență impară, atunci șirul poate fi rearanjat pentru a forma un palindrom.\n\nb) Implementarea în C++:\n\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.in\");\n    int frecventa[1001] = {0};\n    int x;\n    \n    // Citim numerele și numărăm frecvențele\n    while(fin >> x) {\n        frecventa[x]++;\n    }\n    \n    // Numărăm câte numere apar de un număr impar de ori\n    int impare = 0;\n    for(int i = 1; i <= 1000; i++) {\n        if(frecventa[i] % 2 == 1) {\n            impare++;\n        }\n    }\n    \n    // Verificăm condiția pentru palindrom\n    if(impare <= 1) {\n        cout << \"DA\";\n    } else {\n        cout << \"NU\";\n    }\n    \n    fin.close();\n    return 0;\n}\n```\n\n### Răspuns\na) Algoritmul este eficient deoarece:\n- Complexitatea temporală este O(n), unde n este numărul de elemente din șir\n- Complexitatea spațială este O(1), deoarece folosim un vector de frecvență de dimensiune fixă (1000)\n\nb) Programul C++ este prezentat mai sus"
}