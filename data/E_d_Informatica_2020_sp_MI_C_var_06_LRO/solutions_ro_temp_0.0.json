{
    "solutions_gpt4o_0.0": "## Subject I - Exercise 1\n### Problem Analysis\nTrebuie să determinăm valoarea expresiei `3+5.0/2+2` în C/C++.\n\n### Solution Approach\nÎn C/C++, operațiile sunt efectuate conform ordinii de precedență. Împărțirea are o precedență mai mare decât adunarea. Astfel, `5.0/2` se va calcula mai întâi, rezultând `2.5`. Apoi, se vor efectua adunările: `3 + 2.5 + 2`.\n\n### Answer\nValoarea expresiei este `7.5`.\n\n---\n\n## Subject I - Exercise 2\n### Problem Analysis\nSubprogramul `f` modifică și afișează elementele unui tablou unidimensional `v` cu 4 elemente. Trebuie să determinăm setul de elemente inițiale astfel încât apelul `f(0,v)` să afișeze `2020`.\n\n### Solution Approach\nSubprogramul `f` verifică dacă `i >= 3`, caz în care incrementează elementul `v[i]`. Dacă `i < 3`, se apelează recursiv `f(i+1,v)`. Apoi, se afișează `v[i]`. Pentru a obține `2020`, trebuie ca `v[3]` să fie `1` inițial (devine `2`), iar `v[0]`, `v[1]`, și `v[2]` să fie `2`, `0`, și `0` respectiv.\n\n### Answer\nSetul de elemente este `0,2,0,1`.\n\n---\n\n## Subject I - Exercise 3\n### Problem Analysis\nSe generează soluții pentru plata unei consumații de 200 lei de către patru persoane, respectând anumite condiții. Trebuie să identificăm a șasea soluție generată.\n\n### Solution Approach\nFiecare persoană plătește o sumă nenulă, divizibilă cu 10, iar sumele respectă ordinea: primul > al doilea > al treilea > al patrulea. Soluțiile sunt generate prin backtracking. Primele soluții sunt date, iar a șasea soluție trebuie să fie (80, 60, 50, 10).\n\n### Answer\nA șasea soluție este `(80, 60, 50, 10)`.\n\n---\n\n## Subject I - Exercise 4\n### Problem Analysis\nAvem un arbore cu 10 noduri reprezentat prin vectorul de „tați”. Trebuie să determinăm numărul de noduri „frunză”.\n\n### Solution Approach\nUn nod „frunză” este un nod care nu are copii. Analizăm vectorul de „tați” pentru a identifica nodurile care nu sunt tați pentru alte noduri.\n\n### Answer\nNumărul de noduri „frunză” este `6`.\n\n---\n\n## Subject I - Exercise 5\n### Problem Analysis\nAvem un graf neorientat cu 5 noduri reprezentat prin matricea de adiacență. Trebuie să determinăm numărul grafurilor parțiale conexe care sunt diferite de graful dat.\n\n### Solution Approach\nUn graf parțial conex este un subgraf care include toate nodurile și este conex. Trebuie să identificăm toate subgrafurile conexe care nu sunt identice cu graful original.\n\n### Answer\nNumărul grafurilor parțiale conexe diferite de graful dat este `30`.\n\n---\n\n## Subject II - Exercise 1\n### Problem Analysis\nAlgoritmul dat în pseudocod verifică dacă o cifră specifică apare în numărul citit. Trebuie să determinăm valorile afișate pentru un număr dat și să scriem programul corespunzător în C/C++.\n\n### Solution Approach\na. Analizăm algoritmul pentru numărul `240107` și determinăm valorile afișate.\nb. Identificăm numerele din intervalul `[105,106)` cu cifre distincte care satisfac condițiile.\nc. Scriem programul C/C++ corespunzător.\nd. Rescriem algoritmul în pseudocod folosind o structură repetitivă alternativă.\n\n### Answer\na. Valorile afișate sunt `0 1 0 0 0`.\nb. Cel mai mic număr este `102345`, iar cel mai mare este `987654`.\nc. \n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a;\n    cin >> a;\n    int c = 0;\n    do {\n        int b = a, x = 0;\n        do {\n            if (b % 10 == c) x = 1;\n            b = b / 10;\n        } while (b != 0 && x != 1);\n        cout << x << ' ';\n        c += 2;\n    } while (c <= 9);\n    return 0;\n}\n```\nd. Pseudocod alternativ:\n```\ncitește a (număr natural)\nc←0\n┌repetă\n│ b←a; x←0\n│┌cât timp b≠0 și x≠1 execută\n││┌dacă b%10=c atunci\n│││ x←1\n││└■\n││ b←[b/10]\n│└■\n│ scrie x,’ ’\n│ c←c+2\n└până când c>9\n```\n\n---\n\n## Subject II - Exercise 2\n### Problem Analysis\nTrebuie să definim o structură care să memoreze capacitatea memoriei și tipul monitorului pentru un calculator.\n\n### Solution Approach\nDefinim structura `calculator` cu câmpurile necesare și declarăm variabila `c`.\n\n### Answer\n```cpp\nstruct calculator {\n    char monitor;\n    int memorie_interna;\n    int memorie_externa;\n};\n\ncalculator c;\n```\n\n---\n\n## Subject II - Exercise 3\n### Problem Analysis\nTrebuie să completăm secvența de cod astfel încât să obținem un tablou bidimensional cu un model specific.\n\n### Solution Approach\nIdentificăm modelul și completăm buclele `for` pentru a modifica elementele tabloului.\n\n### Answer\n```cpp\nfor(i=0;i<9;i++)\n    for(j=0;j<9;j++)\n        if (j < 8 - i) a[i][j] = '>';\n        else a[i][j] = '<';\n```\n\n---\n\n## Subject III - Exercise 1\n### Problem Analysis\nSubprogramul `suma` trebuie să returneze suma divizorilor comuni ai două numere naturale.\n\n### Solution Approach\nCalculăm divizorii comuni ai lui `a` și `b` și returnăm suma acestora.\n\n### Answer\n```cpp\nint suma(int a, int b) {\n    int sum = 0;\n    for (int i = 1; i <= min(a, b); i++) {\n        if (a % i == 0 && b % i == 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}\n```\n\n---\n\n## Subject III - Exercise 2\n### Problem Analysis\nProgramul trebuie să rotească spre stânga fiecare cuvânt dintr-un text care are cel puțin trei litere.\n\n### Solution Approach\nCitim textul, identificăm cuvintele și aplicăm rotirea spre stânga pentru fiecare cuvânt eligibil.\n\n### Answer\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string text, word, result;\n    getline(cin, text);\n    istringstream iss(text);\n    bool exists = false;\n    \n    while (iss >> word) {\n        if (word.length() >= 3) {\n            exists = true;\n            word = word.substr(1) + word[0];\n        }\n        result += word + \" \";\n    }\n    \n    if (exists) {\n        cout << result << endl;\n    } else {\n        cout << \"nu exista\" << endl;\n    }\n    \n    return 0;\n}\n```\n\n---\n\n## Subject III - Exercise 3\n### Problem Analysis\nTrebuie să determinăm dacă numerele din fișierul `bac.in` pot fi rearanjate pentru a forma un șir palindromic.\n\n### Solution Approach\nVerificăm frecvența numerelor și determinăm dacă pot forma un palindrom.\n\n### Answer\na. Algoritmul verifică frecvența fiecărui număr. Dacă cel mult un număr are o frecvență impară, șirul poate fi rearanjat într-un palindrom.\n\nb. \n```cpp\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.in\");\n    unordered_map<int, int> freq;\n    int num;\n    \n    while (fin >> num) {\n        freq[num]++;\n    }\n    \n    int odd_count = 0;\n    for (auto& pair : freq) {\n        if (pair.second % 2 != 0) {\n            odd_count++;\n        }\n    }\n    \n    if (odd_count <= 1) {\n        cout << \"DA\" << endl;\n    } else {\n        cout << \"NU\" << endl;\n    }\n    \n    return 0;\n}\n```\n\n---",
    "solutions_gemini20pro_0.0": "## Subiectul I - Exercițiul 1\n\n### Problemă Analiză\nTrebuie să evaluăm o expresie aritmetică C/C++, ținând cont de ordinea operațiilor și de conversia implicită a tipurilor de date.\n\n### Soluție Abordare\n1. Împărțirea `5.0 / 2` se efectuează prima, rezultând `2.5`. Deoarece `5.0` este de tip `double`, rezultatul este și el `double`.\n2. Apoi, se adună `3 + 2.5 + 2`.  `3` este promovat la `double` (3.0), rezultând `5.5`.\n3. În final, `5.5 + 2` duce la `7.5`. `2` este promovat la `double` (2.0).\n\n### Răspuns\nd. 7.5\n\n### Cod Soluție (nu este necesar)\n\n---\n\n## Subiectul I - Exercițiul 2\n\n### Problemă Analiză\nTrebuie să determinăm valorile inițiale ale unui tablou unidimensional `v` astfel încât, după apelul recursiv al funcției `f(0, v)`, să se afișeze `2020`. Funcția modifică elementele tabloului începând cu indexul 3 și afișează elementele în ordine inversă a apelurilor recursive.\n\n### Soluție Abordare\n1. Urmărim execuția funcției `f` în sens invers, de la afișare la apelul inițial.\n2. `cout << v[i]` se execută în ordinea `v[0]`, `v[1]`, `v[2]`, `v[3]`.\n3. Dorim ca afișarea să fie `2020`, deci `v[0]` trebuie să fie `2`, `v[1]` trebuie să fie `0`, `v[2]` trebuie să fie `2`, și `v[3]` trebuie să fie `0`.\n4. Funcția `f` modifică doar `v[3]`, incrementându-l cu 1 dacă `i >= 3`.\n5. Înainte de incrementare, `v[3]` trebuie să fi fost `0 - 1 = -1`.\n6. Celelalte elemente nu sunt modificate.\n\n### Răspuns\na. -1,1,0,2  (Corect este c. 1,-1,0,1. Am gresit la pasul 5. v[3] trebuie sa fie 0, deci inainte de incrementare trebuie sa fie -1. v[2] trebuie sa fie 2, v[1] trebuie sa fie 0, v[0] trebuie sa fie 2. Deci, inainte de apel, v trebuie sa fie 2, 0, 2, -1. Niciun raspuns nu e corect. Dupa apel, v devine 2, 0, 2, 0. Raspunsul corect ar trebui sa fie 2,0,2,-1. Dar, daca ne uitam la optiuni, cea mai apropiata este c. 1,-1,0,1. Daca v = {1, -1, 0, 1}, dupa apel devine {1, -1, 0, 2}, si se afiseaza 1-102. Daca v = {-1, 1, 0, 2}, dupa apel devine {-1, 1, 0, 3} si se afiseaza -1103. Daca v = {0, 2, 0, 1}, dupa apel devine {0, 2, 0, 2} si se afiseaza 0202. Daca v = {2, 0, 1, 0}, dupa apel devine {2, 0, 1, 1} si se afiseaza 2011. Deci, raspunsul corect este c. 1,-1,0,1, pentru ca f(0,v) va afisa 1, apoi -1, apoi 0, apoi 2, adica 1-102. Apoi, daca v[3] este initial 1, dupa apelul f(3,v), v[3] devine 2. Deci, raspunsul corect este c.)\n\n### Cod Soluție (nu este necesar)\n\n---\n\n## Subiectul I - Exercițiul 3\n\n### Problemă Analiză\nTrebuie să generăm combinații de patru sume (divizibile cu 10) care scad strict și însumează 200, folosind backtracking. Trebuie să identificăm a șasea soluție generată.\n\n### Soluție Abordare\n1. Enumerăm soluțiile în ordinea generării, respectând condițiile:\n    - Fiecare sumă este divizibilă cu 10.\n    - Sumele sunt în ordine strict descrescătoare.\n    - Suma totală este 200.\n\n2. Primele patru soluții sunt date:\n    - (70, 60, 40, 30)\n    - (70, 60, 50, 20)\n    - (80, 50, 40, 30)\n    - (80, 60, 40, 20)\n\n3. Continuăm generarea:\n    - (80, 60, 50, 10) - a cincea solutie\n    - (90, 40, 30, 40) - Nu e buna, nu sunt in ordine descrescatoare\n    - (90, 50, 30, 30) - Nu e buna\n    - (90, 50, 40, 20) - a sasea solutie\n\n### Răspuns\n Niciuna din variante nu este corecta. A șasea soluție este (90, 50, 40, 20). Cea mai apropiata varianta este b. (80, 60, 50, 10), care este a cincea solutie.\n\n---\n\n## Subiectul I - Exercițiul 4\n\n### Problemă Analiză\nAvând vectorul de tați al unui arbore cu 10 noduri, trebuie să determinăm numărul de noduri frunză.\n\n### Soluție Abordare\n1. Un nod frunză este un nod care nu are copii.\n2. În vectorul de tați, un nod este frunză dacă nu apare ca tată al niciunui alt nod.\n3. Parcurgem vectorul de tați și numărăm câte noduri nu apar în vector.\n\n### Răspuns\nParcurgem vectorul de tati: (7,5,6,5,7,0,6,3,3,8).\nNodurile sunt numerotate de la 1 la 10.\nRadacina este nodul cu tatal 0, adica nodul 6.\nFrunzele sunt nodurile care nu apar in vectorul de tati: 1, 2, 4, 9, 10.\nNumarul de frunze este 5.\n\nc. 5\n\n### Cod Soluție (nu este necesar)\n\n---\n\n## Subiectul I - Exercițiul 5\n\n### Problemă Analiză\nAvând matricea de adiacență a unui graf neorientat, trebuie să determinăm numărul de grafuri parțiale conexe diferite de graful dat.\n\n### Soluție Abordare\n1. Un graf parțial se obține eliminând una sau mai multe muchii din graful original.\n2. Graful trebuie să rămână conex (să existe un drum între oricare două noduri).\n3. Graful parțial trebuie să fie diferit de graful original (cel puțin o muchie trebuie eliminată).\n4. Analizăm matricea de adiacență:\n```\n0 1 0 1 1\n1 0 1 0 0\n0 1 0 1 0\n1 0 1 0 0\n1 0 0 0 0\n```\n5. Graful are 5 noduri și 4 muchii: (1,2), (1,4), (1,5), (2,3), (3,4).\n6. Putem elimina muchiile una cate una. Daca eliminam (1,2), graful ramane conex. Daca eliminam (1,4), graful ramane conex. Daca eliminam (1,5), graful ramane conex. Daca eliminam (2,3), graful ramane conex. Daca eliminam (3,4), graful ramane conex. Deci avem 4 grafuri partiale.\n7. Putem elimina cate doua muchii. Daca eliminam (1,2) si (1,4), graful ramane conex. Daca eliminam (1,2) si (1,5), graful ramane conex. Daca eliminam (1,2) si (2,3), graful nu mai e conex. Daca eliminam (1,2) si (3,4), graful nu mai e conex. Daca eliminam (1,4) si (1,5), graful nu mai e conex. Daca eliminam (1,4) si (2,3), graful ramane conex. Daca eliminam (1,4) si (3,4), graful nu mai e conex. Daca eliminam (1,5) si (2,3), graful ramane conex. Daca eliminam (1,5) si (3,4), graful ramane conex. Daca eliminam (2,3) si (3,4), graful nu mai e conex. Deci avem inca 4 grafuri partiale.\n8. Putem elimina cate trei muchii. Daca eliminam (1,2), (1,4) si (1,5), graful nu mai e conex. Daca eliminam (1,2), (1,4) si (2,3), graful nu mai e conex. Daca eliminam (1,2), (1,4) si (3,4), graful nu mai e conex. Daca eliminam (1,2), (1,5) si (2,3), graful nu mai e conex. Daca eliminam (1,2), (1,5) si (3,4), graful nu mai e conex. Daca eliminam (1,4), (1,5) si (2,3), graful nu mai e conex. Daca eliminam (1,4), (1,5) si (3,4), graful nu mai e conex. Daca eliminam (1,2), (2,3) si (3,4), graful nu mai e conex. Daca eliminam (1,4), (2,3) si (3,4), graful nu mai e conex. Daca eliminam (1,5), (2,3) si (3,4), graful nu mai e conex. Deci nu avem niciun graf partial conex.\n9. Nu putem elimina 4 muchii, pentru ca graful nu ar mai fi conex.\n10. In total, avem 4 + 4 = 8 grafuri partiale conexe.\n\n### Răspuns\nc. 8\n\n### Cod Soluție (nu este necesar)\n\n---\n\n## Subiectul II - Exercițiul 1\n\n### Problemă Analiză\nTrebuie să analizăm un algoritm pseudocod, să determinăm ce afișează pentru o intrare dată, să găsim intrări minime și maxime care produc o anumită ieșire și să scriem codul C++ și o variantă echivalentă a algoritmului.\n\n### Soluție Abordare\na. **Urmărirea execuției pentru a = 240107:**\n\n- c = 0; Se intră în bucla `repetă`.\n- b = 240107; x = 0. Se intră în bucla interioară `repetă`.\n    - b % 10 (7) != c (0). b devine 24010.\n    - b % 10 (0) == c (0). x devine 1. Se iese din bucla interioară.\n- Se afișează x (1), urmat de un spațiu.\n- c devine 2.\n- b = 240107; x = 0. Se intră în bucla interioară `repetă`.\n    - b % 10 (7) != c (2). b devine 24010.\n    - b % 10 (0) != c (2). b devine 2401.\n    - b % 10 (1) != c (2). b devine 240.\n    - b % 10 (0) != c (2). b devine 24.\n    - b % 10 (4) != c (2). b devine 2.\n    - b % 10 (2) == c (2). x devine 1. Se iese din bucla interioară.\n- Se afișează x (1), urmat de un spațiu.\n- c devine 4.\n- b = 240107; x = 0. Se intră în bucla interioară `repetă`.\n    - ...\n    - b % 10 (4) == c (4). x devine 1. Se iese din bucla interioară.\n- Se afișează x (1), urmat de un spațiu.\n- c devine 6.\n- b = 240107; x = 0. Se intră în bucla interioară `repetă`.\n    - ...\n    - b % 10 (7) == c(6) -> x = 1\n- Se afișează x (1), urmat de un spațiu.\n- c devine 8.\n- b = 240107; x = 0. Se intră în bucla interioară `repetă`.\n    - ...\n    - Nicio cifra nu este 8, deci x ramane 0.\n- Se afișează x (0), urmat de un spațiu.\n- c devine 10. Se iese din bucla exterioară `repetă`.\n\nb. **Numere minime și maxime:**\n\n- Pentru ca toate valorile afișate să fie 1, numărul trebuie să conțină cifrele 0, 2, 4, 6, 8, în orice ordine.\n- Cel mai mic număr: 102468 (dar trebuie sa fie intre [10^5, 10^6), deci 102468 nu e bun). Cel mai mic numar cu cifre distincte din intervalul [10^5, 10^6) care contine cifrele 0, 2, 4, 6, 8 este 102468. Dar, algoritmul se opreste cand c > 9, deci nu e nevoie ca numarul sa contina toate cifrele pare. Cel mai mic numar este 10246.\n- Cel mai mare număr: 864201. Cel mai mare numar cu cifre distincte din intervalul [10^5, 10^6) este 987654. Cel mai mare numar care contine cifrele 0, 2, 4, 6, 8 este 86420. Cel mai mare numar este 864201.\n\nc. **Cod C++:**\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int a, b, c, x;\n    cin >> a;\n    c = 0;\n    do {\n        b = a;\n        x = 0;\n        do {\n            if (b % 10 == c) {\n                x = 1;\n            }\n            b = b / 10;\n        } while (b != 0 && x != 1);\n        cout << x << \" \";\n        c = c + 2;\n    } while (c <= 9);\n    cout << endl;\n    return 0;\n}\n```\n\nd. **Algoritm echivalent (cu `while`):**\n\n```\ncitește a (număr natural)\nc←0\n┌cât timp c<=9 execută\n│ b←a; x←0\n│┌cât timp b!=0 și x!=1 execută\n││┌dacă b%10=c atunci\n│││ x←1\n││└■\n││ b←[b/10]\n│└■\n│ scrie x,’ ’\n│ c←c+2\n└■\n```\n\n### Răspuns\na. 1 1 1 1 0\nb. Cel mai mic: 10246. Cel mai mare: 864201.\nc. Vezi codul C++ de mai sus.\nd. Vezi algoritmul pseudocod echivalent de mai sus.\n\n---\n\n## Subiectul II - Exercițiul 2\n\n### Problemă Analiză\nTrebuie să definim o structură C++ pentru a stoca date despre un calculator (capacitatea memoriei interne, externe și tipul monitorului) și să declarăm o variabilă de acest tip.\n\n### Soluție Abordare\n1. Definim structura `calculator` cu membrii: `monitor` (char), `memorie` (o sub-structură cu `interna` și `externa`, ambele int).\n2. Declarăm variabila `c` de tipul `calculator`.\n\n### Răspuns\n\n```cpp\nstruct memorie {\n    int interna;\n    int externa;\n};\n\nstruct calculator {\n    char monitor;\n    memorie memorie;\n};\n\ncalculator c;\n```\n\n---\n\n## Subiectul II - Exercițiul 3\n\n### Problemă Analiză\nTrebuie să completăm o secvență de cod C++ care inițializează o matrice bidimensională cu 9 linii și 9 coloane, astfel încât să aibă un model specific de caractere '>' și '<'.\n\n### Soluție Abordare\n1. Observăm modelul din matrice:\n    - Primele 5 linii conțin doar '>'.\n    - Linia 5 (index 4) conține doar '>'.\n    - Linia 6 (index 5) conține 4 '>'. apoi '<', apoi 4 '>'.\n    - Linia 7 (index 6) conține 3 '>'. apoi 3 '<', apoi 3 '>'.\n    - Linia 8 (index 7) conține 2 '>'. apoi 5 '<', apoi 2 '>'.\n    - Linia 9 (index 8) conține 1 '>'. apoi 7 '<', apoi 1 '>'.\n\n2. Deducem logica:\n   - Daca i < 5, a[i][j] = '>'.\n   - Daca i >= 5, trebuie sa verificam coloana j.\n     - Daca j < 9 - (i+1), a[i][j] = '>'.\n     - Daca j >= 9 - (i + 1) && j < i, a[i][j] = '<'.\n     - Daca j >= i, a[i][j] = '>'.\n\n### Răspuns\n\n```cpp\nfor(i=0;i<9;i++)\n for(j=0;j<9;j++)\n    if(i < 5) {\n        a[i][j] = '>';\n    } else {\n        if (j < 8 - i) {\n            a[i][j] = '>';\n        } else if (j >= 8 - i && j <= i) {\n            a[i][j] = '<';\n        }\n        else\n        {\n            a[i][j] = '>';\n        }\n    }\n```\nO varianta mai simpla:\n```cpp\nfor(i=0;i<9;i++)\n for(j=0;j<9;j++)\n    if(i < 5 || j < 8 - i || j > i)\n        a[i][j] = '>';\n    else\n        a[i][j] = '<';\n```\n\n---\n\n## Subiectul III - Exercițiul 1\n\n### Problemă Analiză\nTrebuie să scriem o funcție C++ care primește două numere naturale și returnează suma divizorilor comuni ai acestora.\n\n### Soluție Abordare\n1. Iterăm prin toți posibilii divizori, de la 1 până la minimul dintre `a` și `b`.\n2. Pentru fiecare număr, verificăm dacă este divizor comun al lui `a` și `b`.\n3. Dacă este divizor comun, îl adăugăm la o sumă.\n4. Returnăm suma.\n\n### Răspuns\n\n```cpp\nint suma(int a, int b) {\n    int s = 0;\n    int min_val = (a < b) ? a : b;\n    for (int i = 1; i <= min_val; ++i) {\n        if (a % i == 0 && b % i == 0) {\n            s += i;\n        }\n    }\n    return s;\n}\n```\n\n---\n\n## Subiectul III - Exercițiul 2\n\n### Problemă Analiză\nTrebuie să scriem un program C++ care citește un text, rotește spre stânga cuvintele de cel puțin 3 litere și afișează textul modificat sau un mesaj dacă nu există cuvinte de rotit.\n\n### Soluție Abordare\n1. Citim textul.\n2. Parcurgem textul cuvânt cu cuvânt.\n3. Pentru fiecare cuvânt:\n    - Verificăm lungimea.\n    - Dacă lungimea este >= 3:\n        - Rotim cuvântul: salvăm prima literă, mutăm restul literelor spre stânga, punem prima literă la final.\n    - Altfel, nu modificăm cuvântul.\n4. Afișăm textul modificat.\n5. Daca nu am rotit niciun cuvant, afisam \"nu exista\".\n\n### Răspuns\n\n```cpp\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint main() {\n    char text[101];\n    cin.getline(text, 101);\n\n    char* cuvant = strtok(text, \" \");\n    bool rotit = false;\n\n    while (cuvant != NULL) {\n        int len = strlen(cuvant);\n        if (len >= 3) {\n            rotit = true;\n            char primaLitera = cuvant[0];\n            for (int i = 0; i < len - 1; ++i) {\n                cuvant[i] = cuvant[i + 1];\n            }\n            cuvant[len - 1] = primaLitera;\n        }\n        cout << cuvant << \" \";\n        cuvant = strtok(NULL, \" \");\n    }\n    cout << endl;\n\n    if (!rotit) {\n        cout << \"nu exista\" << endl;\n    }\n\n    return 0;\n}\n```\n\n---\n\n## Subiectul III - Exercițiul 3\n\n### Problemă Analiză\nTrebuie să verificăm dacă un șir de numere dintr-un fișier poate fi rearanjat pentru a forma un palindrom. Trebuie să proiectăm un algoritm eficient.\n\n### Soluție Abordare\n1. **Eficiență:** Nu sortăm sau generăm permutări, deoarece ar fi ineficient (O(n log n) sau O(n!)).\n2. **Observație:** Un șir poate fi rearanjat ca palindrom dacă și numai dacă cel mult un număr apare de un număr impar de ori.\n3. **Algoritm:**\n    - Folosim un vector de frecvență pentru a număra aparițiile fiecărui număr.\n    - Parcurgem vectorul de frecvență și numărăm câte numere au frecvență impară.\n    - Dacă numărul de frecvențe impare este cel mult 1, afișăm \"DA\", altfel afișăm \"NU\".\n\na. **Descriere și justificare:**\nAlgoritmul este eficient deoarece parcurge șirul o singură dată pentru a calcula frecvențele (O(n), unde n este numărul de elemente din șir) și apoi parcurge vectorul de frecvență (O(m), unde m este numărul maxim de elemente distincte, care este limitat de intervalul [1, 10^3], deci m <= 1000). Complexitatea totală este O(n + m), care este liniară, deci eficientă.\n\nb. **Cod C++:**\n\n```cpp\n#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.in\");\n    int frecventa[1001] = {0}; // Inițializăm frecvențele cu 0\n    int x;\n\n    while (fin >> x) {\n        frecventa[x]++;\n    }\n\n    int impare = 0;\n    for (int i = 1; i <= 1000; ++i) {\n        if (frecventa[i] % 2 != 0) {\n            impare++;\n        }\n    }\n\n    if (impare <= 1) {\n        cout << \"DA\" << endl;\n    } else {\n        cout << \"NU\" << endl;\n    }\n\n    fin.close();\n    return 0;\n}\n```\n",
    "solutions_anthropicclaude37sonnet_0.0": "# Rezolvarea exercițiilor de informatică\n\n## Subiectul I - Exercițiul 1\n### Analiza problemei\nTrebuie să evaluăm expresia C/C++ `3+5.0/2+2` respectând ordinea operațiilor.\n\n### Abordarea soluției\nÎn C/C++, operațiile se execută conform priorității: mai întâi împărțirea, apoi adunarea de la stânga la dreapta.\n- 5.0/2 = 2.5 (împărțire în virgulă mobilă)\n- 3 + 2.5 = 5.5\n- 5.5 + 2 = 7.5\n\n### Răspuns\nRăspunsul corect este d. 7.5\n\n## Subiectul I - Exercițiul 2\n### Analiza problemei\nAvem un subprogram recursiv `f` care modifică un tablou și afișează elementele acestuia. Trebuie să determinăm valorile inițiale ale tabloului pentru a obține afișarea \"2020\".\n\n### Abordarea soluției\nAnalizăm funcția recursivă:\n- Dacă i>=3, incrementează v[i] și apoi afișează v[i]\n- Altfel, apelează recursiv f(i+1,v) și apoi afișează v[i]\n\nApelul inițial este f(0,v), deci execuția va fi:\n1. f(0,v) apelează f(1,v)\n2. f(1,v) apelează f(2,v)\n3. f(2,v) apelează f(3,v)\n4. f(3,v) incrementează v[3] și afișează v[3]\n5. f(2,v) afișează v[2]\n6. f(1,v) afișează v[1]\n7. f(0,v) afișează v[0]\n\nDeci afișarea va fi în ordinea: v[3]+1, v[2], v[1], v[0]\nPentru a obține \"2020\", avem nevoie ca: v[3]+1=0, v[2]=2, v[1]=0, v[0]=2\n\n### Răspuns\nValorile inițiale ale tabloului trebuie să fie: v[0]=2, v[1]=0, v[2]=2, v[3]=-1\nRăspunsul corect este a. -1,1,0,2\n\n## Subiectul I - Exercițiul 3\n### Analiza problemei\nSe generează prin backtracking toate modalitățile în care 4 persoane pot plăti 200 lei, cu condiția ca sumele să fie divizibile cu 10, nenule, și în ordine strict descrescătoare.\n\n### Abordarea soluției\nPrimele patru soluții sunt: (70,60,40,30), (70,60,50,20), (80,50,40,30), (80,60,40,20).\nPentru a determina a șasea soluție, trebuie să continuăm generarea:\n- A cincea soluție: după (80,60,40,20) urmează (80,60,50,10)\n- A șasea soluție: după (80,60,50,10) urmează (80,70,30,20)\n\n### Răspuns\nRăspunsul corect este c. (80,70,30,20)\n\n## Subiectul I - Exercițiul 4\n### Analiza problemei\nAvem un arbore reprezentat prin vectorul de tați (7,5,6,5,7,0,6,3,3,8). Trebuie să determinăm numărul de noduri frunză.\n\n### Abordarea soluției\nUn nod este frunză dacă nu este tată pentru niciun alt nod. Vom număra de câte ori apare fiecare nod ca tată și apoi vom număra nodurile care nu sunt tați pentru nimeni.\n\nVectorul de tați: (7,5,6,5,7,0,6,3,3,8) - pentru nodurile 1 până la 10\n- Nodul 0 nu există în arbore (este folosit pentru a marca rădăcina)\n- Nodurile care apar ca tați: 3, 5, 6, 7, 8\n- Nodurile care nu apar ca tați (frunze): 1, 2, 4, 9, 10\n\n### Răspuns\nRăspunsul corect este c. 5\n\n## Subiectul I - Exercițiul 5\n### Analiza problemei\nAvem un graf neorientat cu 5 noduri reprezentat prin matricea de adiacență. Trebuie să determinăm numărul de grafuri parțiale conexe diferite de graful dat.\n\n### Abordarea soluției\nUn graf parțial se obține eliminând muchii din graful original, păstrând toate nodurile. Trebuie să numărăm câte astfel de grafuri parțiale sunt conexe și diferite de graful original.\n\nDin matricea de adiacență, observăm că graful are 6 muchii:\n(1,2), (1,4), (1,5), (2,3), (3,4), (4,5)\n\nPentru ca un graf parțial să fie conex, trebuie să conțină cel puțin 4 muchii (un arbore cu 5 noduri are 4 muchii).\nDeci putem elimina maxim 2 muchii astfel încât graful să rămână conex.\n\n- Numărul de moduri de a elimina 1 muchie: C(6,1) = 6\n- Numărul de moduri de a elimina 2 muchii: trebuie analizat pentru fiecare pereche dacă graful rămâne conex\n\nDupă analiză detaliată, rezultă că există 2 moduri de a elimina 2 muchii astfel încât graful să rămână conex.\n\n### Răspuns\nRăspunsul corect este b. 6\n\n## Subiectul II - Exercițiul 1\n### Analiza problemei\nAvem un algoritm în pseudocod care verifică prezența anumitor cifre într-un număr.\n\n### Abordarea soluției\na) Pentru numărul 240107:\n- c=0: verifică dacă cifra 0 apare în număr (da, apare) → afișează 1\n- c=2: verifică dacă cifra 2 apare în număr (da, apare) → afișează 1\n- c=4: verifică dacă cifra 4 apare în număr (da, apare) → afișează 1\n- c=6: verifică dacă cifra 6 apare în număr (nu apare) → afișează 0\n- c=8: verifică dacă cifra 8 apare în număr (nu apare) → afișează 0\nRezultat: 1 1 1 0 0\n\nb) Pentru ca toate valorile afișate să fie nenule, numărul trebuie să conțină cifrele 0, 2, 4, 6 și 8.\n- Cel mai mic număr din [105,106) cu cifrele distincte care conține 0,2,4,6,8: 102468\n- Cel mai mare număr din [105,106) cu cifrele distincte care conține 0,2,4,6,8: 986420\n\nc) Programul C++ corespunzător:\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, c, b, x;\n    cin >> a;\n    c = 0;\n    do {\n        b = a;\n        x = 0;\n        do {\n            if (b % 10 == c)\n                x = 1;\n            b = b / 10;\n        } while (b != 0 && x != 1);\n        cout << x << \" \";\n        c = c + 2;\n    } while (c <= 9);\n    return 0;\n}\n```\n\nd) Algoritmul echivalent, înlocuind a doua structură repetă...până când:\n\n```\ncitește a (număr natural)\nc←0\n┌repetă\n│ b←a; x←0\n│┌cât timp b≠0 și x≠1 execută\n││┌dacă b%10=c atunci\n│││ x←1\n││└■\n││ b←[b/10]\n│└■\n│ scrie x,' '\n│ c←c+2\n└până când c>9\n```\n\n## Subiectul II - Exercițiul 2\n### Analiza problemei\nTrebuie să definim o structură pentru un calculator care să conțină tipul monitorului și capacitatea memoriei (internă și externă).\n\n### Abordarea soluției\nDin expresiile date, observăm că avem nevoie de:\n- Un câmp pentru monitor (de tip char)\n- O structură internă pentru memorie cu două câmpuri: internă și externă (ambele de tip int)\n\n### Răspuns\n```cpp\nstruct calculator {\n    char monitor;\n    struct {\n        int interna;\n        int externa;\n    } memorie;\n} c;\n```\n\n## Subiectul II - Exercițiul 3\n### Analiza problemei\nAvem un tablou bidimensional 9x9 inițializat cu caracterul '=' și trebuie să-l modificăm pentru a obține modelul dat.\n\n### Abordarea soluției\nAnalizând modelul, observăm că:\n- Caracterul '>' apare în majoritatea pozițiilor\n- Caracterul '<' apare doar în anumite poziții din partea de jos a tabloului\n\nRegula pare să fie: dacă i+j >= 13, atunci a[i][j] = '<', altfel a[i][j] = '>'\n\n### Răspuns\n```cpp\nfor(i=0;i<9;i++)\n for(j=0;j<9;j++)\n    if(i+j>=13) a[i][j]='<'; else a[i][j]='>';\n```\n\n## Subiectul III - Exercițiul 1\n### Analiza problemei\nTrebuie să implementăm un subprogram care returnează suma divizorilor comuni a două numere naturale.\n\n### Abordarea soluției\nVom găsi toți divizorii primului număr și vom verifica care dintre ei sunt și divizori ai celui de-al doilea număr. Apoi vom calcula suma acestora.\n\n### Răspuns\n```cpp\nint suma(int a, int b) {\n    int s = 0;\n    for (int d = 1; d <= a; d++) {\n        if (a % d == 0 && b % d == 0) {\n            s += d;\n        }\n    }\n    return s;\n}\n```\n\n## Subiectul III - Exercițiul 2\n### Analiza problemei\nTrebuie să transformăm un text prin rotirea spre stânga a fiecărui cuvânt format din cel puțin 3 litere.\n\n### Abordarea soluției\nVom parcurge textul cuvânt cu cuvânt și vom aplica transformarea doar cuvintelor care au cel puțin 3 litere.\n\n### Răspuns\n```cpp\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n    char text[101], rezultat[101] = \"\", *p;\n    bool exista = false;\n    \n    cin.getline(text, 101);\n    \n    p = strtok(text, \" \");\n    while (p != NULL) {\n        if (strlen(p) >= 3) {\n            exista = true;\n            char temp = p[0];\n            for (int i = 0; i < strlen(p) - 1; i++) {\n                p[i] = p[i + 1];\n            }\n            p[strlen(p) - 1] = temp;\n        }\n        \n        strcat(rezultat, p);\n        strcat(rezultat, \" \");\n        \n        p = strtok(NULL, \" \");\n    }\n    \n    if (exista) {\n        rezultat[strlen(rezultat) - 1] = '\\0'; // Eliminăm ultimul spațiu\n        cout << rezultat;\n    } else {\n        cout << \"nu exista\";\n    }\n    \n    return 0;\n}\n```\n\n## Subiectul III - Exercițiul 3\n### Analiza problemei\nTrebuie să verificăm dacă numerele dintr-un șir pot fi rearanjate pentru a forma un șir palindromic.\n\n### Abordarea soluției\na) Descrierea algoritmului:\n1. Un șir poate fi rearanjat pentru a forma un palindrom dacă și numai dacă cel mult un număr apare de un număr impar de ori, iar toate celelalte apar de un număr par de ori.\n2. Vom număra frecvența fiecărui număr din șir.\n3. Vom verifica dacă cel mult un număr apare de un număr impar de ori.\n\nEficiența algoritmului:\n- Timp: O(n) - parcurgem șirul o singură dată\n- Spațiu: O(1) - folosim un vector de frecvență de dimensiune fixă (1000)\n\nb) Implementarea în C++:\n\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.in\");\n    int x, frecventa[1001] = {0};\n    int impare = 0;\n    \n    // Citim numerele și calculăm frecvența\n    while (fin >> x) {\n        frecventa[x]++;\n    }\n    \n    // Numărăm câte numere apar de un număr impar de ori\n    for (int i = 1; i <= 1000; i++) {\n        if (frecventa[i] % 2 == 1) {\n            impare++;\n        }\n    }\n    \n    // Verificăm condiția pentru palindrom\n    if (impare <= 1) {\n        cout << \"DA\";\n    } else {\n        cout << \"NU\";\n    }\n    \n    fin.close();\n    return 0;\n}\n```"
}