{
    "gpt_model": "E_d_Informatica_2020_sp_MI_C_var_06_LRO",
    "gpt_response": {
        "id": "chatcmpl-BH2wQ438bOT0pZNu3U2BmaQ4kyh7T",
        "model": "o3-mini-2025-01-31",
        "object": "chat.completion",
        "choices": [
            {
                "finish_reason": "stop",
                "index": 0,
                "message": {
                    "content": "## Subiectul I - Exercitiul 1\n\nAnaliză:  \nTrebuie evaluată expresia „3 + 5.0/2 + 2” în C/C++. Deoarece 5.0 este număr real, operaţia de împărţire se efectuează în virgulă mobilă. Calculul se face astfel:  \n  5.0/2 = 2.5  \n  3 + 2.5 + 2 = 7.5\n\nStrategie pas cu pas:  \n1. Se efectuează împărţirea 5.0/2 → 2.5.  \n2. Se adună 3 și 2 → 5.  \n3. Apoi se adaugă 2.5 → 7.5.\n\nRăspuns final: 7.5 – varianta d.\n\n```cpp\n#include <iostream>\nusing namespace std;\n \nint main(){\n    // Calcularea expresiei 3 + 5.0/2 + 2\n    double rezultat = 3 + 5.0/2 + 2;\n    cout << \"Rezultatul este: \" << rezultat << endl;  // Afișează 7.5\n    return 0;\n}\n```\n\n---\n \n## Subiectul I - Exercitiul 2\n\nAnaliză:  \nAvem un tablou v cu 4 elemente și un subprogram f definit recursiv astfel:  \n – Dacă indicele i e cel din dreapta (i>=3) se actualizează elementul (v[3] devine v[3]+1) și se afișează.  \n – Altfel, se apelează f(i+1, v) iar după revenire se afișează v[i].  \nApelul f(0, v) va afişa elementele în ordine: f(3) → f(2) → f(1) → f(0).  \nDacă notăm iniţial v = {a, b, c, d}, atunci:  \n – Pentru i = 3: se face d = d + 1 şi se afișează (valoarea devine prima cifră a şirului afişat).  \n – Rezultatul final concatenat trebuie să fie „2020”.  \nDeci trebuie ca:  \n  d+1 = 2 → d = 1  \n  c = 0  \n  b = 2  \n  a = 0  \nDeci tabloul este {0, 2, 0, 1}.\n\nStrategie pas cu pas:  \n1. Stabiliţi condiţiile impuse de afişare, având în vedere ordinea recursivă.  \n2. Se rezolvă ecuaţiile pentru a, b, c, d.\n\nRăspuns final: v = {0, 2, 0, 1} – varianta b.\n\n```cpp\n#include <iostream>\nusing namespace std;\n \nvoid f(int i, int v[4]){\n    if(i >= 3) {\n        v[i] = v[i] + 1;\n    }\n    else {\n        f(i+1, v);\n    }\n    cout << v[i];\n}\n \nint main(){\n    int v[4] = {0, 2, 0, 1}; // Setarea valorilor astfel încât f(0, v) să afișeze \"2020\"\n    f(0, v);\n    return 0;\n}\n```\n\n---\n \n## Subiectul I - Exercitiul 3\n\nAnaliză:  \nSe generează prin backtracking toate quadruplele (sume în lei, multipli de 10, nenule) care îndeplinesc:  \n  suma = 200, şi  \n  prima > a doua > a treia > a patra.  \nPrimele patru soluţii generate sunt:  \n  (70, 60, 40, 30), (70, 60, 50, 20), (80, 50, 40, 30) şi (80, 60, 40, 20).  \nSe deduce că metoda de parcurgere a posibilităţilor – probabil prin iterarea valorii “a” de la valorile mici spre mari şi, la interior, iterarea “b”, apoi „c” şi „d” – va genera ulterior şi (80, 60, 50, 10) şi apoi (80, 70, 40, 10).  \nComparând cu opţiunile date, singura variantă care corespunde fiind (80, 70, 40, 10).\n\nStrategie pas cu pas:  \n1. Notaţi că transformând sumele în “zeci” avem:  \n  (7,6,4,3), (7,6,5,2), (8,5,4,3), (8,6,4,2), (8,6,5,1) și (8,7,4,1).  \n2. Conform ordinii de generare date, cea de-a șasea soluţie este (8,7,4,1) ce corespunde (80, 70, 40, 10).\n\nRăspuns final: (80, 70, 40, 10) – varianta d.\n\n---\n \n## Subiectul I - Exercitiul 4\n\nAnaliză:  \nAvem un arbore cu 10 noduri reprezentat prin vectorul de “tați”:  \n  (7, 5, 6, 5, 7, 0, 6, 3, 3, 8)  \nInterpretare: elementul de pe poziţia i este tatăl nodului i+1. Nodul cu valoare 0 este rădăcina.  \nConstruim lista de copii:  \n – Nod 1 (tată 7)  → copil al nodului 7  \n – Nod 2 (tată 5)  → copil al nodului 5  \n – Nod 3 (tată 6)  → copil al nodului 6  \n – Nod 4 (tată 5)  → copil al nodului 5  \n – Nod 5 (tată 7)  → copil al nodului 7  \n – Nod 6 (tată 0)  → rădăcină  \n – Nod 7 (tată 6)  → copil al nodului 6  \n – Nod 8 (tată 3)  → copil al nodului 3  \n – Nod 9 (tată 3)  → copil al nodului 3  \n – Nod 10 (tată 8) → copil al nodului 8  \nDeterminăm nodurile care nu apar ca tată (nu au copii):  \n – Nod 1: nu are copii  \n – Nod 2: nu are copii  \n – Nod 4: nu are copii  \n – Nod 9: nu are copii  \n – Nod 10: nu are copii\n\nStrategie pas cu pas:  \n1. Se listează toate nodurile şi se identifică pe cele care nu sunt “tați”.  \n2. Se numără nodurile frunză.\n\nRăspuns final: 5 noduri – varianta c.\n\n---\n \n## Subiectul I - Exercitiul 5\n\nAnaliză:  \nAvem un graf neorientat cu 5 noduri şi 5 muchii (determinate din matricea de adiacență):  \n  Muchiile sunt: 1–2, 1–4, 1–5, 2–3 şi 3–4.  \nSe consideră grafurile parţiale conexe – adică subgrafuri cu acelaşi set de noduri şi cu o mulțime de muchii, care sunt conexe, diferite de graful dat (care are toate 5 muchiile).  \nObservaţie: Un graf conex cu 5 noduri are cel puţin 4 muchii (arborele de acoperire).  \nCalculăm:  \n – Există 4 submulţimi de 4 muchii (spanning trees) care sunt conecte (calculând prin eliminarea fiecărei muchii, se verifică dacă se obţine un arbore conex – s-a obţinut 4 soluţii valide).  \n – Submulţimea de 5 muchii este graful dat şi se exclude.  \n\nStrategie pas cu pas:  \n1. Enumerăm toate submulţimile de muchii şi selectăm cele care dau un graf conex.  \n2. Se observă că singurele grafuri parţiale conexe diferite de graful dat sunt cele 4 arbore de acoperire.\n\nRăspuns final: 4 grafuri – varianta a.\n\n---\n \n## Subiectul II - Exercitiul 1\n\nAnaliză:  \nAvem un algoritm care, pentru un număr natural a citit de la tastatură, parcurge, pentru c = 0, 2, 4, 6, 8, cifrele lui a (de la dreapta la stânga) şi dacă găseşte cel puţin o cifră egală cu c, setează x=1; altfel rămâne x=0. Se afișează valoarea lui x pentru fiecare c şi se incrementează c cu 2, până când c > 9.  \nTrebuie să rezolvăm patru subpuncte:\n\na) Simularea algoritmului pentru a = 240107.  \nb) Găsirea celui mai mic şi celui mai mare număr din intervalul [10^5, 10^6) cu cifre distincte, care, la rularea algoritmului, au toate valorile afişate nenule.  \nc) Scrierea programului în C/C++ corespunzător.  \nd) Rescrierea algoritmului folosind o altă structură repetitivă pentru a doua buclă.\n\n----------------------------------------------------\n\na) Simulare pentru a = 240107\n\nSe parcurge pentru c = 0, 2, 4, 6 și 8:\n\n• Pentru c = 0:  \n Se parcurg cifrele numărului de la dreapta: 7, 0, ...  \n Când se întâlneşte cifra 0, x devine 1.  \n Afișare: 1\n\n• Pentru c = 2:  \n Cifrele: 7, 0, 1, 0, 4, 2 → se găseşte 2.  \n Afișare: 1\n\n• Pentru c = 4:  \n Cifrele: 7, 0, 1, 0, 4 → se găseşte 4.  \n Afișare: 1\n\n• Pentru c = 6:  \n Cifrele: 7, 0, 1, 0, 4, 2 – niciun 6.  \n Afișare: 0\n\n• Pentru c = 8:  \n Parcurgerea similară nu găseşte 8.  \n Afișare: 0\n\nValorile afişate sunt: 1 1 1 0 0\n\n----------------------------------------------------\n\nb) Pentru ca fiecare valoare afișată să fie nenul (adică pentru fiecare c, s-a găsit apare o cifră egală cu c), numărul citit trebuie să conţină cel puţin o cifră 0, 2, 4, 6 şi 8.  \nDin intervalul [10^5, 10^6) avem numere formate din 6 cifre, cu toate cifrele distincte.  \nCel mai mic număr care conţine obligatoriu cifrele 0, 2, 4, 6, 8 şi o altă cifră suplimentară (care va fi 1 pentru minim) se poate forma ordonând cifrele în ordine crescătoare, dar având cifra 0 plasată pe poziția care nu este prima (deoarece numărul nu poate începe cu 0).  \nAstfel, cel mai mic număr este: 102468  \nSimilar, cel mai mare număr se obţine folosind cifrele {0,2,4,6,8,9} în ordine descrescătoare, obţinând: 986420\n\n----------------------------------------------------\n\nc) Programul C/C++ pentru algoritmul dat:\n\n```cpp\n#include <iostream>\nusing namespace std;\n \nint main(){\n    unsigned int a;\n    cin >> a;  // Citim numărul natural\n    int c = 0;\n    // Se repetă pentru c = 0,2,4,6,8 (c <= 9)\n    do {\n        int b = a;\n        int x = 0;  // x va deveni 1 dacă se găsește cifra c\n        // Parcurgem cifrele lui b (de la dreapta la stânga)\n        do {\n            if(b % 10 == c)\n                x = 1;\n            b = b / 10;  // Partea întreagă după împărţire la 10\n        } while(b != 0 && x == 0);\n \n        cout << x << \" \";\n        c = c + 2;\n    } while(c <= 9);\n \n    return 0;\n}\n```\n\n----------------------------------------------------\n\nd) Variante în pseudocod cu înlocuirea structurii repetitivă (a doua buclă) cu o structură de tip while:\n\nPseudocodul echivalent:\n\nAlgoritm:\n  c ← 0  \n  repeat  \n    b ← a  \n    x ← 0  \n    while (b ≠ 0 and x = 0) do  \n      if (b % 10 = c) then x ← 1  \n      b ← [b/10]  \n    end while  \n    scrie x, \" \"  \n    c ← c + 2  \n  until (c > 9)\n\n---\n\n## Subiectul II - Exercitiul 2\n\nAnaliză:  \nVariabila c memorează informaţii despre un calculator:  \n  – c.monitor – o literă (tipul monitorului)  \n  – c.memorie – o structură care conţine:  \n    c.memorie.interna – capacitatea memoriei interne (număr natural din [1,10^6])  \n    c.memorie.externa – capacitatea memoriei externe (număr natural din [1,10^6])\n\nStrategie pas cu pas:  \n1. Definirea structurii externe (ex: struct Memorie) şi apoi a structurii calculator.  \n2. Declararea variabilei c de tip calculator.\n\nRăspuns final:\n\n```cpp\n#include <iostream>\nusing namespace std;\n \n// Definim o structură pentru memorie\nstruct Memorie {\n    unsigned int interna; // capacitatea memoriei interne\n    unsigned int externa; // capacitatea memoriei externe\n};\n \n// Structura calculator\nstruct Calculator {\n    char monitor;   // litera ce indică tipul monitorului\n    Memorie memorie;\n};\n \nint main(){\n    // Declarația variabilei c de tip Calculator\n    Calculator c;\n    \n    // Exemplu de inițializare (se poate citi de la tastatură)\n    c.monitor = 'A';\n    c.memorie.interna = 500;   // exemplu: 500 GB\n    c.memorie.externa = 120;    // exemplu: 120 GB\n    \n    cout << \"Monitor: \" << c.monitor << \"\\nMemorie interna: \" << c.memorie.interna \n         << \"\\nMemorie externa: \" << c.memorie.externa << endl;\n    return 0;\n}\n```\n\n---\n \n## Subiectul II - Exercitiul 3\n\nAnaliză:  \nAvem un tablou bidimensional a cu 9 linii şi 9 coloane, iniţial cu elementele '='. Trebuie să se modifice elementele tabloului astfel încât, la final, acesta să aibă forma:\n\n  Linia 1: > > > > > > > > >  \n  Linia 2: > > > > > > > > >  \n  Linia 3: > > > > > > > > >  \n  Linia 4: > > > > > > > > >  \n  Linia 5: > > > > > > > > >  \n  Linia 6: > > > < > > > > >  \n  Linia 7: > > < < < > > > >  \n  Linia 8: > < < < < < > > >  \n  Linia 9: < < < < < < < > >\n\nStrategie pas cu pas:  \nIdentificăm poziţiile în care înlocuim simbolul '=' cu '<', celelalte rămân '>'.  \nObservaţi:  \n– Pentru liniile 0–4 (primele 5 linii, indexate de la 0) se păstrează '>'.  \n– Pentru linia 5 (i = 5): se pune '<' doar la coloana 3.  \n– Pentru linia 6 (i = 6): se pun '<' la coloanele 2, 3 şi 4.  \n– Pentru linia 7 (i = 7): se pun '<' la coloanele 1 până la 5.  \n– Pentru linia 8 (i = 8): se pun '<' la coloanele 0 până la 6.\n\nRăspuns final: Comanda necesară se poate scrie astfel:\n\n```cpp\n#include <iostream>\nusing namespace std;\n \nint main(){\n    char a[9][9];\n    int i, j;\n    \n    // Inițializare cu '=' (deşi se poate porni cu orice valoare, dar se va suprascrie)\n    for(i = 0; i < 9; i++)\n        for(j = 0; j < 9; j++)\n            a[i][j] = '=';\n    \n    // Modificare conform modelului cerut\n    for(i = 0; i < 9; i++){\n        for(j = 0; j < 9; j++){\n            if(i < 5){\n                a[i][j] = '>';\n            }\n            else if(i == 5){\n                if(j == 3)\n                    a[i][j] = '<';\n                else\n                    a[i][j] = '>';\n            }\n            else if(i == 6){\n                if(j >= 2 && j <= 4)\n                    a[i][j] = '<';\n                else\n                    a[i][j] = '>';\n            }\n            else if(i == 7){\n                if(j >= 1 && j <= 5)\n                    a[i][j] = '<';\n                else\n                    a[i][j] = '>';\n            }\n            else if(i == 8){\n                if(j <= 6)\n                    a[i][j] = '<';\n                else\n                    a[i][j] = '>';\n            }\n        }\n    }\n    \n    // Afișarea tabloului\n    for(i = 0; i < 9; i++){\n        for(j = 0; j < 9; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}\n```\n\nObservație: Secvența de completat în bucla dublă poate fi obţinută prin blocul de condiţii if–else prezentat.\n\n---\n \n## Subiectul III - Exercitiul 1\n\nAnaliză:  \nSubprogramul \"suma\" primeşte doi parametri naturali a şi b (din intervalul [1,10^4]) şi trebuie să returneze suma tuturor divizorilor comuni ai lui a şi b.  \nObservaţie: Orice divizor comun al lui a şi b divizează şi pe gcd(a, b). De aceea, se poate calcula gcd-ul şi apoi suma divizorilor lui gcd.  \nStrategie pas cu pas:  \n1. Se calculează gcd-ul lui a şi b.  \n2. Se parcurge de la 1 la √g şi se adaugă divizorii (atenţie la dublare, dacă divisorul este pătratul perfect).\n\nRăspuns final:\n\n```cpp\n#include <iostream>\n#include <cmath>\nusing namespace std;\n \n// Funcție pentru calculul celui mai mare divizor comun (gcd)\nint gcd(int a, int b){\n    while(b){\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n \n// Subprogramul suma: returnează suma divizorilor comuni ai lui a și b\nint suma(int a, int b){\n    int g = gcd(a, b);\n    int s = 0;\n    // Parcurgem divizorii lui g\n    for(int d = 1; d <= sqrt(g); d++){\n        if(g % d == 0){\n            s += d;\n            if(d != g/d)\n                s += g/d;\n        }\n    }\n    return s;\n}\n \nint main(){\n    int a, b;\n    cin >> a >> b;\n    cout << \"Suma divizorilor comuni este: \" << suma(a, b) << endl;\n    return 0;\n}\n```\n\nExemplu: pentru a=20 şi b=12, gcd(20,12)=4, iar divizorii lui 4 sunt 1, 2, 4; suma = 7.\n\n---\n \n## Subiectul III - Exercitiul 2\n\nAnaliză:  \nAvem de citit un text cu cel mult 100 de caractere, conţinând cuvinte formate din litere mici ale alfabetului englez şi separate prin spațiu.  \nSe aplică operaţia de rotire spre stânga pentru fiecare cuvânt format din cel puțin trei litere: prima literă se mută la final, iar celelalte se deplasează cu o poziţie spre stânga.  \nDacă în text nu există niciun cuvânt cu cel puțin trei litere se va afișa mesajul \"nu exista\".\n\nStrategie pas cu pas:  \n1. Se citeşte linia de text.  \n2. Se împarte textul în cuvinte (folosind spaţiul ca separator).  \n3. Pentru fiecare cuvânt cu lungime ≥ 3, se realizează rotirea (noul cuvânt = subşirul de la a doua literă până la sfârşit + prima literă).  \n4. Se formează textul modificat.  \n5. Dacă niciun cuvânt nu îndeplinește criteriul, se afișează \"nu exista\".\n\nRăspuns final:\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\n \nint main(){\n    string text, cuvant;\n    getline(cin, text); // Citim textul întreg\n    istringstream iss(text);\n    string rezultat = \"\";\n    bool aFostModificat = false;\n    \n    while(iss >> cuvant){\n        if(cuvant.length() >= 3){\n            // Rotirea spre stânga: se mută prima literă la sfârșit\n            cuvant = cuvant.substr(1) + cuvant[0];\n            aFostModificat = true;\n        }\n        rezultat += cuvant + \" \";\n    }\n    \n    if(aFostModificat)\n        cout << rezultat;\n    else\n        cout << \"nu exista\";\n    \n    return 0;\n}\n```\n\nExemplu:  \nPentru textul:  \n  \"un palc mic de scolarite ilumina sala\"  \nSe obţine:  \n  \"un alcp icm de colarites luminai alas\"\n\n---\n \n## Subiectul III - Exercitiul 3\n\nAnaliză:  \nTrebuie să determinăm dacă numerele dintr‑un şir (din fişierul bac.in) pot fi rearanjate astfel încât să formeze un șir palindromic.  \nIdee:  \nUn şir poate fi rearanjat într‑un palindrom dacă cel mult un element apare un număr impar de ori (în cazul numerelor cu număr impar de apariţii, acesta va fi plasat în mijloc).  \nStrategie pentru eficienţă:  \n1. Citiți numerele şi țineți un contor (frecvenţa) pentru fiecare număr (fiindcă numerele sunt din intervalul [1,10^3], putem folosi un tablou de 1001 elemente).  \n2. Se numără câte valori apar de un număr impar de ori.  \n3. Dacă numărul de valori cu frecvenţă impară este cel mult 1, atunci se poate forma un palindrom; altfel, nu se poate.\n\na) Descriere în limbaj natural:  \n  Se parcurge şirul de numere şi se calculează frecvenţa de apariţie pentru fiecare număr.  \n  Un şir poate forma un palindrom dacă, în cazul unui şir cu un număr par de elemente, toate numerele apar de un număr par de ori; iar în cazul unui şir cu număr impar de elemente, exact unul dintre numere poate avea frecvenţă impară.  \n  Această abordare este O(n) la timp, folosind un tablou de frecvenţă de dimensiune fixă (1001), deci este foarte eficientă.\n\nb) Programul C/C++:\n\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\n \nint main(){\n    ifstream fin(\"bac.in\");\n    int num;\n    // Datele sunt din intervalul [1,10^3], deci folosim un tablou de 1001 elemente\n    int freq[1001] = {0};\n \n    // Citim numerele din fișier\n    while(fin >> num){\n        freq[num]++;\n    }\n    fin.close();\n \n    int imparCount = 0;\n    for(int i = 1; i <= 1000; i++){\n        if(freq[i] % 2 != 0)\n            imparCount++;\n    }\n    \n    if(imparCount <= 1)\n        cout << \"DA\";\n    else\n        cout << \"NU\";\n \n    return 0;\n}\n```\n\nExplicaţie:  \n– Se citeşte fiecare număr şi se actualizează frecvenţa.  \n– Se verifică câte numere apar de un număr impar de ori.  \n– Dacă cel mult unul apare impar, se poate forma un palindrom (afişăm \"DA\"), altfel se afișează \"NU\".\n\n---\n\nAcestea sunt soluţiile complete, cu explicaţii detaliate şi cod în C++ pentru fiecare exerciţiu.",
                    "role": "assistant"
                }
            }
        ],
        "created": 1743402582,
        "usage": {
            "completion_tokens": 15156,
            "prompt_tokens": 2465,
            "total_tokens": 17621,
            "cache_read_input_tokens": 0
        }
    },
    "temp": 0.0,
    "results": {
        "I": {
            "1": "Analiză:   Trebuie evaluată expresia „3 + 5.0/2 + 2” în C/C++. Deoarece 5.0 este număr real, operaţia de împărţire se efectuează în virgulă mobilă. Calculul se face astfel:     5.0/2 = 2.5     3 + 2.5 + 2 = 7.5  Strategie pas cu pas:   1. Se efectuează împărţirea 5.0/2 → 2.5.   2. Se adună 3 și 2 → 5.   3. Apoi se adaugă 2.5 → 7.5.  Răspuns final: 7.5 – varianta d.  ```cpp #include <iostream> using namespace std;   int main(){     // Calcularea expresiei 3 + 5.0/2 + 2     double rezultat = 3 + 5.0/2 + 2;     cout << \"Rezultatul este: \" << rezultat << endl;  // Afișează 7.5     return 0; } ```",
            "2": "Analiză:   Avem un tablou v cu 4 elemente și un subprogram f definit recursiv astfel:    – Dacă indicele i e cel din dreapta (i>=3) se actualizează elementul (v[3] devine v[3]+1) și se afișează.    – Altfel, se apelează f(i+1, v) iar după revenire se afișează v[i].   Apelul f(0, v) va afişa elementele în ordine: f(3) → f(2) → f(1) → f(0).   Dacă notăm iniţial v = {a, b, c, d}, atunci:    – Pentru i = 3: se face d = d + 1 şi se afișează (valoarea devine prima cifră a şirului afişat).    – Rezultatul final concatenat trebuie să fie „2020”.   Deci trebuie ca:     d+1 = 2 → d = 1     c = 0     b = 2     a = 0   Deci tabloul este {0, 2, 0, 1}.  Strategie pas cu pas:   1. Stabiliţi condiţiile impuse de afişare, având în vedere ordinea recursivă.   2. Se rezolvă ecuaţiile pentru a, b, c, d.  Răspuns final: v = {0, 2, 0, 1} – varianta b.  ```cpp #include <iostream> using namespace std;   void f(int i, int v[4]){     if(i >= 3) {         v[i] = v[i] + 1;     }     else {         f(i+1, v);     }     cout << v[i]; }   int main(){     int v[4] = {0, 2, 0, 1}; // Setarea valorilor astfel încât f(0, v) să afișeze \"2020\"     f(0, v);     return 0; } ```",
            "3": "Analiză:   Se generează prin backtracking toate quadruplele (sume în lei, multipli de 10, nenule) care îndeplinesc:     suma = 200, şi     prima > a doua > a treia > a patra.   Primele patru soluţii generate sunt:     (70, 60, 40, 30), (70, 60, 50, 20), (80, 50, 40, 30) şi (80, 60, 40, 20).   Se deduce că metoda de parcurgere a posibilităţilor – probabil prin iterarea valorii “a” de la valorile mici spre mari şi, la interior, iterarea “b”, apoi „c” şi „d” – va genera ulterior şi (80, 60, 50, 10) şi apoi (80, 70, 40, 10).   Comparând cu opţiunile date, singura variantă care corespunde fiind (80, 70, 40, 10).  Strategie pas cu pas:   1. Notaţi că transformând sumele în “zeci” avem:     (7,6,4,3), (7,6,5,2), (8,5,4,3), (8,6,4,2), (8,6,5,1) și (8,7,4,1).   2. Conform ordinii de generare date, cea de-a șasea soluţie este (8,7,4,1) ce corespunde (80, 70, 40, 10).  Răspuns final: (80, 70, 40, 10) – varianta d.",
            "4": "Analiză:   Avem un arbore cu 10 noduri reprezentat prin vectorul de “tați”:     (7, 5, 6, 5, 7, 0, 6, 3, 3, 8)   Interpretare: elementul de pe poziţia i este tatăl nodului i+1. Nodul cu valoare 0 este rădăcina.   Construim lista de copii:    – Nod 1 (tată 7)  → copil al nodului 7    – Nod 2 (tată 5)  → copil al nodului 5    – Nod 3 (tată 6)  → copil al nodului 6    – Nod 4 (tată 5)  → copil al nodului 5    – Nod 5 (tată 7)  → copil al nodului 7    – Nod 6 (tată 0)  → rădăcină    – Nod 7 (tată 6)  → copil al nodului 6    – Nod 8 (tată 3)  → copil al nodului 3    – Nod 9 (tată 3)  → copil al nodului 3    – Nod 10 (tată 8) → copil al nodului 8   Determinăm nodurile care nu apar ca tată (nu au copii):    – Nod 1: nu are copii    – Nod 2: nu are copii    – Nod 4: nu are copii    – Nod 9: nu are copii    – Nod 10: nu are copii  Strategie pas cu pas:   1. Se listează toate nodurile şi se identifică pe cele care nu sunt “tați”.   2. Se numără nodurile frunză.  Răspuns final: 5 noduri – varianta c.",
            "5": "Analiză:   Avem un graf neorientat cu 5 noduri şi 5 muchii (determinate din matricea de adiacență):     Muchiile sunt: 1–2, 1–4, 1–5, 2–3 şi 3–4.   Se consideră grafurile parţiale conexe – adică subgrafuri cu acelaşi set de noduri şi cu o mulțime de muchii, care sunt conexe, diferite de graful dat (care are toate 5 muchiile).   Observaţie: Un graf conex cu 5 noduri are cel puţin 4 muchii (arborele de acoperire).   Calculăm:    – Există 4 submulţimi de 4 muchii (spanning trees) care sunt conecte (calculând prin eliminarea fiecărei muchii, se verifică dacă se obţine un arbore conex – s-a obţinut 4 soluţii valide).    – Submulţimea de 5 muchii este graful dat şi se exclude.    Strategie pas cu pas:   1. Enumerăm toate submulţimile de muchii şi selectăm cele care dau un graf conex.   2. Se observă că singurele grafuri parţiale conexe diferite de graful dat sunt cele 4 arbore de acoperire.  Răspuns final: 4 grafuri – varianta a."
        },
        "II": {
            "1": "Analiză:   Avem un algoritm care, pentru un număr natural a citit de la tastatură, parcurge, pentru c = 0, 2, 4, 6, 8, cifrele lui a (de la dreapta la stânga) şi dacă găseşte cel puţin o cifră egală cu c, setează x=1; altfel rămâne x=0. Se afișează valoarea lui x pentru fiecare c şi se incrementează c cu 2, până când c > 9.   Trebuie să rezolvăm patru subpuncte:  a) Simularea algoritmului pentru a = 240107.   b) Găsirea celui mai mic şi celui mai mare număr din intervalul [10^5, 10^6) cu cifre distincte, care, la rularea algoritmului, au toate valorile afişate nenule.   c) Scrierea programului în C/C++ corespunzător.   d) Rescrierea algoritmului folosind o altă structură repetitivă pentru a doua buclă.   a) Simulare pentru a = 240107  Se parcurge pentru c = 0, 2, 4, 6 și 8:  • Pentru c = 0:    Se parcurg cifrele numărului de la dreapta: 7, 0, ...    Când se întâlneşte cifra 0, x devine 1.    Afișare: 1  • Pentru c = 2:    Cifrele: 7, 0, 1, 0, 4, 2 → se găseşte 2.    Afișare: 1  • Pentru c = 4:    Cifrele: 7, 0, 1, 0, 4 → se găseşte 4.    Afișare: 1  • Pentru c = 6:    Cifrele: 7, 0, 1, 0, 4, 2 – niciun 6.    Afișare: 0  • Pentru c = 8:    Parcurgerea similară nu găseşte 8.    Afișare: 0  Valorile afişate sunt: 1 1 1 0 0   b) Pentru ca fiecare valoare afișată să fie nenul (adică pentru fiecare c, s-a găsit apare o cifră egală cu c), numărul citit trebuie să conţină cel puţin o cifră 0, 2, 4, 6 şi 8.   Din intervalul [10^5, 10^6) avem numere formate din 6 cifre, cu toate cifrele distincte.   Cel mai mic număr care conţine obligatoriu cifrele 0, 2, 4, 6, 8 şi o altă cifră suplimentară (care va fi 1 pentru minim) se poate forma ordonând cifrele în ordine crescătoare, dar având cifra 0 plasată pe poziția care nu este prima (deoarece numărul nu poate începe cu 0).   Astfel, cel mai mic număr este: 102468   Similar, cel mai mare număr se obţine folosind cifrele {0,2,4,6,8,9} în ordine descrescătoare, obţinând: 986420   c) Programul C/C++ pentru algoritmul dat:  ```cpp #include <iostream> using namespace std;   int main(){     unsigned int a;     cin >> a;  // Citim numărul natural     int c = 0;     // Se repetă pentru c = 0,2,4,6,8 (c <= 9)     do {         int b = a;         int x = 0;  // x va deveni 1 dacă se găsește cifra c         // Parcurgem cifrele lui b (de la dreapta la stânga)         do {             if(b % 10 == c)                 x = 1;             b = b / 10;  // Partea întreagă după împărţire la 10         } while(b != 0 && x == 0);           cout << x << \" \";         c = c + 2;     } while(c <= 9);       return 0; } ```   d) Variante în pseudocod cu înlocuirea structurii repetitivă (a doua buclă) cu o structură de tip while:  Pseudocodul echivalent:  Algoritm:   c ← 0     repeat       b ← a       x ← 0       while (b ≠ 0 and x = 0) do         if (b % 10 = c) then x ← 1         b ← [b/10]       end while       scrie x, \" \"       c ← c + 2     until (c > 9)",
            "2": "Analiză:   Variabila c memorează informaţii despre un calculator:     – c.monitor – o literă (tipul monitorului)     – c.memorie – o structură care conţine:       c.memorie.interna – capacitatea memoriei interne (număr natural din [1,10^6])       c.memorie.externa – capacitatea memoriei externe (număr natural din [1,10^6])  Strategie pas cu pas:   1. Definirea structurii externe (ex: struct Memorie) şi apoi a structurii calculator.   2. Declararea variabilei c de tip calculator.  Răspuns final:  ```cpp #include <iostream> using namespace std;   // Definim o structură pentru memorie struct Memorie {     unsigned int interna; // capacitatea memoriei interne     unsigned int externa; // capacitatea memoriei externe };   // Structura calculator struct Calculator {     char monitor;   // litera ce indică tipul monitorului     Memorie memorie; };   int main(){     // Declarația variabilei c de tip Calculator     Calculator c;          // Exemplu de inițializare (se poate citi de la tastatură)     c.monitor = 'A';     c.memorie.interna = 500;   // exemplu: 500 GB     c.memorie.externa = 120;    // exemplu: 120 GB          cout << \"Monitor: \" << c.monitor << \"\\nMemorie interna: \" << c.memorie.interna           << \"\\nMemorie externa: \" << c.memorie.externa << endl;     return 0; } ```",
            "3": "Analiză:   Avem un tablou bidimensional a cu 9 linii şi 9 coloane, iniţial cu elementele '='. Trebuie să se modifice elementele tabloului astfel încât, la final, acesta să aibă forma:    Linia 1: > > > > > > > > >     Linia 2: > > > > > > > > >     Linia 3: > > > > > > > > >     Linia 4: > > > > > > > > >     Linia 5: > > > > > > > > >     Linia 6: > > > < > > > > >     Linia 7: > > < < < > > > >     Linia 8: > < < < < < > > >     Linia 9: < < < < < < < > >  Strategie pas cu pas:   Identificăm poziţiile în care înlocuim simbolul '=' cu '<', celelalte rămân '>'.   Observaţi:   – Pentru liniile 0–4 (primele 5 linii, indexate de la 0) se păstrează '>'.   – Pentru linia 5 (i = 5): se pune '<' doar la coloana 3.   – Pentru linia 6 (i = 6): se pun '<' la coloanele 2, 3 şi 4.   – Pentru linia 7 (i = 7): se pun '<' la coloanele 1 până la 5.   – Pentru linia 8 (i = 8): se pun '<' la coloanele 0 până la 6.  Răspuns final: Comanda necesară se poate scrie astfel:  ```cpp #include <iostream> using namespace std;   int main(){     char a[9][9];     int i, j;          // Inițializare cu '=' (deşi se poate porni cu orice valoare, dar se va suprascrie)     for(i = 0; i < 9; i++)         for(j = 0; j < 9; j++)             a[i][j] = '=';          // Modificare conform modelului cerut     for(i = 0; i < 9; i++){         for(j = 0; j < 9; j++){             if(i < 5){                 a[i][j] = '>';             }             else if(i == 5){                 if(j == 3)                     a[i][j] = '<';                 else                     a[i][j] = '>';             }             else if(i == 6){                 if(j >= 2 && j <= 4)                     a[i][j] = '<';                 else                     a[i][j] = '>';             }             else if(i == 7){                 if(j >= 1 && j <= 5)                     a[i][j] = '<';                 else                     a[i][j] = '>';             }             else if(i == 8){                 if(j <= 6)                     a[i][j] = '<';                 else                     a[i][j] = '>';             }         }     }          // Afișarea tabloului     for(i = 0; i < 9; i++){         for(j = 0; j < 9; j++){             cout << a[i][j] << \" \";         }         cout << endl;     }          return 0; } ```  Observație: Secvența de completat în bucla dublă poate fi obţinută prin blocul de condiţii if–else prezentat."
        },
        "III": {
            "1": "Analiză:   Subprogramul \"suma\" primeşte doi parametri naturali a şi b (din intervalul [1,10^4]) şi trebuie să returneze suma tuturor divizorilor comuni ai lui a şi b.   Observaţie: Orice divizor comun al lui a şi b divizează şi pe gcd(a, b). De aceea, se poate calcula gcd-ul şi apoi suma divizorilor lui gcd.   Strategie pas cu pas:   1. Se calculează gcd-ul lui a şi b.   2. Se parcurge de la 1 la √g şi se adaugă divizorii (atenţie la dublare, dacă divisorul este pătratul perfect).  Răspuns final:  ```cpp #include <iostream> #include <cmath> using namespace std;   // Funcție pentru calculul celui mai mare divizor comun (gcd) int gcd(int a, int b){     while(b){         int temp = b;         b = a % b;         a = temp;     }     return a; }   // Subprogramul suma: returnează suma divizorilor comuni ai lui a și b int suma(int a, int b){     int g = gcd(a, b);     int s = 0;     // Parcurgem divizorii lui g     for(int d = 1; d <= sqrt(g); d++){         if(g % d == 0){             s += d;             if(d != g/d)                 s += g/d;         }     }     return s; }   int main(){     int a, b;     cin >> a >> b;     cout << \"Suma divizorilor comuni este: \" << suma(a, b) << endl;     return 0; } ```  Exemplu: pentru a=20 şi b=12, gcd(20,12)=4, iar divizorii lui 4 sunt 1, 2, 4; suma = 7.",
            "2": "Analiză:   Avem de citit un text cu cel mult 100 de caractere, conţinând cuvinte formate din litere mici ale alfabetului englez şi separate prin spațiu.   Se aplică operaţia de rotire spre stânga pentru fiecare cuvânt format din cel puțin trei litere: prima literă se mută la final, iar celelalte se deplasează cu o poziţie spre stânga.   Dacă în text nu există niciun cuvânt cu cel puțin trei litere se va afișa mesajul \"nu exista\".  Strategie pas cu pas:   1. Se citeşte linia de text.   2. Se împarte textul în cuvinte (folosind spaţiul ca separator).   3. Pentru fiecare cuvânt cu lungime ≥ 3, se realizează rotirea (noul cuvânt = subşirul de la a doua literă până la sfârşit + prima literă).   4. Se formează textul modificat.   5. Dacă niciun cuvânt nu îndeplinește criteriul, se afișează \"nu exista\".  Răspuns final:  ```cpp #include <iostream> #include <sstream> #include <string> using namespace std;   int main(){     string text, cuvant;     getline(cin, text); // Citim textul întreg     istringstream iss(text);     string rezultat = \"\";     bool aFostModificat = false;          while(iss >> cuvant){         if(cuvant.length() >= 3){             // Rotirea spre stânga: se mută prima literă la sfârșit             cuvant = cuvant.substr(1) + cuvant[0];             aFostModificat = true;         }         rezultat += cuvant + \" \";     }          if(aFostModificat)         cout << rezultat;     else         cout << \"nu exista\";          return 0; } ```  Exemplu:   Pentru textul:     \"un palc mic de scolarite ilumina sala\"   Se obţine:     \"un alcp icm de colarites luminai alas\"",
            "3": "Analiză:   Trebuie să determinăm dacă numerele dintr‑un şir (din fişierul bac.in) pot fi rearanjate astfel încât să formeze un șir palindromic.   Idee:   Un şir poate fi rearanjat într‑un palindrom dacă cel mult un element apare un număr impar de ori (în cazul numerelor cu număr impar de apariţii, acesta va fi plasat în mijloc).   Strategie pentru eficienţă:   1. Citiți numerele şi țineți un contor (frecvenţa) pentru fiecare număr (fiindcă numerele sunt din intervalul [1,10^3], putem folosi un tablou de 1001 elemente).   2. Se numără câte valori apar de un număr impar de ori.   3. Dacă numărul de valori cu frecvenţă impară este cel mult 1, atunci se poate forma un palindrom; altfel, nu se poate.  a) Descriere în limbaj natural:     Se parcurge şirul de numere şi se calculează frecvenţa de apariţie pentru fiecare număr.     Un şir poate forma un palindrom dacă, în cazul unui şir cu un număr par de elemente, toate numerele apar de un număr par de ori; iar în cazul unui şir cu număr impar de elemente, exact unul dintre numere poate avea frecvenţă impară.     Această abordare este O(n) la timp, folosind un tablou de frecvenţă de dimensiune fixă (1001), deci este foarte eficientă.  b) Programul C/C++:  ```cpp #include <iostream> #include <fstream> using namespace std;   int main(){     ifstream fin(\"bac.in\");     int num;     // Datele sunt din intervalul [1,10^3], deci folosim un tablou de 1001 elemente     int freq[1001] = {0};       // Citim numerele din fișier     while(fin >> num){         freq[num]++;     }     fin.close();       int imparCount = 0;     for(int i = 1; i <= 1000; i++){         if(freq[i] % 2 != 0)             imparCount++;     }          if(imparCount <= 1)         cout << \"DA\";     else         cout << \"NU\";       return 0; } ```  Explicaţie:   – Se citeşte fiecare număr şi se actualizează frecvenţa.   – Se verifică câte numere apar de un număr impar de ori.   – Dacă cel mult unul apare impar, se poate forma un palindrom (afişăm \"DA\"), altfel se afișează \"NU\".   Acestea sunt soluţiile complete, cu explicaţii detaliate şi cod în C++ pentru fiecare exerciţiu."
        }
    },
    "barem_url": "https://info-hobby.ro/wp-content/uploads/2020/06/E_d_Informatica_2020_sp_MI_bar_06.pdf",
    "exam": {
        "title": "o3mini",
        "subject": "Informatica",
        "categories": [
            "Filiera teoretică - Profilul real"
        ]
    }
}