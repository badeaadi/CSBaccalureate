{
    "solutions_gpt4o_0.2": "## Subject I - Exercise 1\n### Problem Analysis\nTrebuie să determinăm valoarea expresiei C/C++ `3+5.0/2+2`.\n\n### Solution Approach\n1. Evaluăm expresia pas cu pas:\n   - `5.0/2` este o împărțire între un număr real și un număr întreg, rezultând `2.5`.\n   - `3 + 2.5` este `5.5`.\n   - `5.5 + 2` este `7.5`.\n\n### Answer\nd. 7.5\n\n---\n\n## Subject I - Exercise 2\n### Problem Analysis\nAvem un subprogram recursiv `f` care modifică și afișează elementele unui tablou `v` de 4 elemente. Trebuie să identificăm setul de elemente care, la apelul `f(0,v)`, afișează `2020`.\n\n### Solution Approach\n1. Analizăm funcția `f`:\n   - Dacă `i >= 3`, incrementăm `v[i]`.\n   - Altfel, apelăm recursiv `f(i+1,v)`.\n   - Afișăm `v[i]`.\n2. Pentru a obține `2020`, trebuie ca `v[3]` să fie incrementat și să fie `2` înainte de incrementare. `v[2]` trebuie să fie `0`, `v[1]` să fie `2`, și `v[0]` să fie `0`.\n\n### Answer\na. -1,1,0,2\n\n---\n\n## Subject I - Exercise 3\n### Problem Analysis\nSe generează variante de plată pentru patru persoane, cu condiții specifice. Trebuie să identificăm a șasea soluție generată.\n\n### Solution Approach\n1. Folosim metoda backtracking pentru a genera soluțiile:\n   - Fiecare sumă este nenulă și divizibilă cu 10.\n   - Sumele respectă ordinea: primul > al doilea > al treilea > al patrulea.\n2. Continuăm de la soluțiile date și generăm următoarele:\n   - (80, 60, 50, 10) este a cincea soluție.\n   - (80, 70, 40, 10) este a șasea soluție.\n\n### Answer\nd. (80, 70, 40, 10)\n\n---\n\n## Subject I - Exercise 4\n### Problem Analysis\nAvem un arbore reprezentat prin vectorul de „tați” și trebuie să determinăm numărul de noduri „frunză”.\n\n### Solution Approach\n1. Identificăm nodurile frunză:\n   - Un nod este frunză dacă nu este tată pentru niciun alt nod.\n2. Analizăm vectorul (7,5,6,5,7,0,6,3,3,8):\n   - Nodurile care nu apar ca „tați” sunt frunze: 1, 2, 4, 9, 10.\n\n### Answer\nc. 5\n\n---\n\n## Subject I - Exercise 5\n### Problem Analysis\nAvem un graf neorientat reprezentat prin matricea de adiacență și trebuie să determinăm numărul grafurilor parțiale conexe diferite de graful dat.\n\n### Solution Approach\n1. Determinăm componentele conexe ale grafului:\n   - Folosim matricea de adiacență pentru a identifica componentele.\n2. Calculăm numărul de subgrafuri conexe:\n   - Excludem graful complet și calculăm subgrafurile conexe.\n\n### Answer\nb. 6\n\n---\n\n## Subject II - Exercise 1\n### Problem Analysis\nAlgoritmul dat în pseudocod trebuie analizat pentru a determina valorile afișate și a scrie programul corespunzător în C/C++.\n\n### Solution Approach\na. Calculăm valorile afișate pentru numărul 240107:\n   - Pentru fiecare valoare a lui `c` (0, 2, 4, 6, 8), verificăm dacă există o cifră în `a` care este egală cu `c`.\n   - Afișăm `1` dacă există, `0` dacă nu.\n\nb. Determinăm numerele din intervalul [105,106) cu cifre distincte care afișează toate valorile nenule:\n   - Cel mai mic număr: 102345\n   - Cel mai mare număr: 987654\n\nc. Scriem programul C/C++ corespunzător:\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a;\n    cin >> a;\n    int c = 0;\n    do {\n        int b = a, x = 0;\n        do {\n            if (b % 10 == c) x = 1;\n            b /= 10;\n        } while (b != 0 && x != 1);\n        cout << x << ' ';\n        c += 2;\n    } while (c <= 9);\n    return 0;\n}\n```\n\nd. Scriem algoritmul echivalent în pseudocod:\n```\ncitește a (număr natural)\nc ← 0\nrepetă\n    b ← a; x ← 0\n    cât timp b ≠ 0 și x ≠ 1 execută\n        dacă b%10 = c atunci\n            x ← 1\n        b ← [b/10]\n    scrie x, ' '\n    c ← c + 2\npână când c > 9\n```\n\n---\n\n## Subject II - Exercise 2\n### Problem Analysis\nTrebuie să definim o structură care să memoreze capacitatea memoriei și tipul monitorului pentru un calculator.\n\n### Solution Approach\n1. Definim structura `calculator` cu câmpurile necesare:\n   - `monitor` pentru litera tipului monitorului.\n   - `memorie.interna` și `memorie.externa` pentru capacitățile memoriei.\n\n### Answer\n```cpp\nstruct calculator {\n    char monitor;\n    unsigned int memorie_interna;\n    unsigned int memorie_externa;\n};\n\ncalculator c;\n```\n\n---\n\n## Subject II - Exercise 3\n### Problem Analysis\nTrebuie să completăm secvența de cod pentru a modifica un tablou bidimensional astfel încât să obținem un model specific.\n\n### Solution Approach\n1. Observăm modelul dorit și identificăm condițiile pentru fiecare element:\n   - Elementele din partea de sus sunt `>`.\n   - Elementele din partea de jos sunt `<`.\n2. Implementăm condițiile în bucla `for`.\n\n### Code Solution\n```cpp\nfor(i=0;i<9;i++)\n    for(j=0;j<9;j++)\n        if (i < 5 || (i == 5 && j != 5) || (i == 6 && j < 5) || (i == 7 && j < 6) || (i == 8 && j < 7))\n            a[i][j] = '>';\n        else\n            a[i][j] = '<';\n```\n\n---\n\n## Subject III - Exercise 1\n### Problem Analysis\nTrebuie să scriem un subprogram care returnează suma divizorilor comuni ai două numere naturale.\n\n### Solution Approach\n1. Calculăm divizorii comuni:\n   - Iterăm de la 1 la minimul dintre `a` și `b`.\n   - Verificăm dacă un număr este divizor comun și adăugăm la sumă.\n\n### Code Solution\n```cpp\nint suma(int a, int b) {\n    int sum = 0;\n    int limit = min(a, b);\n    for (int i = 1; i <= limit; i++) {\n        if (a % i == 0 && b % i == 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}\n```\n\n---\n\n## Subject III - Exercise 2\n### Problem Analysis\nTrebuie să rotim spre stânga fiecare cuvânt dintr-un text care are cel puțin trei litere.\n\n### Solution Approach\n1. Citim textul și separăm cuvintele.\n2. Pentru fiecare cuvânt cu cel puțin trei litere, aplicăm rotirea.\n3. Afișăm textul modificat sau mesajul `nu exista`.\n\n### Code Solution\n```cpp\n#include <iostream>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    string text;\n    getline(cin, text);\n    stringstream ss(text);\n    string word;\n    vector<string> words;\n    bool exists = false;\n\n    while (ss >> word) {\n        if (word.length() >= 3) {\n            exists = true;\n            word = word.substr(1) + word[0];\n        }\n        words.push_back(word);\n    }\n\n    if (exists) {\n        for (const auto& w : words) {\n            cout << w << ' ';\n        }\n    } else {\n        cout << \"nu exista\";\n    }\n\n    return 0;\n}\n```\n\n---\n\n## Subject III - Exercise 3\n### Problem Analysis\nTrebuie să determinăm dacă numerele din fișierul `bac.in` pot fi rearanjate pentru a forma un șir palindromic.\n\n### Solution Approach\n1. Citim numerele și calculăm frecvența fiecărui număr.\n2. Verificăm condiția pentru a forma un palindrom:\n   - Cel mult un număr poate avea o frecvență impară.\n3. Afișăm `DA` dacă condiția este îndeplinită, `NU` altfel.\n\n### Code Solution\n```cpp\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.in\");\n    unordered_map<int, int> freq;\n    int num;\n    while (fin >> num) {\n        freq[num]++;\n    }\n    fin.close();\n\n    int odd_count = 0;\n    for (const auto& pair : freq) {\n        if (pair.second % 2 != 0) {\n            odd_count++;\n        }\n    }\n\n    if (odd_count <= 1) {\n        cout << \"DA\";\n    } else {\n        cout << \"NU\";\n    }\n\n    return 0;\n}\n```\n\n---\n\nAcestea sunt soluțiile complete pentru exercițiile date. Dacă aveți întrebări suplimentare sau nevoie de clarificări, nu ezitați să întrebați!",
    "solutions_gemini20pro_0.2": "## Subiectul I - Exercițiul 1\n\n### Problemă Analiză\nTrebuie să evaluăm o expresie aritmetică C/C++, ținând cont de ordinea operațiilor și de conversia implicită a tipurilor de date.\n\n### Soluție Abordare\n1. Împărțirea 5.0 / 2 se efectuează prima, rezultând 2.5 (deoarece 5.0 este de tip double, rezultatul este de asemenea double).\n2. Se adună 3 + 2.5 + 2.\n3. Rezultatul final este 7.5.\n\n### Răspuns\nd. 7.5\n\n### Cod Soluție (nu este necesar)\n\n---\n\n## Subiectul I - Exercițiul 2\n\n### Problemă Analiză\nSe definește o funcție recursivă `f` care modifică un tablou unidimensional `v`. Trebuie să determinăm ce valori inițiale trebuie să aibă tabloul `v` astfel încât, după apelul `f(0, v)`, să se afișeze \"2020\".\n\n### Soluție Abordare\n1. Urmărim execuția recursivă a funcției:\n   - `f(0, v)`:  Se apelează `f(1, v)`.\n   - `f(1, v)`:  Se apelează `f(2, v)`.\n   - `f(2, v)`:  Se apelează `f(3, v)`.\n   - `f(3, v)`:  `v[3] = v[3] + 1`. Se afișează `v[3]`.\n   - `f(2, v)`:  Se afișează `v[2]`.\n   - `f(1, v)`:  Se afișează `v[1]`.\n   - `f(0, v)`:  Se afișează `v[0]`.\n\n2. Pentru a afișa \"2020\", trebuie să avem:\n   - `v[3]` (după incrementare) = 0  => `v[3]` inițial = -1\n   - `v[2]` = 2\n   - `v[1]` = 0\n   - `v[0]` = 2\n\n### Răspuns\nd. 2,0,1,0 -> devine 2, 0, 2, 0 dupa apel.\n\n### Cod Soluție (nu este necesar)\n\n---\n\n## Subiectul I - Exercițiul 3\n\n### Problemă Analiză\nSe generează prin backtracking toate combinațiile de patru sume (divizibile cu 10) care însumează 200, respectând condiția de ordine descrescătoare. Trebuie să identificăm a șasea soluție generată.\n\n### Soluție Abordare\n1. Enumerăm soluțiile generate, respectând regulile:\n   1. (70, 60, 40, 30)\n   2. (70, 60, 50, 20)\n   3. (80, 50, 40, 30)\n   4. (80, 60, 40, 20)\n   5. (80, 60, 50, 10)\n   6. (90, 50, 40, 20)\n\n### Răspuns\n Niciuna din variantele date nu este corecta. A 6-a solutie este (90, 50, 40, 20).\n\n### Cod Soluție (nu este necesar)\n\n---\n\n## Subiectul I - Exercițiul 4\n\n### Problemă Analiză\nSe dă un arbore reprezentat printr-un vector de tați. Trebuie să determinăm numărul de noduri frunză.\n\n### Soluție Abordare\n1. Un nod frunză este un nod care nu are copii. În vectorul de tați, un nod frunză este un nod care nu apare ca tată al niciunui alt nod.\n2. Analizăm vectorul de tați: (7, 5, 6, 5, 7, 0, 6, 3, 3, 8)\n3. Nodurile care apar ca tați sunt: 7, 5, 6, 3, 8.\n4. Nodurile care nu apar ca tați (și deci sunt frunze) sunt: 1, 2, 4, 9, 10.\n5. Numărul de noduri frunză este 5.\n\n### Răspuns\nc. 5\n\n### Cod Soluție (nu este necesar)\n\n---\n\n## Subiectul I - Exercițiul 5\n\n### Problemă Analiză\nSe dă un graf neorientat prin matricea de adiacență. Trebuie să determinăm numărul de grafuri parțiale conexe diferite de graful dat.\n\n### Soluție Abordare\n1. Un graf parțial se obține prin eliminarea unor muchii din graful original.\n2. Graful este conex.\n3. Graful dat are muchiile: (1,2), (1,4), (1,5), (2,3), (3,4).\n4.  Numaram cate muchii are graful: 5 muchii.\n5.  Un graf partial conex trebuie sa aiba cel putin n-1 muchii, unde n este numarul de noduri. In cazul nostru, cel putin 4 muchii.\n6. Graful dat are 5 muchii. Putem elimina maxim o muchie pentru a ramane conex.\n7.  Numarul de grafuri partiale conexe diferite de graful dat este egal cu numarul de muchii, adica 5.\n\n### Răspuns\na. 4 - Raspunsul corect este 5, niciuna din variante nu este corecta.\n\n### Cod Soluție (nu este necesar)\n\n---\n\n## Subiectul II - Exercițiul 1\n\n### Problemă Analiză\nTrebuie să analizăm un algoritm pseudocod, să determinăm ce afișează pentru o valoare de intrare dată, să găsim valori de intrare specifice și să scriem codul C++ și o variantă echivalentă a algoritmului.\n\n### a. Valori afișate pentru a = 240107\n\n### Soluție Abordare\nUrmărim execuția algoritmului pentru a = 240107:\n\n- c = 0\n- Repetă:\n  - b = 240107; x = 0\n  - Repetă:\n    - Dacă b % 10 == 0 (7 == 0 - fals)\n    - b = 24010\n    - Dacă b % 10 == 0 (0 == 0 - adevărat)\n      - x = 1\n    - Se iese din bucla interioara pentru ca x=1\n  - Scrie x (1)\n  - c = 2\n- Repetă:\n  - b = 240107; x = 0\n  - Repetă:\n    - Dacă b % 10 == 2 (7 == 2 - fals)\n    - ...\n    - b = 240;\n    - Dacă b%10 == 2 (0 == 2 - fals)\n    - b = 24\n    - Dacă b%10 == 2 (4 == 2 - fals)\n    - b = 2\n    - Dacă b%10 == 2 (2 == 2 - adevarat)\n      - x = 1\n  - Scrie x (1)\n  - c = 4\n- Repetă:\n  - b = 240107; x = 0\n  - Repetă:\n    - ...\n    - b = 24\n    - Dacă b%10 == 4 (4 == 4 - adevarat)\n      - x = 1\n  - Scrie x (1)\n  - c = 6\n- Repetă:\n  - b = 240107; x = 0\n    - ...\n    - b = 2\n    - Daca b%10 == 6 (2 == 6 - fals)\n  - Scrie x (0)\n  - c = 8\n- Repetă:\n    - b = 240107; x = 0\n    - ...\n    - b = 2\n    - Daca b%10 == 8 (2 == 8 - fals)\n  - Scrie x (0)\n  - c = 10\n- Se iese din bucla exterioara pentru ca c > 9\n\n### Răspuns\n1 1 1 0 0\n\n### b. Cel mai mic și cel mai mare număr\n\n### Soluție Abordare\nPentru ca toate valorile afișate să fie nenule (adică 1), fiecare cifră pară (0, 2, 4, 6, 8) trebuie să apară în număr.  Numărul trebuie să fie între 100000 (inclusiv) și 1000000 (exclusiv) și să aibă cifre distincte.\n\n- Cel mai mic: 102345\n- Cel mai mare: 987654\n\n### Răspuns\nCel mai mic: 102345\nCel mai mare: 987654\n\n### c. Program C++\n\n### Cod Soluție\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int a, b, c, x;\n    cin >> a;\n    c = 0;\n    do {\n        b = a;\n        x = 0;\n        do {\n            if (b % 10 == c) {\n                x = 1;\n            }\n            b = b / 10;\n        } while (b != 0 && x != 1);\n        cout << x << \" \";\n        c = c + 2;\n    } while (c <= 9);\n    cout << endl;\n    return 0;\n}\n```\n\n### d. Algoritm echivalent\n\n### Soluție Abordare\nPutem înlocui a doua structură `repetă...până când` cu o structură `cât timp...execută`.\n\n### Răspuns\n```\ncitește a (număr natural)\nc←0\n┌repetă\n│ b←a; x←0\n│┌cât timp b≠0 și x≠1 execută\n││┌dacă b%10=c atunci\n│││ x←1\n││└■\n││ b←[b/10]\n│└■\n│ scrie x,’ ’\n│ c←c+2\n└până când c>9\n```\n\n---\n\n## Subiectul II - Exercițiul 2\n\n### Problemă Analiză\nTrebuie să definim o structură C++ pentru a stoca date despre un calculator (capacitate memorie internă, externă și tip monitor).\n\n### Soluție Abordare\nDefinim o structură `calculator` cu câmpurile `monitor` (char), `memorie` (o sub-structură cu `interna` și `externa` - int).\n\n### Răspuns\n```cpp\nstruct memorie_struct {\n    int interna;\n    int externa;\n};\n\nstruct calculator {\n    char monitor;\n    memorie_struct memorie;\n};\n\ncalculator c;\n```\n\n### Cod Soluție\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nstruct memorie_struct {\n    int interna;\n    int externa;\n};\n\nstruct calculator {\n    char monitor;\n    memorie_struct memorie;\n};\n\nint main() {\n    calculator c;\n    c.monitor = 'A'; // Exemplu\n    c.memorie.interna = 8; // Exemplu\n    c.memorie.externa = 512; // Exemplu\n    cout << c.monitor << \" \" << c.memorie.interna << \" \" << c.memorie.externa << endl;\n    return 0;\n}\n```\n\n---\n\n## Subiectul II - Exercițiul 3\n\n### Problemă Analiză\nTrebuie să completăm o secvență de cod C++ care inițializează o matrice bidimensională cu anumite caractere, formând un model specific.\n\n### Soluție Abordare\nObservăm modelul din matrice:\n- Elementele de deasupra diagonalei secundare, inclusiv diagonala secundara, sunt '>'.\n- Elementele de sub diagonala secundara sunt '<'.\n- Diagonala secundara: i + j = n - 1 (unde n este dimensiunea matricei, in cazul nostru 9)\n\n### Răspuns\n```cpp\nif (i + j <= 8) {\n    a[i][j] = '>';\n} else {\n    a[i][j] = '<';\n}\n```\n\n### Cod Soluție\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    char a[9][9];\n    int i, j;\n\n    for (i = 0; i < 9; i++) {\n        for (j = 0; j < 9; j++) {\n            a[i][j] = '='; // Initializare cu '='\n        }\n    }\n\n    for (i = 0; i < 9; i++) {\n        for (j = 0; j < 9; j++) {\n            if (i + j <= 8) {\n                a[i][j] = '>';\n            } else {\n                a[i][j] = '<';\n            }\n        }\n    }\n\n    for (i = 0; i < 9; i++) {\n        for (j = 0; j < 9; j++) {\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```\n\n---\n\n## Subiectul III - Exercițiul 1\n\n### Problemă Analiză\nTrebuie să scriem o funcție C++ care primește două numere naturale și returnează suma divizorilor comuni ai acestora.\n\n### Soluție Abordare\n1. Parcurgem toți posibilii divizori de la 1 până la minimul dintre cele două numere.\n2. Pentru fiecare număr, verificăm dacă este divizor comun al ambelor numere.\n3. Dacă este divizor comun, îl adăugăm la sumă.\n\n### Răspuns\n```cpp\nint suma(int a, int b) {\n    int s = 0;\n    int min_val = (a < b) ? a : b;\n    for (int i = 1; i <= min_val; i++) {\n        if (a % i == 0 && b % i == 0) {\n            s = s + i;\n        }\n    }\n    return s;\n}\n```\n\n### Cod Soluție\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint suma(int a, int b) {\n    int s = 0;\n    int min_val = (a < b) ? a : b;\n    for (int i = 1; i <= min_val; i++) {\n        if (a % i == 0 && b % i == 0) {\n            s = s + i;\n        }\n    }\n    return s;\n}\n\nint main() {\n    cout << suma(20, 12) << endl; // Exemplu: 7\n    return 0;\n}\n```\n\n---\n\n## Subiectul III - Exercițiul 2\n\n### Problemă Analiză\nTrebuie să scriem un program C++ care citește un text, rotește spre stânga cuvintele de cel puțin trei litere și afișează textul modificat.\n\n### Soluție Abordare\n1. Citim textul.\n2. Parcurgem textul cuvânt cu cuvânt (delimitat de spații).\n3. Pentru fiecare cuvânt:\n   - Dacă lungimea cuvântului este >= 3:\n     - Rotim cuvântul spre stânga (mutăm primul caracter la final).\n   - Altfel, lăsăm cuvântul nemodificat.\n4. Afișăm textul modificat.\n\n### Răspuns\n```cpp\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nvoid roteste(char s[]) {\n    if (strlen(s) >= 3) {\n        char primaLitera = s[0];\n        for (int i = 0; i < strlen(s) - 1; i++) {\n            s[i] = s[i + 1];\n        }\n        s[strlen(s) - 1] = primaLitera;\n    }\n}\n\nint main() {\n    char text[101];\n    cin.getline(text, 101);\n\n    char* cuvant = strtok(text, \" \");\n    bool existaCuvinte = false;\n\n    while (cuvant != NULL) {\n        if (strlen(cuvant) >= 3) {\n            existaCuvinte = true;\n            roteste(cuvant);\n        }\n        cout << cuvant << \" \";\n        cuvant = strtok(NULL, \" \");\n    }\n    cout << endl;\n\n    if (!existaCuvinte)\n    {\n        cout << \"nu exista\" << endl;\n    }\n\n    return 0;\n}\n```\n\n### Cod Soluție\n(Codul de mai sus este și răspunsul)\n\n---\n\n## Subiectul III - Exercițiul 3\n\n### Problemă Analiză\nTrebuie să verificăm dacă un șir de numere poate fi rearanjat pentru a forma un palindrom.\n\n### Soluție Abordare\n1. Un șir poate fi rearanjat ca palindrom dacă și numai dacă există cel mult un număr care apare de un număr impar de ori.\n2. Folosim un vector de frecvență pentru a număra aparițiile fiecărui număr.\n3. Parcurgem vectorul de frecvență și numărăm câte numere au frecvență impară.\n4. Dacă numărul de frecvențe impare este <= 1, afișăm \"DA\", altfel afișăm \"NU\".\n\n### a. Descriere algoritm\n\nAlgoritmul este eficient deoarece parcurge șirul o singură dată pentru a construi vectorul de frecvență (complexitate O(n), unde n este numărul de elemente din șir) și apoi parcurge vectorul de frecvență (complexitate O(m), unde m este valoarea maximă din șir, care este constantă - 1000).  Complexitatea totală este O(n), ceea ce este eficient pentru n <= 10^6.\n\n### b. Program C++\n\n### Răspuns\n```cpp\n#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.in\");\n    int frecventa[1001] = {0};\n    int x;\n    while (fin >> x) {\n        frecventa[x]++;\n    }\n    fin.close();\n\n    int nrImpare = 0;\n    for (int i = 1; i <= 1000; i++) {\n        if (frecventa[i] % 2 != 0) {\n            nrImpare++;\n        }\n    }\n\n    if (nrImpare <= 1) {\n        cout << \"DA\" << endl;\n    } else {\n        cout << \"NU\" << endl;\n    }\n\n    return 0;\n}\n```\n\n### Cod Soluție\n(Codul de mai sus este și răspunsul)\n",
    "solutions_anthropicclaude37sonnet_0.2": "# Soluții pentru exercițiile de informatică\n\n## Subiectul I - Exercițiul 1\n### Analiza problemei\nTrebuie să evaluăm expresia C/C++ `3+5.0/2+2` respectând ordinea operațiilor.\n\n### Abordarea soluției\nÎn C/C++, operațiile se execută conform priorității: mai întâi împărțirea, apoi adunarea de la stânga la dreapta.\n- 5.0/2 = 2.5 (împărțire în virgulă mobilă)\n- 3+2.5+2 = 7.5\n\n### Răspuns\nRăspunsul corect este d. 7.5\n\n## Subiectul I - Exercițiul 2\n### Analiza problemei\nAvem un subprogram recursiv `f` care modifică un tablou și afișează elementele acestuia. Trebuie să determinăm valorile inițiale ale tabloului pentru a obține afișarea \"2020\".\n\n### Abordarea soluției\nAnalizăm funcția recursivă:\n- Dacă i>=3, se incrementează v[i] și apoi se afișează v[i]\n- Altfel, se apelează recursiv f(i+1,v) și apoi se afișează v[i]\n\nApelul inițial este f(0,v), deci execuția va fi:\n- f(0,v) apelează f(1,v)\n- f(1,v) apelează f(2,v)\n- f(2,v) apelează f(3,v)\n- f(3,v) incrementează v[3] și afișează v[3]\n- Revine la f(2,v) și afișează v[2]\n- Revine la f(1,v) și afișează v[1]\n- Revine la f(0,v) și afișează v[0]\n\nDeci afișarea va fi în ordinea: v[3]+1, v[2], v[1], v[0]\nPentru a obține \"2020\", avem nevoie ca aceste valori să fie 2, 0, 2, 0.\n\n### Răspuns\nPentru a obține afișarea \"2020\", tabloul inițial trebuie să fie: v = {0, 2, 0, 1}\nRăspunsul corect este b. 0,2,0,1\n\n## Subiectul I - Exercițiul 3\n### Analiza problemei\nSe generează prin backtracking toate variantele prin care 4 persoane pot plăti 200 lei, cu condiția ca sumele să fie divizibile cu 10, nenule, și în ordine strict descrescătoare.\n\n### Abordarea soluției\nPrimele patru soluții sunt: (70,60,40,30), (70,60,50,20), (80,50,40,30), (80,60,40,20).\nPentru a determina a șasea soluție, trebuie să identificăm a cincea soluție și apoi să o generăm pe următoarea.\n\nA cincea soluție ar fi (80,60,50,10).\nA șasea soluție ar fi următoarea configurație validă după aceasta.\n\n### Răspuns\nA șasea soluție este (80,70,30,20).\nRăspunsul corect este c. (80,70,30,20)\n\n## Subiectul I - Exercițiul 4\n### Analiza problemei\nAvem un arbore reprezentat prin vectorul de \"tați\" și trebuie să determinăm numărul de noduri frunză.\n\n### Abordarea soluției\nVectorul de tați este: (7,5,6,5,7,0,6,3,3,8)\n- Nodul 1 are tatăl 7\n- Nodul 2 are tatăl 5\n- Nodul 3 are tatăl 6\n- Nodul 4 are tatăl 5\n- Nodul 5 are tatăl 7\n- Nodul 6 are tatăl 0 (rădăcina)\n- Nodul 7 are tatăl 6\n- Nodul 8 are tatăl 3\n- Nodul 9 are tatăl 3\n- Nodul 10 are tatăl 8\n\nUn nod este frunză dacă nu este tatăl niciunui alt nod. Verificăm pentru fiecare nod dacă apare în vectorul de tați.\n\n### Răspuns\nNodurile frunză sunt: 1, 2, 4, 9, 10\nDeci sunt 5 noduri frunză.\nRăspunsul corect este c. 5\n\n## Subiectul I - Exercițiul 5\n### Analiza problemei\nAvem un graf neorientat cu 5 noduri reprezentat prin matricea de adiacență și trebuie să determinăm numărul de grafuri parțiale conexe diferite de graful dat.\n\n### Abordarea soluției\nUn graf parțial se obține eliminând una sau mai multe muchii din graful original, păstrând toate nodurile.\nPentru ca graful parțial să fie conex, trebuie să existe un drum între oricare două noduri.\n\nDin matricea de adiacență, identificăm muchiile grafului:\n(1,2), (1,4), (1,5), (2,3), (3,4)\n\nGraful are 5 muchii. Numărul total de grafuri parțiale este 2^5 = 32 (pentru fiecare muchie decidem dacă o păstrăm sau nu).\nDin acestea, trebuie să eliminăm:\n- Graful original (1 graf)\n- Grafurile neconexe\n- Grafurile care nu au nicio muchie (1 graf)\n\n### Răspuns\nNumărul de grafuri parțiale conexe diferite de graful dat este 30.\nRăspunsul corect este d. 30\n\n## Subiectul II - Exercițiul 1\n### Analiza problemei\nTrebuie să analizăm algoritmul dat în pseudocod și să răspundem la întrebările specifice.\n\n### Abordarea soluției\nAlgoritmul verifică pentru fiecare cifră pară de la 0 la 8 (c=0,2,4,6,8) dacă aceasta apare în numărul citit (a).\n\na) Pentru a=240107:\n- c=0: verifică dacă 0 apare în 240107 → da → afișează 1\n- c=2: verifică dacă 2 apare în 240107 → da → afișează 1\n- c=4: verifică dacă 4 apare în 240107 → da → afișează 1\n- c=6: verifică dacă 6 apare în 240107 → nu → afișează 0\n- c=8: verifică dacă 8 apare în 240107 → nu → afișează 0\n\nb) Pentru ca toate valorile afișate să fie nenule, numărul trebuie să conțină toate cifrele pare (0,2,4,6,8).\n- Cel mai mic număr din [10^5, 10^6) cu cifre distincte care conține toate cifrele pare: 102468\n- Cel mai mare număr din [10^5, 10^6) cu cifre distincte care conține toate cifrele pare: 986420\n\nc) Programul C++ corespunzător:\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, c = 0, b, x;\n    cin >> a;\n    \n    do {\n        b = a;\n        x = 0;\n        do {\n            if (b % 10 == c)\n                x = 1;\n            b = b / 10;\n        } while (b != 0 && x != 1);\n        \n        cout << x << \" \";\n        c += 2;\n    } while (c <= 9);\n    \n    return 0;\n}\n```\n\nd) Algoritmul echivalent, înlocuind a doua structură repetă...până când:\n\n```\ncitește a (număr natural)\nc←0\n┌repetă\n│ b←a; x←0\n│┌cât timp b≠0 și x≠1 execută\n││┌dacă b%10=c atunci\n│││ x←1\n││└■\n││ b←[b/10]\n│└■\n│ scrie x,' '\n│ c←c+2\n└până când c>9\n```\n\n### Răspuns\na) Valorile afișate pentru a=240107 sunt: 1 1 1 0 0\nb) Cel mai mic număr: 102468, cel mai mare număr: 986420\nc) Programul C++ este prezentat mai sus\nd) Algoritmul echivalent este prezentat mai sus\n\n## Subiectul II - Exercițiul 2\n### Analiza problemei\nTrebuie să definim o structură pentru un calculator care să conțină tipul monitorului și capacitatea memoriei (interne și externe).\n\n### Abordarea soluției\nDin expresiile date, observăm că avem nevoie de:\n- Un câmp pentru tipul monitorului (char)\n- O structură internă pentru memorie, cu două câmpuri: internă și externă (ambele int)\n\n### Răspuns\n```cpp\nstruct calculator {\n    char monitor;\n    struct {\n        int interna;\n        int externa;\n    } memorie;\n} c;\n```\n\n## Subiectul II - Exercițiul 3\n### Analiza problemei\nTrebuie să completăm o secvență de cod pentru a obține un tablou bidimensional cu un anumit model.\n\n### Abordarea soluției\nAnalizând tabloul rezultat, observăm că acesta conține simboluri \">\" și \"<\". Simbolul \"<\" apare doar în partea de jos-dreapta a tabloului, formând un model specific.\n\n### Răspuns\nSecvența completată:\n```cpp\nfor(i=0;i<9;i++)\n    for(j=0;j<9;j++)\n        if(i+j>=8) a[i][j]='<'; else a[i][j]='>';\n```\n\n## Subiectul III - Exercițiul 1\n### Analiza problemei\nTrebuie să definim un subprogram care returnează suma divizorilor comuni a două numere naturale.\n\n### Abordarea soluției\nPentru a găsi divizorii comuni ai două numere, vom itera de la 1 până la minimul dintre cele două numere și vom verifica pentru fiecare valoare dacă este divizor pentru ambele numere.\n\n### Răspuns\n```cpp\nint suma(int a, int b) {\n    int s = 0;\n    for (int i = 1; i <= min(a, b); i++) {\n        if (a % i == 0 && b % i == 0) {\n            s += i;\n        }\n    }\n    return s;\n}\n```\n\n## Subiectul III - Exercițiul 2\n### Analiza problemei\nTrebuie să transformăm un text prin rotirea spre stânga a fiecărui cuvânt format din cel puțin trei litere.\n\n### Abordarea soluției\nVom parcurge textul cuvânt cu cuvânt și vom aplica operația de rotire spre stânga pentru cuvintele care au cel puțin trei litere.\n\n### Răspuns\n```cpp\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n    char text[101], *p;\n    bool exista = false;\n    cin.getline(text, 101);\n    \n    p = strtok(text, \" \");\n    while (p != NULL) {\n        if (strlen(p) >= 3) {\n            exista = true;\n            char first = p[0];\n            for (int i = 0; i < strlen(p) - 1; i++) {\n                p[i] = p[i + 1];\n            }\n            p[strlen(p) - 1] = first;\n        }\n        cout << p << \" \";\n        p = strtok(NULL, \" \");\n    }\n    \n    if (!exista) {\n        cout << \"nu exista\";\n    }\n    \n    return 0;\n}\n```\n\n## Subiectul III - Exercițiul 3\n### Analiza problemei\nTrebuie să verificăm dacă numerele dintr-un șir pot fi rearanjate pentru a forma un șir palindromic.\n\n### Abordarea soluției\nUn șir poate fi rearanjat pentru a forma un palindrom dacă și numai dacă cel mult un număr apare de un număr impar de ori, iar toate celelalte apar de un număr par de ori.\n\na) Descrierea algoritmului:\n1. Citim numerele din fișier și numărăm frecvența fiecărui număr.\n2. Verificăm câte numere apar de un număr impar de ori.\n3. Dacă sunt cel mult un număr cu frecvență impară, atunci șirul poate fi rearanjat pentru a forma un palindrom.\n\nb) Programul C++:\n\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.in\");\n    int x, frecv[1001] = {0};\n    \n    // Citim numerele și numărăm frecvențele\n    while (fin >> x) {\n        frecv[x]++;\n    }\n    \n    // Numărăm câte numere au frecvență impară\n    int impare = 0;\n    for (int i = 1; i <= 1000; i++) {\n        if (frecv[i] % 2 == 1) {\n            impare++;\n        }\n    }\n    \n    // Verificăm condiția pentru palindrom\n    if (impare <= 1) {\n        cout << \"DA\";\n    } else {\n        cout << \"NU\";\n    }\n    \n    fin.close();\n    return 0;\n}\n```\n\n### Răspuns\na) Algoritmul este eficient deoarece:\n- Parcurge șirul o singură dată pentru a număra frecvențele\n- Folosește un vector de frecvență cu dimensiune fixă (1001)\n- Complexitatea este O(n), unde n este numărul de elemente din șir\n\nb) Programul C++ este prezentat mai sus."
}