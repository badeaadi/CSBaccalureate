{
    "gpt_model": "E_d_Informatica_2020_sp_MI_C_var_06_LRO",
    "gpt_response": {
        "id": "chatcmpl-a97dedd0-f23f-4f23-914e-93aeb5efb87d",
        "model": "gemini-2.0-pro-exp-02-05",
        "object": "chat.completion",
        "choices": [
            {
                "finish_reason": "STOP",
                "index": 0,
                "message": {
                    "content": "## Subiectul I - Exercitiul 1\n\n[Analiza problemei: Trebuie să evaluăm o expresie aritmetică simplă, respectând ordinea operațiilor.]\n[Strategia de rezolvare: Împărțirea are prioritate, apoi efectuăm adunările de la stânga la dreapta.]\n[Răspuns final: 3 + 5.0 / 2 + 2 = 3 + 2.5 + 2 = 5.5 + 2 = 7.5]\n```cpp\n// Nu este necesar cod C++ pentru această problemă.\n```\nRăspuns corect: d. 7.5\n\n---\n\n## Subiectul I - Exercitiul 2\n\n[Analiza problemei: Trebuie să determinăm starea inițială a unui vector, astfel încât, după apelul recursiv al unei funcții, să se afișeze \"2020\". Funcția incrementează elementul v[i] dacă i >= 3, altfel se autoapelează cu i+1. Afișarea se face în ordinea inversă a apelurilor recursive.]\n[Strategia de rezolvare: Urmărim invers apelurile recursive și deducem valorile inițiale.\n- f(0,v) afișează v[0] *după* ce restul apelurilor s-au încheiat. Deci v[0] trebuie să fie 2 la final.\n- f(1,v) afișează v[1] *după* ce f(2,v) și f(3,v) s-au încheiat. Deci v[1] trebuie să fie 0 la final.\n- f(2,v) afișează v[2] *după* ce f(3,v) s-a încheiat. Deci v[2] trebuie să fie 2 la final.\n- f(3,v) incrementează v[3] și apoi afișează v[3]. Deci v[3] trebuie să fie 0 la final, ceea ce înseamnă că a fost inițial -1 (pentru că este incrementat).\nDeoarece f(3,v) incrementează v[3], și v[3] final trebuie să fie 0, atunci v[3] inițial este -1.\nApelurile sunt: f(0,v) -> f(1,v) -> f(2,v) -> f(3,v).\nf(3,v): v[3] = v[3] + 1; cout << v[3];  // v[3] devine 0, se afiseaza 0\nf(2,v): cout << v[2]; // se afiseaza 2 => v[2] = 2\nf(1,v): cout << v[1]; // se afiseaza 0 => v[1] = 0\nf(0,v): cout << v[0]; // se afiseaza 2 => v[0] = 2\n]\n[Răspuns final: Vectorul inițial este 2, 0, 2, -1.]\n```cpp\n// Nu este necesar cod C++ pentru această problemă.\n```\nRăspuns corect: a. -1,1,0,2 - NU. Raspunsul corect este 2, 0, 2, -1, care nu se afla printre variantele date.\n\n---\n\n## Subiectul I - Exercitiul 3\n\n[Analiza problemei: Generarea prin backtracking a tuturor combinațiilor de 4 sume (divizibile cu 10) care adunate dau 200, cu condiția ca sumele să fie în ordine descrescătoare.]\n[Strategia de rezolvare: Analizăm soluțiile date și deducem regula de generare. Observăm că se încearcă maximizarea primei valori, apoi a celei de-a doua, etc.  Vom continua generarea manuală până ajungem la a șasea soluție.]\n[Răspuns final:\n1. (70, 60, 40, 30)\n2. (70, 60, 50, 20)\n3. (80, 50, 40, 30)\n4. (80, 60, 40, 20)\n5. (80, 60, 50, 10)\n6. (90, 50, 40, 20)\n]\n```cpp\n// Nu este necesar cod C++ pentru această problemă.\n```\nRăspuns corect: Niciuna dintre variantele date. Raspunsul corect este (90, 50, 40, 20). Varianta b. (80, 60, 50, 10) este a 5-a solutie.\n\n---\n\n## Subiectul I - Exercitiul 4\n\n[Analiza problemei: Dat fiind un vector de tați, trebuie să determinăm numărul de noduri frunză (noduri fără copii).]\n[Strategia de rezolvare: Un nod este frunză dacă nu apare ca tată pentru niciun alt nod. Parcurgem vectorul de tați și numărăm nodurile care nu apar în el.]\n[Răspuns final: Vectorul de tați: (7, 5, 6, 5, 7, 0, 6, 3, 3, 8).  Nodul 0 reprezintă rădăcina.\nTați: 7, 5, 6, 5, 7, 0, 6, 3, 3, 8\nNoduri: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\nFrunze: 1, 2, 4, 9, 10 (5 frunze) ]\n```cpp\n// Nu este necesar cod C++ pentru această problemă.\n```\nRăspuns corect: c. 5\n\n---\n\n## Subiectul I - Exercitiul 5\n\n[Analiza problemei: Dată fiind matricea de adiacență a unui graf neorientat, trebuie să determinăm numărul de grafuri parțiale conexe diferite de graful dat.]\n[Strategia de rezolvare: Un graf parțial se obține eliminând una sau mai multe muchii din graful original. Trebuie să numărăm câte astfel de grafuri rămân conexe (există un drum între oricare două noduri).\nGraful are muchiile: (1,2), (1,4), (1,5), (2,3), (3,4).\n1. Eliminam (1,5): conex\n2. Eliminam (1,2): conex\n3. Eliminam (1,4): conex\n4. Eliminam (2,3): conex\n5. Eliminam (3,4): conex\n6. Eliminam (1,5) si (1,2) : conex\n7. Eliminam (1,5) si (1,4) : conex\n8. Eliminam (1,5) si (2,3) : conex\n9. Eliminam (1,5) si (3,4) : conex\n10. Eliminam (1,2) si (1,4) : conex\n11. Eliminam (1,2) si (2,3) : conex\n12. Eliminam (1,2) si (3,4) : conex\n13. Eliminam (1,4) si (2,3) : conex\n14. Eliminam (1,4) si (3,4) : conex\n15. Eliminam (2,3) si (3,4) : conex\n...\nObservam ca daca eliminam o singura muchie, graful ramane conex. Sunt 5 muchii, deci 5 grafuri partiale conexe.\nDaca eliminam 2 muchii:\n- (1,2) si (3,4) - conex\n- (1,4) si (2,3) - conex\n- (1,5) si oricare alta - conex\nDeci, avem 5 grafuri cu o muchie eliminata + combinari de 5 luate cate 2 = 10, dar trebuie sa verificam daca raman conexe.\n]\n[Răspuns final: Graful are 5 muchii. Eliminând câte o muchie, graful rămâne conex, deci avem 5 grafuri parțiale conexe.\nDacă eliminăm două muchii, trebuie să verificăm conexitatea:\n- Eliminăm (1,2) și (1,4): conex.\n- Eliminăm (1,2) și (1,5): conex.\n- Eliminăm (1,2) și (2,3): conex.\n- Eliminăm (1,2) și (3,4): conex.\n- Eliminăm (1,4) și (1,5): conex.\n- Eliminăm (1,4) și (2,3): conex.\n- Eliminăm (1,4) și (3,4): conex.\n- Eliminăm (1,5) și (2,3): conex.\n- Eliminăm (1,5) și (3,4): conex.\n- Eliminăm (2,3) și (3,4): conex.\nToate combinatiile de 2 muchii eliminate lasa graful conex. Sunt 10 combinatii.\nDaca eliminam 3 muchii:\n(1,2), (1,4), (1,5) - raman (2,3), (3,4) - conex\n(1,2), (1,4), (2,3) - raman (1,5), (3,4) - conex\n...\nSe pare ca oricate muchii am elimina, mai putin pe toate, graful ramane conex.\nNumarul total de subgrafuri este 2^5 = 32.  Graful vid nu este conex. Graful initial este conex. Deci avem 32 - 1 - 1 = 30.\n]\n```cpp\n// Nu este necesar cod C++ pentru această problemă.\n```\nRăspuns corect: d. 30\n\n---\n\n## Subiectul al II-lea - Exercitiul 1\n\n### a.\n[Analiza problemei: Trebuie să urmărim execuția algoritmului pentru valoarea de intrare dată și să determinăm valorile afișate.]\n[Strategia de rezolvare: Executăm manual algoritmul, pas cu pas.]\n[Răspuns final:\na = 240107\nc = 0\n- b = 240107; x = 0\n  - b%10 == c (7 == 0) fals\n  - b = 24010; x = 0\n  - b%10 == c (0 == 0) adevarat; x = 1\n  - se iese din repetă\n- scrie x (1)\n- c = 2\n- b = 240107; x = 0\n  - b%10 == c (7 == 2) fals\n  - b = 24010; x = 0\n  - b%10 == c (0 == 2) fals\n  - b = 2401; x = 0\n  - b%10 == c (1 == 2) fals\n  - b = 240; x = 0\n  - b%10 == c (0 == 2) fals\n  - b = 24; x = 0\n  - b%10 == c (4 == 2) fals\n  - b = 2; x = 0\n  - b%10 == c (2 == 2) adevarat; x = 1\n  - se iese din repetă\n- scrie x (1)\n- c = 4\n- ...\n- c = 6\n- ...\n- c = 8\n- ...\nSe afiseaza: 1 1 0 1 0\n]\n```cpp\n// Nu este necesar cod C++ pentru acest subpunct.\n```\nRăspuns: 1 1 0 1 0\n\n### b.\n[Analiza: Trebuie să găsim cel mai mic și cel mai mare număr de 5 cifre distincte, în intervalul [10000, 100000), astfel încât algoritmul să afișeze numai valori nenule (adică 1).]\n[Strategie: Pentru ca algoritmul să afișeze numai 1, trebuie ca fiecare cifră pară (0, 2, 4, 6, 8) să fie prezentă în număr. Cel mai mic număr: 10246. Cel mai mare număr: 98642.]\n[Răspuns final: Cel mai mic: 10246. Cel mai mare: 98642.]\n```cpp\n// Nu este necesar cod C++ pentru acest subpunct.\n```\n\n### c.\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int a, b, c, x;\n    cin >> a;\n    c = 0;\n    do {\n        b = a;\n        x = 0;\n        do {\n            if (b % 10 == c) {\n                x = 1;\n            }\n            b = b / 10;\n        } while (b != 0 && x != 1);\n        cout << x << \" \";\n        c = c + 2;\n    } while (c <= 9);\n    cout << endl;\n    return 0;\n}\n```\n\n### d.\n[Analiza: Trebuie să înlocuim a doua structură `repetă...până când` cu o altă structură repetitivă.]\n[Strategie: Putem folosi `while`. Condiția de continuare a ciclului `while` este negația condiției de oprire a ciclului `do...while`.]\n[Răspuns final:]\n```pseudocod\ncitește a (număr natural)\nc←0\n┌repetă\n│ b←a; x←0\n│┌cât timp b≠0 și x≠1 execută\n││┌dacă b%10=c atunci\n│││ x←1\n││└■\n││ b←[b/10]\n│└■\n│ scrie x,’ ’\n│ c←c+2\n└până când c>9\n```\n\n---\n\n## Subiectul al II-lea - Exercitiul 2\n\n[Analiza: Trebuie să definim o structură `calculator` care conține câmpurile `monitor` (char) și `memorie` (o altă structură, cu câmpurile `interna` și `externa`, ambele int).]\n[Strategie: Definim structura imbricată `memorie`, apoi structura `calculator`.]\n[Răspuns final:]\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nstruct memorie {\n    int interna;\n    int externa;\n};\n\nstruct calculator {\n    char monitor;\n    memorie memorie;\n};\n\nint main() {\n    calculator c;\n    // Exemplu de utilizare (nu face parte din cerință):\n    c.monitor = 'L';\n    c.memorie.interna = 8;\n    c.memorie.externa = 512;\n\n    cout << c.monitor << \" \" << c.memorie.interna << \" \" << c.memorie.externa << endl;\n\n    return 0;\n}\n```\n\n---\n\n## Subiectul al II-lea - Exercitiul 3\n\n[Analiza: Trebuie să completăm o secvență de cod C++ care inițializează o matrice pătratică de 9x9, astfel încât să conțină caracterele '>' și '<' conform modelului dat.]\n[Strategie: Observăm că:\n- Primele 5 linii conțin doar '>'.\n- Linia 5: '<' pe coloana 4.\n- Linia 6: '<' pe coloanele 3, 4, 5.\n- Linia 7: '<' pe coloanele 2, 3, 4, 5, 6.\n- Linia 8: '<' pe coloanele 1, 2, 3, 4, 5, 6, 7.\nNumărul de caractere '<' crește cu 2 pe fiecare linie, începând de la linia 5.  Poziția primului '<' scade cu 1 pe fiecare linie.]\n[Răspuns final:]\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    char a[9][9];\n    int i, j;\n\n    for (i = 0; i < 9; i++) {\n        for (j = 0; j < 9; j++) {\n            if (i < 5) {\n                a[i][j] = '>';\n            } else {\n                if (j >= (9 - (i + 1)) / 2 && j < 9 - (9 - (i + 1)) / 2)\n                {\n                    a[i][j] = '<';\n                }\n                else\n                {\n                    a[i][j] = '>';\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < 9; i++)\n    {\n        for (j = 0; j < 9; j++)\n        {\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```\nAlternativ, o solutie mai simpla:\n```cpp\nfor(i=0;i<9;i++)\n for(j=0;j<9;j++)\n    if(i>=5 && j>=4-(i-5) && j<=4+(i-5))\n        a[i][j]='<';\n    else\n        a[i][j]='>';\n```\n\n---\n\n## Subiectul al III-lea - Exercitiul 1\n\n[Analiza: Trebuie să scriem un subprogram `suma` care primește doi parametri întregi și returnează suma divizorilor comuni ai acestora.]\n[Strategie: Calculăm cel mai mare divizor comun (cmmdc) al celor două numere, apoi iterăm de la 1 la cmmdc și adunăm divizorii comuni.]\n[Răspuns final:]\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint suma(int a, int b) {\n    int suma_divizori = 0;\n    int temp;\n\n    // Algoritmul lui Euclid pentru cmmdc\n    while (b != 0) {\n        temp = b;\n        b = a % b;\n        a = temp;\n    }\n    int cmmdc = a;\n\n    // Suma divizorilor comuni\n    for (int i = 1; i <= cmmdc; ++i) {\n        if (cmmdc % i == 0) {\n            suma_divizori += i;\n        }\n    }\n\n    return suma_divizori;\n}\n\nint main() {\n    cout << suma(20, 12) << endl; // Exemplu de apel: 7\n    return 0;\n}\n```\nO variantă mai eficientă, fără a calcula explicit CMMDC:\n```cpp\nint suma(int a, int b) {\n    int s = 0;\n    for (int d = 1; d <= a && d <= b; ++d) {\n        if (a % d == 0 && b % d == 0) {\n            s += d;\n        }\n    }\n    return s;\n}\n```\n\n---\n\n## Subiectul al III-lea - Exercitiul 2\n\n[Analiza: Trebuie să citim un text, să rotim spre stânga cuvintele de cel puțin 3 litere și să afișăm textul modificat.]\n[Strategie: Citim textul, parcurgem cuvintele, verificăm lungimea, rotim dacă e cazul, și afișăm.]\n[Răspuns final:]\n```cpp\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint main() {\n    char text[101], *cuvant;\n    char rezultat[101] = \"\";\n    bool exista = false;\n\n    cin.getline(text, 101);\n\n    cuvant = strtok(text, \" \");\n    while (cuvant != NULL) {\n        if (strlen(cuvant) >= 3) {\n            exista = true;\n            char primaLitera = cuvant[0];\n            for (int i = 0; i < strlen(cuvant) - 1; ++i) {\n                cuvant[i] = cuvant[i + 1];\n            }\n            cuvant[strlen(cuvant) - 1] = primaLitera;\n        }\n        strcat(rezultat, cuvant);\n        strcat(rezultat, \" \");\n        cuvant = strtok(NULL, \" \");\n    }\n\n    if (exista) {\n        cout << rezultat << endl;\n    } else {\n        cout << \"nu exista\" << endl;\n    }\n\n    return 0;\n}\n```\n\n---\n\n## Subiectul al III-lea - Exercitiul 3\n\n### a.\n[Analiza: Trebuie să verificăm dacă un șir de numere poate fi rearanjat pentru a forma un palindrom. Un șir poate fi rearanjat ca palindrom dacă și numai dacă cel mult un număr apare de un număr impar de ori.]\n[Strategie: Vom folosi un vector de frecvență pentru a număra aparițiile fiecărui număr. Apoi, vom număra câte numere au frecvență impară. Dacă acest număr este cel mult 1, afișăm \"DA\", altfel \"NU\". Această abordare este eficientă deoarece parcurgem șirul o singură dată pentru a construi vectorul de frecvență și apoi parcurgem vectorul de frecvență (care are o dimensiune maximă constantă, 1000) pentru a număra frecvențele impare. Complexitatea este O(n), unde n este lungimea șirului.]\n[Răspuns final: Descrierea algoritmului în limbaj natural, justificând eficiența.]\n\n### b.\n```cpp\n#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint main() {\n    ifstream fin(\"bac.in\");\n    int frecventa[1001] = {0}; // Inițializăm vectorul de frecvență cu 0\n    int numar;\n    int frecvente_impare = 0;\n\n    while (fin >> numar) {\n        frecventa[numar]++;\n    }\n\n    for (int i = 1; i <= 1000; ++i) {\n        if (frecventa[i] % 2 != 0) {\n            frecvente_impare++;\n        }\n    }\n\n    if (frecvente_impare <= 1) {\n        cout << \"DA\" << endl;\n    } else {\n        cout << \"NU\" << endl;\n    }\n\n    fin.close();\n    return 0;\n}\n```\n",
                    "role": "assistant"
                }
            }
        ],
        "created": 1743402625,
        "usage": {
            "completion_tokens": 5424,
            "prompt_tokens": 2604,
            "total_tokens": 8028
        }
    },
    "temp": 0.0,
    "results": {
        "I": {
            "1": "[Analiza problemei: Trebuie să evaluăm o expresie aritmetică simplă, respectând ordinea operațiilor.] [Strategia de rezolvare: Împărțirea are prioritate, apoi efectuăm adunările de la stânga la dreapta.] [Răspuns final: 3 + 5.0 / 2 + 2 = 3 + 2.5 + 2 = 5.5 + 2 = 7.5] ```cpp // Nu este necesar cod C++ pentru această problemă. ``` Răspuns corect: d. 7.5",
            "2": "[Analiza problemei: Trebuie să determinăm starea inițială a unui vector, astfel încât, după apelul recursiv al unei funcții, să se afișeze \"2020\". Funcția incrementează elementul v[i] dacă i >= 3, altfel se autoapelează cu i+1. Afișarea se face în ordinea inversă a apelurilor recursive.] [Strategia de rezolvare: Urmărim invers apelurile recursive și deducem valorile inițiale. - f(0,v) afișează v[0] *după* ce restul apelurilor s-au încheiat. Deci v[0] trebuie să fie 2 la final. - f(1,v) afișează v[1] *după* ce f(2,v) și f(3,v) s-au încheiat. Deci v[1] trebuie să fie 0 la final. - f(2,v) afișează v[2] *după* ce f(3,v) s-a încheiat. Deci v[2] trebuie să fie 2 la final. - f(3,v) incrementează v[3] și apoi afișează v[3]. Deci v[3] trebuie să fie 0 la final, ceea ce înseamnă că a fost inițial -1 (pentru că este incrementat). Deoarece f(3,v) incrementează v[3], și v[3] final trebuie să fie 0, atunci v[3] inițial este -1. Apelurile sunt: f(0,v) -> f(1,v) -> f(2,v) -> f(3,v). f(3,v): v[3] = v[3] + 1; cout << v[3];  // v[3] devine 0, se afiseaza 0 f(2,v): cout << v[2]; // se afiseaza 2 => v[2] = 2 f(1,v): cout << v[1]; // se afiseaza 0 => v[1] = 0 f(0,v): cout << v[0]; // se afiseaza 2 => v[0] = 2 ] [Răspuns final: Vectorul inițial este 2, 0, 2, -1.] ```cpp // Nu este necesar cod C++ pentru această problemă. ``` Răspuns corect: a. -1,1,0,2 - NU. Raspunsul corect este 2, 0, 2, -1, care nu se afla printre variantele date.",
            "3": "[Analiza problemei: Generarea prin backtracking a tuturor combinațiilor de 4 sume (divizibile cu 10) care adunate dau 200, cu condiția ca sumele să fie în ordine descrescătoare.] [Strategia de rezolvare: Analizăm soluțiile date și deducem regula de generare. Observăm că se încearcă maximizarea primei valori, apoi a celei de-a doua, etc.  Vom continua generarea manuală până ajungem la a șasea soluție.] [Răspuns final: 1. (70, 60, 40, 30) 2. (70, 60, 50, 20) 3. (80, 50, 40, 30) 4. (80, 60, 40, 20) 5. (80, 60, 50, 10) 6. (90, 50, 40, 20) ] ```cpp // Nu este necesar cod C++ pentru această problemă. ``` Răspuns corect: Niciuna dintre variantele date. Raspunsul corect este (90, 50, 40, 20). Varianta b. (80, 60, 50, 10) este a 5-a solutie.",
            "4": "[Analiza problemei: Dat fiind un vector de tați, trebuie să determinăm numărul de noduri frunză (noduri fără copii).] [Strategia de rezolvare: Un nod este frunză dacă nu apare ca tată pentru niciun alt nod. Parcurgem vectorul de tați și numărăm nodurile care nu apar în el.] [Răspuns final: Vectorul de tați: (7, 5, 6, 5, 7, 0, 6, 3, 3, 8).  Nodul 0 reprezintă rădăcina. Tați: 7, 5, 6, 5, 7, 0, 6, 3, 3, 8 Noduri: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 Frunze: 1, 2, 4, 9, 10 (5 frunze) ] ```cpp // Nu este necesar cod C++ pentru această problemă. ``` Răspuns corect: c. 5",
            "5": "[Analiza problemei: Dată fiind matricea de adiacență a unui graf neorientat, trebuie să determinăm numărul de grafuri parțiale conexe diferite de graful dat.] [Strategia de rezolvare: Un graf parțial se obține eliminând una sau mai multe muchii din graful original. Trebuie să numărăm câte astfel de grafuri rămân conexe (există un drum între oricare două noduri). Graful are muchiile: (1,2), (1,4), (1,5), (2,3), (3,4). 1. Eliminam (1,5): conex 2. Eliminam (1,2): conex 3. Eliminam (1,4): conex 4. Eliminam (2,3): conex 5. Eliminam (3,4): conex 6. Eliminam (1,5) si (1,2) : conex 7. Eliminam (1,5) si (1,4) : conex 8. Eliminam (1,5) si (2,3) : conex 9. Eliminam (1,5) si (3,4) : conex 10. Eliminam (1,2) si (1,4) : conex 11. Eliminam (1,2) si (2,3) : conex 12. Eliminam (1,2) si (3,4) : conex 13. Eliminam (1,4) si (2,3) : conex 14. Eliminam (1,4) si (3,4) : conex 15. Eliminam (2,3) si (3,4) : conex ... Observam ca daca eliminam o singura muchie, graful ramane conex. Sunt 5 muchii, deci 5 grafuri partiale conexe. Daca eliminam 2 muchii: - (1,2) si (3,4) - conex - (1,4) si (2,3) - conex - (1,5) si oricare alta - conex Deci, avem 5 grafuri cu o muchie eliminata + combinari de 5 luate cate 2 = 10, dar trebuie sa verificam daca raman conexe. ] [Răspuns final: Graful are 5 muchii. Eliminând câte o muchie, graful rămâne conex, deci avem 5 grafuri parțiale conexe. Dacă eliminăm două muchii, trebuie să verificăm conexitatea: - Eliminăm (1,2) și (1,4): conex. - Eliminăm (1,2) și (1,5): conex. - Eliminăm (1,2) și (2,3): conex. - Eliminăm (1,2) și (3,4): conex. - Eliminăm (1,4) și (1,5): conex. - Eliminăm (1,4) și (2,3): conex. - Eliminăm (1,4) și (3,4): conex. - Eliminăm (1,5) și (2,3): conex. - Eliminăm (1,5) și (3,4): conex. - Eliminăm (2,3) și (3,4): conex. Toate combinatiile de 2 muchii eliminate lasa graful conex. Sunt 10 combinatii. Daca eliminam 3 muchii: (1,2), (1,4), (1,5) - raman (2,3), (3,4) - conex (1,2), (1,4), (2,3) - raman (1,5), (3,4) - conex ... Se pare ca oricate muchii am elimina, mai putin pe toate, graful ramane conex. Numarul total de subgrafuri este 2^5 = 32.  Graful vid nu este conex. Graful initial este conex. Deci avem 32 - 1 - 1 = 30. ] ```cpp // Nu este necesar cod C++ pentru această problemă. ``` Răspuns corect: d. 30"
        },
        "al II-lea": {
            "1": "### a. [Analiza problemei: Trebuie să urmărim execuția algoritmului pentru valoarea de intrare dată și să determinăm valorile afișate.] [Strategia de rezolvare: Executăm manual algoritmul, pas cu pas.] [Răspuns final: a = 240107 c = 0 - b = 240107; x = 0   - b%10 == c (7 == 0) fals   - b = 24010; x = 0   - b%10 == c (0 == 0) adevarat; x = 1   - se iese din repetă - scrie x (1) - c = 2 - b = 240107; x = 0   - b%10 == c (7 == 2) fals   - b = 24010; x = 0   - b%10 == c (0 == 2) fals   - b = 2401; x = 0   - b%10 == c (1 == 2) fals   - b = 240; x = 0   - b%10 == c (0 == 2) fals   - b = 24; x = 0   - b%10 == c (4 == 2) fals   - b = 2; x = 0   - b%10 == c (2 == 2) adevarat; x = 1   - se iese din repetă - scrie x (1) - c = 4 - ... - c = 6 - ... - c = 8 - ... Se afiseaza: 1 1 0 1 0 ] ```cpp // Nu este necesar cod C++ pentru acest subpunct. ``` Răspuns: 1 1 0 1 0  ### b. [Analiza: Trebuie să găsim cel mai mic și cel mai mare număr de 5 cifre distincte, în intervalul [10000, 100000), astfel încât algoritmul să afișeze numai valori nenule (adică 1).] [Strategie: Pentru ca algoritmul să afișeze numai 1, trebuie ca fiecare cifră pară (0, 2, 4, 6, 8) să fie prezentă în număr. Cel mai mic număr: 10246. Cel mai mare număr: 98642.] [Răspuns final: Cel mai mic: 10246. Cel mai mare: 98642.] ```cpp // Nu este necesar cod C++ pentru acest subpunct. ```  ### c. ```cpp #include <iostream>  using namespace std;  int main() {     int a, b, c, x;     cin >> a;     c = 0;     do {         b = a;         x = 0;         do {             if (b % 10 == c) {                 x = 1;             }             b = b / 10;         } while (b != 0 && x != 1);         cout << x << \" \";         c = c + 2;     } while (c <= 9);     cout << endl;     return 0; } ```  ### d. [Analiza: Trebuie să înlocuim a doua structură `repetă...până când` cu o altă structură repetitivă.] [Strategie: Putem folosi `while`. Condiția de continuare a ciclului `while` este negația condiției de oprire a ciclului `do...while`.] [Răspuns final:] ```pseudocod citește a (număr natural) c←0 ┌repetă │ b←a; x←0 │┌cât timp b≠0 și x≠1 execută ││┌dacă b%10=c atunci │││ x←1 ││└■ ││ b←[b/10] │└■ │ scrie x,’ ’ │ c←c+2 └până când c>9 ```",
            "2": "[Analiza: Trebuie să definim o structură `calculator` care conține câmpurile `monitor` (char) și `memorie` (o altă structură, cu câmpurile `interna` și `externa`, ambele int).] [Strategie: Definim structura imbricată `memorie`, apoi structura `calculator`.] [Răspuns final:] ```cpp #include <iostream>  using namespace std;  struct memorie {     int interna;     int externa; };  struct calculator {     char monitor;     memorie memorie; };  int main() {     calculator c;     // Exemplu de utilizare (nu face parte din cerință):     c.monitor = 'L';     c.memorie.interna = 8;     c.memorie.externa = 512;      cout << c.monitor << \" \" << c.memorie.interna << \" \" << c.memorie.externa << endl;      return 0; } ```",
            "3": "[Analiza: Trebuie să completăm o secvență de cod C++ care inițializează o matrice pătratică de 9x9, astfel încât să conțină caracterele '>' și '<' conform modelului dat.] [Strategie: Observăm că: - Primele 5 linii conțin doar '>'. - Linia 5: '<' pe coloana 4. - Linia 6: '<' pe coloanele 3, 4, 5. - Linia 7: '<' pe coloanele 2, 3, 4, 5, 6. - Linia 8: '<' pe coloanele 1, 2, 3, 4, 5, 6, 7. Numărul de caractere '<' crește cu 2 pe fiecare linie, începând de la linia 5.  Poziția primului '<' scade cu 1 pe fiecare linie.] [Răspuns final:] ```cpp #include <iostream>  using namespace std;  int main() {     char a[9][9];     int i, j;      for (i = 0; i < 9; i++) {         for (j = 0; j < 9; j++) {             if (i < 5) {                 a[i][j] = '>';             } else {                 if (j >= (9 - (i + 1)) / 2 && j < 9 - (9 - (i + 1)) / 2)                 {                     a[i][j] = '<';                 }                 else                 {                     a[i][j] = '>';                 }             }         }     }      for (i = 0; i < 9; i++)     {         for (j = 0; j < 9; j++)         {             cout << a[i][j] << \" \";         }         cout << endl;     }      return 0; } ``` Alternativ, o solutie mai simpla: ```cpp for(i=0;i<9;i++)  for(j=0;j<9;j++)     if(i>=5 && j>=4-(i-5) && j<=4+(i-5))         a[i][j]='<';     else         a[i][j]='>'; ```"
        },
        "al III-lea": {
            "1": "[Analiza: Trebuie să scriem un subprogram `suma` care primește doi parametri întregi și returnează suma divizorilor comuni ai acestora.] [Strategie: Calculăm cel mai mare divizor comun (cmmdc) al celor două numere, apoi iterăm de la 1 la cmmdc și adunăm divizorii comuni.] [Răspuns final:] ```cpp #include <iostream>  using namespace std;  int suma(int a, int b) {     int suma_divizori = 0;     int temp;      // Algoritmul lui Euclid pentru cmmdc     while (b != 0) {         temp = b;         b = a % b;         a = temp;     }     int cmmdc = a;      // Suma divizorilor comuni     for (int i = 1; i <= cmmdc; ++i) {         if (cmmdc % i == 0) {             suma_divizori += i;         }     }      return suma_divizori; }  int main() {     cout << suma(20, 12) << endl; // Exemplu de apel: 7     return 0; } ``` O variantă mai eficientă, fără a calcula explicit CMMDC: ```cpp int suma(int a, int b) {     int s = 0;     for (int d = 1; d <= a && d <= b; ++d) {         if (a % d == 0 && b % d == 0) {             s += d;         }     }     return s; } ```",
            "2": "[Analiza: Trebuie să citim un text, să rotim spre stânga cuvintele de cel puțin 3 litere și să afișăm textul modificat.] [Strategie: Citim textul, parcurgem cuvintele, verificăm lungimea, rotim dacă e cazul, și afișăm.] [Răspuns final:] ```cpp #include <iostream> #include <cstring>  using namespace std;  int main() {     char text[101], *cuvant;     char rezultat[101] = \"\";     bool exista = false;      cin.getline(text, 101);      cuvant = strtok(text, \" \");     while (cuvant != NULL) {         if (strlen(cuvant) >= 3) {             exista = true;             char primaLitera = cuvant[0];             for (int i = 0; i < strlen(cuvant) - 1; ++i) {                 cuvant[i] = cuvant[i + 1];             }             cuvant[strlen(cuvant) - 1] = primaLitera;         }         strcat(rezultat, cuvant);         strcat(rezultat, \" \");         cuvant = strtok(NULL, \" \");     }      if (exista) {         cout << rezultat << endl;     } else {         cout << \"nu exista\" << endl;     }      return 0; } ```",
            "3": "### a. [Analiza: Trebuie să verificăm dacă un șir de numere poate fi rearanjat pentru a forma un palindrom. Un șir poate fi rearanjat ca palindrom dacă și numai dacă cel mult un număr apare de un număr impar de ori.] [Strategie: Vom folosi un vector de frecvență pentru a număra aparițiile fiecărui număr. Apoi, vom număra câte numere au frecvență impară. Dacă acest număr este cel mult 1, afișăm \"DA\", altfel \"NU\". Această abordare este eficientă deoarece parcurgem șirul o singură dată pentru a construi vectorul de frecvență și apoi parcurgem vectorul de frecvență (care are o dimensiune maximă constantă, 1000) pentru a număra frecvențele impare. Complexitatea este O(n), unde n este lungimea șirului.] [Răspuns final: Descrierea algoritmului în limbaj natural, justificând eficiența.]  ### b. ```cpp #include <iostream> #include <fstream>  using namespace std;  int main() {     ifstream fin(\"bac.in\");     int frecventa[1001] = {0}; // Inițializăm vectorul de frecvență cu 0     int numar;     int frecvente_impare = 0;      while (fin >> numar) {         frecventa[numar]++;     }      for (int i = 1; i <= 1000; ++i) {         if (frecventa[i] % 2 != 0) {             frecvente_impare++;         }     }      if (frecvente_impare <= 1) {         cout << \"DA\" << endl;     } else {         cout << \"NU\" << endl;     }      fin.close();     return 0; } ```"
        }
    },
    "barem_url": "https://info-hobby.ro/wp-content/uploads/2020/06/E_d_Informatica_2020_sp_MI_bar_06.pdf",
    "exam": {
        "title": "gemini20pro",
        "subject": "Informatica",
        "categories": [
            "Filiera teoretică - Profilul real"
        ]
    }
}